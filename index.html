<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="忍耐力较诸脑力，尤胜一筹。">
<meta name="keywords" content="donghengyi, Hexo, NexT">
<meta property="og:type" content="website">
<meta property="og:title" content="H.Y&#39;s BLOG">
<meta property="og:url" content="https://blog.dhengyi.name/index.html">
<meta property="og:site_name" content="H.Y&#39;s BLOG">
<meta property="og:description" content="忍耐力较诸脑力，尤胜一筹。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="H.Y&#39;s BLOG">
<meta name="twitter:description" content="忍耐力较诸脑力，尤胜一筹。">



  <link rel="alternate" href="/atom.xml" title="H.Y's BLOG" type="application/atom+xml" />




  <link rel="canonical" href="https://blog.dhengyi.name/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>H.Y's BLOG</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '[object Object]');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"></script></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">H.Y's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="undefined" class="github-corner" target="_blank" title="" aria-label=""><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/11/26/感悟-只是遇见你就已经很幸运了！/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/26/感悟-只是遇见你就已经很幸运了！/" itemprop="url">
                  感悟--只是遇见你就已经很幸运了！
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-11-26 23:44:48" itemprop="dateCreated datePublished" datetime="2018-11-26T23:44:48+08:00">2018-11-26</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/感悟/" itemprop="url" rel="index"><span itemprop="name">感悟</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">5.2k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">5 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote class="blockquote-center">不伴随痛楚的教训就没有意义，因为人若无牺牲就不会有收获，然而当战胜这痛楚时，人就将获得不屈服于任何事物的坚强之心，是的，钢铁般的心！<br><br><strong>—钢之炼金术师</strong></blockquote>

<p>最近，正在尝试对自己的性格进行改变，随着年龄以及阅历的增长，越来越觉得决定一个人是否成功，其性格占绝大因素，你是否坚毅，是否阳光，是否开朗，这都属于你性格乃至人格的一部分。虽然说起来容易，但做起来却异常困难，当自卑感，空虚感等等负面情绪向你袭来时，如何迅速的压制住它们，这都需要你一点点的去努力改变。</p>
<p>为什么突然想要改变自己了呢？因为碰到自己喜欢的人了呗，在喜欢的人面前，感觉暴露了自己太多的缺点，优点却还没有被发现，真的是够衰了。。除此之外，也确实觉得，自己已经快22岁啦，该变成自己想成为的人呢，要不然等到以后回望自己的一生，一定会后悔的吧~</p>
<p>好啦，这些废话就不多说了，今天主要是想记录一下最近一年的感情经历，以及从这份稚嫩的情感经历中学习到了什么，一定要有一个健康的爱情观呐~还有，也许有一天你会无意中在网络上看到这篇博客也说不定，那到时的我们，都会做何感想呢？哈哈哈哈…</p>
<p><strong>引言</strong>：我知道岁月一点都不漫长，我想给这个世界，或者最少，给自己在乎的所有人，在乎我的人，给他们留下一些美好的东西，以此证明我在这个世界上来过，正如阿信在歌词中写道：<strong>我不怕死亡，只是害怕被遗忘</strong>~</p>
<p>要想将故事展开，首先需要了解我在这一年中，都经历了什么，这篇博客，也算作对这份回忆的一份记录吧。</p>
<p>该从何说起呢？直接开门见山的说了吧！从去年12月份左右开始，不对，应该是今年1月份左右，自己一厢情愿的！搞了一段时间的“网恋”！可以算作网恋吗？对于自己来说，可以算作吧…一厢情愿的网恋？什么鬼？这是不是你们的第一反应？哈哈，你们会笑话我吗？我当然不怕你们笑话我，卢梭写作《忏悔录》时都不曾畏惧，我又害怕你们笑话我什么呢？为什么说是一厢情愿呢？因为反思过后，我觉得你说的没错，你从来只是把我当做一个可以说话的朋友，而我，从一开始接近你的时候，就“动机不纯”，因此，作为又一次感情上的败北者，现在我倒觉得是理所当然了，自作自受用到自己的身上一点也不为过~</p>
<p>话说我们早在大约两年前就已经有了对方的联系方式，但真正的“熟络”起来，却是在今年1月份左右。从今年的一月份开始，内心突然有点小膨胀，觉得自己马上就要事业有成了（你成个屁，春招简直一塌糊涂，秋招阿里还是没进！你还有资格膨胀？），马上要找工作了！对自己来说，大学三年的时光，过的还算充实，没有辜负自己，因此求得一份较好的工作应该是问题不大的，那么现在是不是应该去找一个自己喜欢的女朋友了？之前一直听学长们说，最好在大学里找一个自己喜欢的人，因为在出入社会以后，真的就很难再找到合适的了（我插一句啊，在现在的我看来，这种观念十分错误！）。刚好那个时候我们又突然联络了一下（有时缘分就是这样），之后我翻看了一下你朋友圈的照片，嗯，不错，是我喜欢的类型（男人就是这么*），因此，我决定去追一追你，结果一不小心，就入坑了~</p>
<p>在没熟络之前，我曾好几次约你出来，结果你都以不太合适为由给拒绝了，那好，我就找话题聊天吧。你很慢热，刚开始，我们完全没有话题，就这样一直尬聊到不知何年何月何天，最终还是让我逮住了一个机会（haha），那天晚上你告诉我说你平时的身体不太好，为了拉近我们之间的距离，我动了一下脑筋，身体不太好？那需要补补？怎么补呢？我又不是医生怎么知道开什么样药方会给女生补身体呢？吃的？对了，就买一些甜食，女生普遍喜欢吃，还能在寒冷的冬天中增加一些热量，haha，就这么办了！之后我就开始在网上给你找零食吃，找到了晚上2点多吧（都不写代码了！！！），现在回想起来，是不是从那个时候开始，我就已经开始掉进自己的美好幻想之中了？不过，你别说，送零食的效果出其的好，我们聊的越来越起劲，开始互道早晚（我当时认为自己已经成功一半了？？事实证明，年轻！）就这样，寒假很快的过去了…现在想起来，那个寒假还真是一点都不觉得寒冷啊~</p>
<p>终于开学啦~终于可以见面啦~不过我做事一直有一个很坏的毛病，喜欢计划，喜欢拖延，思前想后，优柔寡断….当时总觉得，我是不是应该在找到一份不错的实习之后，再去找你，之后，我就可以心无旁骛的去追你了。行，既然这样决定了，那就先好好找实习吧（事实证明，追女孩子这事情，你们tmd就不要拖，这东西可不等人的！）。果不其然，出事了。那天晚上，我们两句话没有说到一块，，就因为我每天按时给你发消息，你却说什么感觉耽误了我的学习，我当时听到这句话，差点没能脑淤血，最后还扯到了三观不同…那天晚上心态爆炸，加上撩妹经验不足，ok，成功暴露了自己的依赖感，原来我一点都不成熟，不，不是不成熟，你只是在感情上真的只是一个菜鸟而已。。。行了，这个时候还不见面，还等什么？但现实真的很喜欢和你开玩笑，从那天晚上开始，脸上突然开始疯狂的长青春痘，不知道是因为过敏还是其他原因，最终的结果就是，脸上成功的开花了，这还怎么见面？彻底完蛋，自信心已经完全丢失，依赖感还在持续暴露，最终彻底拜拜，我成功的搞凉了一段关系，一段压根就没有开始过的关系，，，从陌生人–&gt;……–&gt;陌生人，我做到了。。。</p>
<p>大学四年，应该是这大学四年吧，令我最难受的一段时间来了，在我们的朋友关系彻底冷却后，我还没有拿到自己想要的实习offer，另一方面，这种关系的急速转变，对于我来说，是很难接受的（以前一直以为自己成长了，原来你还是这么的菜！）。那段时间，我深刻的体会到了紫霞仙子说过的一句话：原来爱一个人是这么的痛苦~我硬着头皮找完了实习，但是痘痘还没有减轻。。。也罢，来日方长，以后还有和你见面的机会，现在先着手准备去实习的事情吧。既然找到了实习，那么也该一个人出去散散心了，期间我一个人去石家庄看了场五月天的演唱会，路上还碰到了有趣的小伙伴，哈哈，旅行真的可以让人忘记悲伤呢！对了，在阿信唱“我不愿让你一个人”的时候，我还给你打了电话，但我并没有勇气在电话中说什么，一句话也没有说，最后你就把电话挂了，现在想想，我确实很怂（追女孩就不能怂，但也不要太莽！）。之后基本上就走出了春招时悲伤的阴影，慢慢着眼于实习与秋招准备。</p>
<p>先来说说我的秋招吧，秋招虽然还是没能够进入BAT中梦寐以求的阿里，却也加入了TMD中的美团，因此相对于春招来说，秋招的结果也算令人满意了。好了，工作基本上已经搞定，现在可以去做一些其他的事情了~</p>
<p>时间如白驹过隙，2018年的11月份很过就到来了，距离我们不说话已经将近半年了，脸上的痘痘也消去的差不多啦，期间做了不少的努力，也算挽救了一些我这仅剩的一点颜值。好的！见面！这时候，我就不得不再说一下我到底有多直男（直男癌真的活该单身）了。时隔半年之久，我怀着兴奋、忐忑的心情，给你发的第一条消息：“京东图书满600-400，你要不要买？”，好吧，我现在也觉得，直男是真的活该单身。不过还好，我总算是鼓起勇气给你发了消息（22岁了兄弟，给女孩发个消息还这样，你是真的差劲）。</p>
<p>我们是在赛格见的面，说实话，第一眼看见你的时候，并没有一种心动的感觉，只是觉得，哈，本人和照片差别不大呀（你对我又是怎样的一种印象呢，好奇！）。见面后我就知道你是一个很有自己想法的女孩，你带我吃了火锅，带我看了电影，好吧，出门前舍友交代的东西我已经全忘光了…什么时候觉得你不错的呢？这东西说不准，吃饭的时候？看电影的时候？那个电影真的是我看过的最差劲的电影了，没有和你去看毒液真的是失败！当然，我的心思也没在电影上！看完电影后，我觉得是有一点凉，我当时只想点一首凉凉送给自己，在加上你不让我送你回学校，行吧，我已经完全没有自信了，真是失败透顶，我出地铁的样子，一定很落寞吧，我现在都能想到我出地铁时的那个落寞的背影呢，哈哈。</p>
<p>故事到这里，基本上就已经结束了，我失败了，，，见面终结者。。不过没关系，这次没有春招的时候难受，虽然自己长得不是很帅吧，但感觉也不是那种会招人讨厌的男生，所以觉得问题不大。虽然这次远没有春招的时候让人沮丧，但怎么说呢？还是稍微丧了那么几天吧，但也就是这么几天，孕育出了这篇博客~</p>
<p>首先，我们来看一下我在知乎上摘抄的两句话。</p>
<blockquote><p>我慢慢明白了为什么我不快乐，因为我总是期待一个结果。看一本书期待它让我变得深刻；吃饭、游泳期待它让我一斤斤瘦下；发一条微信期待它被回复；对别人好期待被回待以好；写一个故事说一个心情期待被关注安慰；参加一个活动，期待换来充实丰富的经历。这些预设的期待如果实现了，我长舒一口气，如果没有实现呢，就自怨自艾。可是小时候也是同一个我，用一个下午的时间看蚂蚁搬家，等石头开花。小时候不期待结果，小时候哭笑都不打折。</p>
<footer><strong>晨钟</strong><cite><a href="https://www.zhihu.com/question/68484929/answer/491276288" target="_blank" rel="noopener">有哪些文艺到爆的句子？</a></cite></footer></blockquote>
<hr>
<blockquote><p>我没有很刻意的去想念你，因为我知道遇到了就应该感恩，路过了就需要释怀，我只是在很多很多的小瞬间想起你，比如一部电影，一首歌，一句歌词，一条马路和无数个闭上眼睛的瞬间。</p>
<footer><strong>忘忧不忧</strong><cite><a href="https://www.zhihu.com/question/68484929/answer/524670955" target="_blank" rel="noopener">有哪些文艺到爆的句子？</a></cite></footer></blockquote>
<hr>
<p>爱而不得很痛苦吗？是的，对于大部分人来说，都是痛苦的，长久的付出得不到自己想要的回应，犹如向大海中扔出千斤重石却激不起一层浪花一样让人无比无奈与沮丧。我理解这种心情。可是啊，这是一种正确的爱情观吗？爱而不得，影响了很多人正常的生活，阻碍了很多人不断向前拼搏的步伐，现在看来，这些都是有意义的作为吗？拷问一下自己的灵魂吧，你是真的喜欢她，还只是出于寂寞？如果你真的喜欢她，只要她幸福，不就应该足够了吗？并且，健康的恋爱观，不是应该两个人相互吸引，互相努力，不断变得更优秀吗？如果你每天都这么悲观，不去想着怎么将自己变的更加优秀，变得更加强大，如何去保护你喜欢的人呢？去保护你想要保护的人呢？</p>
<p>人的一生这么短啊，就像我的兄弟说的那样，不要将时间浪费在一些没有意义的事情上。你需要变的更加强大，但是，千万不要将为了得到一个女孩子的喜欢作为目标与动力去提升自己，这样做，是真的很不靠谱，最后有可能会击垮你的自信心。我们每个人都应该找到一个属于自己的生活的意义，为了那份真实的意义去努力，我们才会变得热爱生活，热爱生命。我们始终要先学会如何去爱自己，才能有资格去爱别人！我一直相信爱情是世间最美好的感情之一，但爱情也绝不是生活的全部，美好的爱情，只是生活中的一剂调味品，好好生活，最终才能品尝到这份调位品的美好味道~</p>
<p>再说，如果你真的喜欢一个女孩子，就尝试着去揣摩她的心思吧，投她之所好，爱她之所爱，我们每个人都不妨大胆一点，不要怕被女孩子拒绝。在我们的一生中，并不会遇见太多的自己真正喜欢的人，所以啊，在你还喜欢她的日子里，努力去给她展现自己最好的模样，有机会的，再努力一点点多关心关心她，不求回报，只求在自己还喜欢那个人的时候，愿意用自己的温柔，为她倾倒整个世界~这样的你，日后一定不会后悔吧~</p>
<p>最后，希望我们在爱情中，都能展现自己最自信的一面。还有啊，记得不管什么时候，请务必保持一份理智，因为你需要把自己的温柔，能交给对的，值得被温柔以待的人（好的女孩子），别让一切的一切，都付诸东流啦~</p>
<p>在博客的最后，我再送给大家一段曾经在网易云音乐中看到过的评论：</p>
<blockquote>
<p>按理说，我这么这么喜欢你，真应该从长计议步步为营的筹谋一切，让你慢慢上瘾直到离不开我。可我已经没有理智了，也没有问过你同不同意，就一腔热血的投入了所有感情，吓到你的话真的对不起，可我…在你面前无法克制。</p>
</blockquote>
<p>送给大家一份我喜爱的AMV：视频原链接-<a href="https://www.bilibili.com/video/av1256375" target="_blank" rel="noopener">【钢炼】Don’t forget【永远不会忘记钢之炼金术师】</a>。</p>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"/2018/11/26/感悟-只是遇见你就已经很幸运了！/Don%27t%20forget.mp4"},"danmaku":{"api":"https://api.prprpr.me/dplayer3/","addition":["https://api.prprpr.me/dplayer/v3/bilibili?aid=1256375"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>
<p>至于怎么去追女孩子这个问题嘛，说实话，这的确是一门学问，尤其在你还不是一名帅哥的时候，更加需要你去努力的学习。对了，还有最后一件事，在追女孩子的时候，要将这八个关键字牢记在心：不要卑微，心态放好~ </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/10/03/Java并发-原子变量类的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/Java并发-原子变量类的使用/" itemprop="url">
                  Java并发--原子变量类的使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-03 13:51:16" itemprop="dateCreated datePublished" datetime="2018-10-03T13:51:16+08:00">2018-10-03</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java并发/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.8k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">9 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注</strong>：本篇博客主要内容来源于网络，侵删~</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>我们假设你已经熟练掌握了CAS，原子变量类等的相关概念。这篇博客中，我们主要讨论原子变量类的使用。</p>
<hr>
<h2 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a><strong>原子变量类</strong></h2><p>原子变量类共12个，分4组：</p>
<ol>
<li>计数器：<code>AtomicInteger</code>，<code>AtomicLong</code>，<code>AtomicBoolean</code>，<code>AtomicReference</code>。</li>
<li>域更新器：<code>AtomicIntegerFieldUpdater</code>，<code>AtomicLongFieldUpdater</code>，<code>AtomicReferenceFieldUpdater</code>。</li>
<li>数组：<code>AtomicIntegerArray</code>，<code>AtomicLongArray</code>，<code>AtomicReferenceArray</code>。</li>
<li>复合变量：<code>AtomicMarkableReference</code>，<code>AtomicStampedReference</code>。</li>
</ol>
<p>在每组中我会选择其中一个较有代表性的进行分析与举例。</p>
<h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a><strong>AtomicReference</strong></h3><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a><strong>使用说明</strong></h4><p>AtomicReference的作用是对”对象”进行原子操作。</p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1848883965231344442L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取Unsafe对象，Unsafe的作用是提供CAS操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取相应字段相对Java对象的“起始地址”的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// volatile类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">(V initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            V x = get();</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(x, newValue))</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于上述代码只有两点需要强调：</p>
<ol>
<li><code>valueOffset = unsafe.objectFieldOffset(AtomicReference.class.getDeclaredField(&quot;value&quot;))</code> 通过相关字段的偏移量获取值比直接使用反射获取相应字段的值性能要好许多；</li>
<li>关于lazySet，推荐阅读这一篇博客：<a href="http://ifeve.com/juc-atomic-class-lazyset-que/" target="_blank" rel="noopener">JUC中Atomic Class之lazySet的一点疑惑</a>。</li>
</ol>
<h4 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a><strong>使用举例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"id:"</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个Person对象，它们的id分别是101和102。</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">101</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">102</span>);</span><br><span class="line">        <span class="comment">// 新建AtomicReference对象，初始化它的值为p1对象</span></span><br><span class="line">        AtomicReference ar = <span class="keyword">new</span> AtomicReference(p1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。</span></span><br><span class="line">        ar.compareAndSet(p1, p2);</span><br><span class="line"> </span><br><span class="line">        Person p3 = (Person)ar.get();</span><br><span class="line">        System.out.println(<span class="string">"p3 is "</span>+p3);</span><br><span class="line">        System.out.println(<span class="string">"p3.equals(p1)="</span>+p3.equals(p1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a><strong>AtomicReferenceFieldUpdater</strong></h3><p>接下来所有的原子变量类不再进行源码分析。事实上所有原子变量类的实现都大同小异，感兴趣的同学可以阅读源码。</p>
<h4 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a><strong>使用说明</strong></h4><p>一个基于反射的工具类，它能对指定类的指定的volatile引用字段进行原子更新。(注意这个字段不能是private的) </p>
<p>通过调用AtomicReferenceFieldUpdater的静态方法newUpdater就能创建它的实例，该方法要接收三个参数： </p>
<ol>
<li>包含该字段的对象的类;</li>
<li>将被更新的对象的类;</li>
<li>将被更新的字段的名称。</li>
</ol>
<h4 id="使用举例-1"><a href="#使用举例-1" class="headerlink" title="使用举例"></a><strong>使用举例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">volatile</span> String name = <span class="string">"dog1"</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Dog.class, String.class, <span class="string">"name"</span>);</span><br><span class="line">        Dog dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line">        updater.compareAndSet(dog1, dog1.name, <span class="string">"test"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(dog1.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicReferenceArray"><a href="#AtomicReferenceArray" class="headerlink" title="AtomicReferenceArray"></a><strong>AtomicReferenceArray</strong></h3><h4 id="使用说明-2"><a href="#使用说明-2" class="headerlink" title="使用说明"></a><strong>使用说明</strong></h4><p>可以用原子方式更新其元素的对象引用数组。</p>
<p>以下是AtomicReferenceArray类中可用的重要方法的列表：</p>
<table>
<thead>
<tr>
<th>序列</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>public AtomicReferenceArray(int length)</td>
<td>构造函数，创建给定长度的新 AtomicReferenceArray。</td>
</tr>
<tr>
<td>2</td>
<td>public AtomicReferenceArray(E[] array)</td>
<td>构造函数，创建与给定数组具有相同长度的新 AtomicReferenceArray，并从给定数组复制其所有元素。</td>
</tr>
<tr>
<td>3</td>
<td>public boolean compareAndSet(int i, E expect, E update)</td>
<td>如果当前值==期望值，则将位置i处的元素原子设置为给定的更新值。</td>
</tr>
<tr>
<td>4</td>
<td>public E get(int i)</td>
<td>获取位置i的当前值。</td>
</tr>
<tr>
<td>5</td>
<td>public E getAndSet(int i, E newValue)</td>
<td>将位置i处的元素原子设置为给定值，并返回旧值。</td>
</tr>
<tr>
<td>6</td>
<td>public void set(int i, E newValue)</td>
<td>将位置i处的元素设置为给定值。</td>
</tr>
</tbody>
</table>
<h4 id="使用举例-2"><a href="#使用举例-2" class="headerlink" title="使用举例"></a><strong>使用举例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子引用数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] source = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReferenceArray&lt;String&gt; atomicReferenceArray = <span class="keyword">new</span> AtomicReferenceArray&lt;String&gt;(source);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; atomicReferenceArray.length(); i++) &#123;</span><br><span class="line">            atomicReferenceArray.set(i, <span class="string">"item-2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Increment());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Compare());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Increment</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; atomicReferenceArray.length(); i++) &#123;</span><br><span class="line">                String add = atomicReferenceArray.getAndSet(i, <span class="string">"item-"</span> + (i+<span class="number">1</span>));</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() </span><br><span class="line">                    + <span class="string">", index "</span> + i + <span class="string">", value: "</span> + add);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; atomicReferenceArray.length(); i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() </span><br><span class="line">                    + <span class="string">", index "</span> + i + <span class="string">", value: "</span> + atomicReferenceArray.get(i));</span><br><span class="line">                <span class="keyword">boolean</span> swapped = atomicReferenceArray.compareAndSet(i, <span class="string">"item-2"</span>, <span class="string">"updated-item-2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Item swapped: "</span> + swapped);</span><br><span class="line">                <span class="keyword">if</span>(swapped) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() </span><br><span class="line">                        + <span class="string">", index "</span> + i + <span class="string">", updated-item-2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><h4 id="使用说明-3"><a href="#使用说明-3" class="headerlink" title="使用说明"></a><strong>使用说明</strong></h4><p>AtomicStampedReference主要用来解决在使用CAS算法的过程中，可能会产生的<strong>ABA问题</strong>。一般我们会使用带有版本戳version的记录或对象标记来解决ABA问题，AtomicStampedReference<e>实现了这个作用，它通过包装[E, Integer]的元组来对对象标记版本戳stamp。</e></p>
<p>以下是AtomicStampedReference类中可用的重要方法的列表：</p>
<table>
<thead>
<tr>
<th>序列</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>public AtomicStampedReference(V initialRef, int initialStamp)</td>
<td>构造方法，传入引用和戳。</td>
</tr>
<tr>
<td>2</td>
<td>public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</td>
<td>如果当前引用 == 预期值并且当前版本戳 == 预期版本戳，将更新新的引用和新的版本戳到内存。</td>
</tr>
<tr>
<td>3</td>
<td>public void set(V newReference, int newStamp)</td>
<td>设置当前引用的新引用和版本戳。</td>
</tr>
<tr>
<td>4</td>
<td>public boolean attemptStamp(V expectedReference, int newStamp)</td>
<td>如果当前引用 == 预期引用，将更新新的版本戳到内存。</td>
</tr>
</tbody>
</table>
<h4 id="使用举例-3"><a href="#使用举例-3" class="headerlink" title="使用举例"></a><strong>使用举例</strong></h4><p>下面的代码分别用AtomicInteger和AtomicStampedReference来对初始值为100的原子整型变量进行更新，AtomicInteger会成功执行CAS操作，而加上版本戳的AtomicStampedReference对于ABA问题会执行CAS失败：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInt = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference atomicStampedRef = <span class="keyword">new</span> AtomicStampedReference(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread intT1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                atomicInt.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">                atomicInt.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread intT2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> c3 = atomicInt.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">                System.out.println(c3);         <span class="comment">// true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        intT1.start();</span><br><span class="line">        intT2.start();</span><br><span class="line">        intT1.join();</span><br><span class="line">        intT2.join();</span><br><span class="line"></span><br><span class="line">        Thread refT1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                atomicStampedRef.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">                atomicStampedRef.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread refT2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> stamp = atomicStampedRef.getStamp();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> c3 = atomicStampedRef.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">                System.out.println(c3);         <span class="comment">// false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        refT1.start();</span><br><span class="line">        refT2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="性能比较：锁与原子变量"><a href="#性能比较：锁与原子变量" class="headerlink" title="性能比较：锁与原子变量"></a><strong>性能比较：锁与原子变量</strong></h2><p>事实上，CAS的性能总是优于锁。我们分两种情况进行讨论。</p>
<p><strong>1. 线程间竞争程度较高</strong></p>
<p>对于锁来说，激烈的竞争意味着线程频繁的挂起与恢复，频繁的上下文切换，这些操作都是非常耗费系统资源的；对于CAS算法来说，激烈的竞争意味着线程将对竞争进行频繁的处理（重试，回退，放弃等策略）。</p>
<p>即使如此，一般来说，CAS算法的性能依旧优于锁。</p>
<p><strong>2. 线程间竞争程度较低</strong></p>
<p>较低的竞争程度意味着CAS操作总是能够成功；对于锁来说，虽然锁之间的竞争度也随之下降，但由于获取锁与释放锁的操作不但耗费系统资源，并且其中本身就包含着CAS操作，因此在这种情况下，CAS操作的性能依旧优于锁。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>这篇博客并没有讲述CAS操作以及可能产生的ABA问题，但是我们必须熟悉这两个知识点；</li>
<li>这篇博客的主要目的是构建起大家对原子变量类的一个认识，以至于在以后的项目开发中，可以去思考如何使用这些原子变量类；</li>
<li>对于原子变量与锁之间的优势与劣势，性能间的比较，有一个较为清晰的认识。</li>
</ol>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>Java并发编程实战</p>
<p><a href="https://www.yiibai.com/java_concurrency/concurrency_atomicreferencearray.html" target="_blank" rel="noopener">Java并发AtomicReferenceArray类</a></p>
<p><a href="https://www.cnblogs.com/java20130722/p/3206742.html" target="_blank" rel="noopener">用AtomicStampedReference解决ABA问题</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/09/27/Java并发-深入理解显式锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/27/Java并发-深入理解显式锁/" itemprop="url">
                  Java并发--深入理解显式锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-27 15:46:50" itemprop="dateCreated datePublished" datetime="2018-09-27T15:46:50+08:00">2018-09-27</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java并发/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">6.4k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">6 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注</strong>：本篇博客部分内容引用自：<a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java并发编程：Lock</a></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>在Java 5.0之前，协调对共享对象的访问可以使用到的机制只有synchronized和volatile。在Java 5.0之后，增加了一种新的机制：ReentrantLock。ReentrantLock并不是一种替代内置锁的方法，而是在内置锁不再适用的情况下，作为一种可选择的高级功能。</p>
<hr>
<h2 id="既生synchronized，何生Lock"><a href="#既生synchronized，何生Lock" class="headerlink" title="既生synchronized，何生Lock"></a><strong>既生synchronized，何生Lock</strong></h2><p>synchronized主要在功能上存在一些局限性。</p>
<p>如果获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p>
<p>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p>
<p>如果采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，那么当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p>
<p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p>
<p>值得注意的是：<strong>在使用Lock时，我们必须在finally块中释放锁！</strong></p>
<p>如果在被保护的代码块中抛出了异常，那么这个锁永远都无法被释放。如果没有使用finally来释放锁，当出现问题时，将很难追踪到最初发生错误的位置，因为我们没有记录应该释放锁的位置与时间。</p>
<p><strong>这就是ReentrantLock不能完全替代synchronized的原因：它更加危险，因为当程序的执行控制离开被保护的代码块时，不会自动清除锁。</strong></p>
<p><strong>注</strong>：FindBugs可以帮助你找到未释放的锁。</p>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a><strong>Lock接口</strong></h2><h3 id="认识Lock"><a href="#认识Lock" class="headerlink" title="认识Lock"></a><strong>认识Lock</strong></h3><p>我们先来看一下Lock接口的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 可中断的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 轮询锁与定时锁</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 本节并不需要关注</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ReentrantLock是唯一实现了Lock接口的类</strong>。在获取（释放）ReentrantLock时，有着与进入（退出）同步代码块相同的内存语义，与synchronized一样，ReentrantLock还提供了<strong>可重入</strong>的加锁语义。</p>
<h3 id="tryLock方法"><a href="#tryLock方法" class="headerlink" title="tryLock方法"></a><strong>tryLock方法</strong></h3><p>tryLock只有在成功获取了锁的情况下才会返回true，如果别的线程当前正持有锁，则会立即返回false！如果为这个方法加上timeout参数，则会等待timeout的时间才会返回false或者在获取到锁的时候返回true。</p>
<p>在内置锁中，死锁是一个严重的问题，恢复程序的唯一方法是重启程序，而防止死锁的唯一方法就是在构造程序时避免出现不一致的锁顺序。可定时与可轮询的锁提供了另一种方式：避免死锁的发生。</p>
<p>如果不能获取所有需要的锁，那么可以使用可定时或可轮询的锁获取方式，从而使你重新获得控制权，它会释放已经获得的锁，然后重新尝试获取所有锁。无参数的tryLock一般用作轮询锁，而带有TimeUnit参数的一般用作定时锁。</p>
<p>考虑如下程序，它将资金从一个账户转入另一个账户。在开始转账之前，首先要获得这两个Account对象的锁，以确保通过原子方式来更新两个账户中的余额，同时又不破坏一些不变性条件，如：“账户的余额不能为负数”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount, Account toAccount, DollarAmount amount)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InsufficientResourcesException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (fromAccount) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAccount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span>  <span class="keyword">new</span> InsufficientResourcesException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fromAccount.debit(amount);</span><br><span class="line">                toAccount.credit(amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序看似无害，实则会发生死锁。如果两个线程同时调用transferMoney，其中一个线程从X向Y转账，另一个线程从Y向X转账，那么就会发生死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: transferMoney(myAccount, yourAccount, 10);</span><br><span class="line">B: transferMoney(yourAccount, myAccount, 20);</span><br></pre></td></tr></table></figure>
<p>如果执行顺序不当，那么A可能获得myAccount的锁并等待yourAccount的锁，然而B此时持有yourAccount的锁并等待myAccount的锁，就会发生死锁。</p>
<p>我们可以使用tryLock用作轮询锁来解决这样的问题，使用tryLock来获取两个锁，如果不能同时获得，则退回并重新尝试。程序中锁获取的休眠时间包括固定部分和随机部分，从而降低了发生<a href="https://baike.baidu.com/item/%E6%B4%BB%E9%94%81/5096375" target="_blank" rel="noopener">活锁</a>的可能性。如果在指定时间内不能获得所有需要的锁，那么transferMoney将返回一个失败状态，从而使该操作平缓的失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transferMoney</span><span class="params">(Account fromAcct, Account toAcct, DollarAmount amount, <span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit)</span> <span class="keyword">throws</span> InsufficientResourcesException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> fixedDelay = getFixedDelayComponentNanos(timeout, unit);</span><br><span class="line">    <span class="keyword">long</span> randMod = getRandomDelayModulusNanos(timeout, unit);</span><br><span class="line">    <span class="keyword">long</span> stopTime = System.nanoTime() + unit.toNanos(timeout);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromAcct.lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (toAcct.lock.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientResourcesException();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            fromAccount.debit(amount);</span><br><span class="line">                            toAccount.credit(amount);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        toAcct.lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                fromAcct.lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (System.nanoTime() &lt; stopTime) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryLock用作定时锁的程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trySendOnSharedLine</span><span class="params">(String message, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanosToLock = unit.toNanos(timeout) - estimatedNanosToSend(message);</span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock(nanosToLock, NANOSECONDS)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> trySendOnSharedLine(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述程序试图在Lock保护的共享通信线路上发送一条消息，如果不能在指定的时间内完成，代码就会失败。定时的tryLock能够在这种带有时间限制的操作中实现独占加锁的行为。</p>
<h3 id="lockInterruptibly方法"><a href="#lockInterruptibly方法" class="headerlink" title="lockInterruptibly方法"></a><strong>lockInterruptibly方法</strong></h3><p>lockInterruptibly方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p>
<p>由于在lockInterruptibly方法的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly的方法外声明抛出InterruptedException。</p>
<p>因此lockInterruptibly一般的使用形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">// .....</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，当一个线程获取了锁之后，是不会被interrupt方法中断的。因为单独调用interrupt方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过lockInterruptibly方法获取某个锁时，如果不能获取到，只有在进行等待的情况下，是可以响应中断的。</p>
<p>定时的tryLock同样能够响应中断，因此当需要实现一个定时的和可中断的锁获取操作时，可以使用tryLock方法。</p>
<hr>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a><strong>公平锁</strong></h2><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁，这种就是公平锁。</p>
<p>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p>
<p>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p>
<p>在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p>
<pre><code>ReentrantLock lock = new ReentrantLock(true);
</code></pre><p>参数为true表示为公平锁，为fasle为非公平锁。默认情况下，如果使用无参构造器，则是非公平锁。</p>
<p>另外在ReentrantLock类中定义了很多方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isFair()            <span class="comment">//判断锁是否是公平锁</span></span><br><span class="line"></span><br><span class="line">isLocked()          <span class="comment">//判断锁是否被任何线程获取了</span></span><br><span class="line"></span><br><span class="line">isHeldByCurrentThread()     <span class="comment">//判断锁是否被当前线程获取了</span></span><br><span class="line"></span><br><span class="line">hasQueuedThreads()          <span class="comment">//判断是否有线程在等待该锁</span></span><br></pre></td></tr></table></figure>
<p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p>
<hr>
<h2 id="在synchronized与ReentrantLock之间进行抉择"><a href="#在synchronized与ReentrantLock之间进行抉择" class="headerlink" title="在synchronized与ReentrantLock之间进行抉择"></a><strong>在synchronized与ReentrantLock之间进行抉择</strong></h2><p>在性能上，Java 5.0中ReentrantLock远远优于内置锁，而在Java 6.0中则是略有胜出。</p>
<p>我们建议，仅当内置锁不能满足需求时，才可以考虑使用ReentrantLock。</p>
<p>在Java 8.0中，内置锁的性能已经不压于ReentrantLock，并且未来更可能会继续提升synchronized的性能，毕竟synchronized是JVM的内置属性。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>清楚为什么有Lock接口；</li>
<li>清楚使用ReentrantLock有什么优缺点；</li>
<li>掌握如何使用ReentrantLock（定时锁，轮询锁，中断锁以及一些其他功能）；</li>
<li>能够在synchronized与Lock中做出选择。</li>
</ol>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>Java并发编程实战</p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java并发编程：Lock</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/09/13/Java并发-深入理解线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/Java并发-深入理解线程池/" itemprop="url">
                  Java并发--深入理解线程池
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-13 21:38:05" itemprop="dateCreated datePublished" datetime="2018-09-13T21:38:05+08:00">2018-09-13</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java并发/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">10k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">9 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a><strong>为什么需要线程池</strong></h2><p>在生产环境中，我们不能无限制的创建线程，主要原因如下：</p>
<ol>
<li>线程创建与销毁的代价并不低；</li>
<li>如果可运行的线程数量多于可用处理器的数量，有些线程将会闲置，大量闲置的线程会消耗系统资源（内存）并给垃圾收集器带来压力；</li>
<li>大量线程竞争CPU也会造成不小的性能开销。</li>
</ol>
<hr>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a><strong>Executor框架</strong></h2><p>Executor框架在Java 5中被引入，其内部使用了线程池机制。它在java.util.cocurrent包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。</p>
<p>Executor框架包括：线程池，Executor，Executors，ExecutorService等（Callable与Future本篇不进行讨论）。</p>
<h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a><strong>Executor接口</strong></h3><p>我们先来了解一下其中的Executor接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Executor接口的定义非常简单，但它却为灵活且强大的异步任务执行框架提供了能够支持多种不同类型任务的执行策略。它提供一种标准的方法将任务的提交过程与执行过程进行了解耦。</p>
<p>Executor接口基于生产者 — 消费者模型，提交任务的操作相当与生产者，执行任务的线程相当于消费者。</p>
<p>线程池的实现操作了Executor接口，但现在，我们只关心它是如何将任务提交与任务执行进行解耦的。来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/4 23:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutionWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 任务创建</span></span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务提交与执行</span></span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上述代码进行修改，将任务的执行改为为每个任务都创建新的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/5 9:37</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以对其进行修改，使TaskExecutionWebServer的行为类似于单线程的行为，即以同步的方式执行每个任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/5 9:43</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithinThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用Executor，我们将任务的提交与执行进行了解耦，我们只需采用另一种不同的Executor实现，就完全可以改变应用程序的行为。改变Executor实现或配置所带来的影响要远远小于改变任务提交方式带来的影响。</p>
<h3 id="Executor的生命周期—ExecutorService接口"><a href="#Executor的生命周期—ExecutorService接口" class="headerlink" title="Executor的生命周期—ExecutorService接口"></a><strong>Executor的生命周期—ExecutorService接口</strong></h3><p>我们已经知道了如何创建一个Executor，但JVM只有在所有非守护线程全部终止后才会退出，因此我们还需讨论一下Executor如何关闭。</p>
<p>关闭应用程序的方式我们通常分为两种：</p>
<ol>
<li>平缓的关闭：完成所有已启动的任务，拒绝接受新任务。</li>
<li>粗暴的关闭：直接取消所有任务，拒绝接受新任务。</li>
</ol>
<p>为了便于管理执行服务的生命周期，Executor扩展了ExecutorService接口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 平缓的关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 粗暴的关闭</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 等待终止，通常在调用此方法后会立即调用shutdown，从而产生同步关闭ExecutorService的效果</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... ... 其他用于任务提交的便利方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecutorService的生命周期有三种状态：运行，关闭，终止。</p>
<p>创建ExecutorService时处于运行态（RUNNING）。我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，在调用这两个方法之一后，线程池将不再接收新任务。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p>
<p>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭，且任务缓存队列已经清空或执行结束后才表示线程池关闭成功，进入终止态（TERMINATED），这时调用isTerminaed方法会返回true。</p>
<h3 id="线程池的创建—Executors"><a href="#线程池的创建—Executors" class="headerlink" title="线程池的创建—Executors"></a><strong>线程池的创建—Executors</strong></h3><p>关于线程池的优势不再多说。我们可以通过Executors中的静态工厂方法创建一个线程池：</p>
<ol>
<li><strong>newFixedThreadPool</strong>：创建固定大小的线程池，每当提交一个任务就创建一个线程，直到达到线程池最大数量，如果某个线程发生了Exception异常，线程池会补充一个新线程；</li>
<li><strong>newCachedThreadPool</strong>：可缓存线程池，如果线程池中有空闲的线程，那么将会回收空闲线程，当任务数量增加时，则添加新的线程，线程池的规模不受限制；</li>
<li><strong>newSingleThreadExecutor</strong>：单线程Executor，如果此线程出现异常，会创建另一个线程进行替代。它会确保依照任务在队列中的顺序来串行执行；</li>
<li><strong>newScheduledThreadPool</strong>：创建固定大小线程池并以延迟或定时的方式来执行任务。</li>
</ol>
<hr>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a><strong>线程池的使用</strong></h2><h3 id="认识ThreadPoolExecutor"><a href="#认识ThreadPoolExecutor" class="headerlink" title="认识ThreadPoolExecutor"></a><strong>认识ThreadPoolExecutor</strong></h3><p>如果Executors提供默认的静态工厂方法创建的线程池不能满足需求，我们可以通过ThreadPoolExecutor的构造函数实例化一个对象，根据自己的需求定制相应线程池，ThreadPoolExecutor定义了许多构造函数，我们给出最常见的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实通过源码我们可以知道：ThreadPoolExecutor继承了类AbstractExecutorService，抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法，ExecutorService接口继承了Executor接口，因此ThreadPoolExecutor也基于Executor接口。</p>
<p>我们分模块对上述参数进行描述。</p>
<h3 id="线程的创建与销毁"><a href="#线程的创建与销毁" class="headerlink" title="线程的创建与销毁"></a><strong>线程的创建与销毁</strong></h3><p>corePoolSize（基本大小），maximumPoolSize（最大大小），keepAliveTime（存活时间）等因素共同负责线程的创建与销毁。</p>
<p><strong>基本大小</strong>：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。只有在工作队列满时才会创建超出这个数量的线程；<br><strong>最大大小</strong>：线程池中可同时活动的线程数量的上限。若某个线程的空闲时间超过存活时间，则此线程被标记为可回收，并当线程池当前大小超过基本大小时，此线程将被终止。</p>
<p>newFixedThreadPool工厂方法将线程池的基本大小与最大大小设置为参数中指定的值并且两者相等，且创建的线程池不会超时；newCachedThreadPool工厂方法将线程池的最大大小设为Integer.MAX_VALUE，而将基本大小设置为0，超时设置为1分钟。其他形式的线程池可以通过显式的ThreadPoolExecutor构造函数进行构造。</p>
<p><strong>注</strong>：在将基本大小设置为0之后，有一些值得注意的事项。只有当线程池中的线程数量等于线程池的基本大小并且工作队列已满的情况下，ThreadPoolExecutor才会创建新的线程。因此，如果线程池的基本大小为0，但工作队列还有容量，那么把任务交给线程池时，只有当线程池的工作队列被填满之后，才会执行任务。这通常不是我们所期望的。（将基本大小设置为0的主要目的为当没有任务执行时，销毁工作线程以免阻碍JVM的退出）</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a><strong>任务队列</strong></h3><p>当任务到达线程池的速率超过了线程池的处理速率，那么新到来的任务将会累积起来，我们在线程池中使用一个由Executor管理的Runnable队列来保存等待执行的任务。使用任务队列的好处在于降低了这些任务对CPU资源的竞争，任务队列可以缓解任务的突增问题，但如果任务持续高速的到来，依旧可能耗尽内存资源（阻塞队列没有边界）。</p>
<p>任务队列分为三种：有界队列，无界队列，同步移交。</p>
<p>newFixedThreadPool和newSingleThreadExecutor在默认情况下都使用无界队列：LinkedBlockingQueue。</p>
<p>我们建议使用有界队列，例如：ArrayBlockingQueue，有界的LinkedBlockingQueue，PriorityBlockingQueue。有界队列有助于避免资源的耗尽。</p>
<p>在newCachedThreadPool中则使用了SynchronousQueue（Java 5，在Java 6中提供了一个新的非阻塞算法来替代了SynchronousQueue）。SynchronousQueue并不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入SynchronousQueue中，必须要有另一个线程正在等待接收这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，则ThreadPoolExecutor将创建一个新的线程，否则将拒绝这个任务。只有当线程池是无界的或是可以拒绝任务时，SynchronousQueue才具有实际价值。使用这种方式的优势很明显：任务会直接移交给执行它的线程，而不是被首先放在队列中。</p>
<p>对于Executor，newCachedThreadPool是一种很好的默认选择。</p>
<p>只有任务独立，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或工作队列则可能导致线程出现“饥饿”死锁问题，此时应使用无界线程池如：newCachedThreadPool。</p>
<h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a><strong>线程工厂</strong></h3><p>线程池中的线程都是由线程工厂进行创建的。默认的线程工厂创建一个新的，非守护的线程。我们可以通过指定一个线程工厂方法，来定制线程池的配置信息。ThreadFactory接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当线程池中创建一个新线程，都会调用这个newThread方法。</p>
<p>通常，我们都会使用定制的线程工厂方法，我们可能希望实例化一个定制的Thread类用于执行调试信息的记录，可能希望修改线程优先级，或者只是为了给线程取一个更有意义的名字。在如下程序中，我们给出一个自定义的线程工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/12 22:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span><span class="params">(String poolName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolName = poolName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAppThread(r, poolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以在MyAppThread中定制其他行为，包括为线程指定名字，设置自定义的UncaughtExceptionHandler向Logger中写入信息，维护一些统计信息（多少个线程被创建与销毁），在线程被创建或终止时把调试信息写入日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/12 21:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"MyAppThread"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> debugLifecycle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger created = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger alive = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = Logger.getAnonymousLogger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(runnable, DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable runnable, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(runnable, name + <span class="string">"-"</span> + created.incrementAndGet());</span><br><span class="line">        setUncaughtExceptionHandler(</span><br><span class="line">                <span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">                        log.log(Level.SEVERE, <span class="string">"UNCAUGHT in thread"</span> + t.getName(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> debug = debugLifecycle;</span><br><span class="line">        <span class="keyword">if</span> (debug) log.log(Level.FINE, <span class="string">"Created "</span> + getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            alive.incrementAndGet();</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            alive.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (debug) log.log(Level.FINE, <span class="string">"Exiting "</span> + getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsCreated</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> created.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> alive.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> debugLifecycle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        debugLifecycle = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a><strong>饱和策略</strong></h3><p>当有界队列被填满之后，饱和策略开始发挥作用。我们可以通过ThreadPoolExecutor的setRejectedExecutionHandler方法来选择不同的饱和策略。JDK主要提供了以下几种不同的饱和策略：</p>
<ol>
<li>AbortPolicy（中止策略）：默认的饱和策略，会抛出未检查的RejectedExecutionException。我们可以捕获这个异常，并按需编写自己的处理代码。</li>
<li>DiscardPolicy（抛弃策略）：当任务队列已满，抛弃策略会抛弃该任务。</li>
<li>DiscardOldestPolicy（抛弃最旧策略）：会抛弃下一个将要执行的任务（入队最早的任务，可以理解为最旧的任务），然后尝试重新提交新任务。</li>
<li>CallerRunsPolicy（调用者运行策略）：该策略不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者。它不会在线程池中的某个线程中执行任务，而是在调用了execute的线程中执行该任务。因此当工作队列已满，并且线程池中线程数量已达maximumPoolSize时，下一个任务会在调用execute的主线程中执行。由于任务执行需要一定的时间，因此主线程在这段时间内不会调用accept，因此到达的请求将被保存在TCP层的队列中而不是应用程序的队列中。如果持续过载，那么TCP层的缓冲队列也将会被填满，因此同样会抛弃请求。但对于服务器来说，这种过载情况是逐渐向外蔓延开的 — 从线程池队列到应用程序再到TCP层，最终到达客户端，这是一种平缓的性能降低。</li>
</ol>
<p>如下，我们使用了“调用者运行”饱和策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(N_THREADS, N_THREADS, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(CAPACITY));</span><br><span class="line"></span><br><span class="line">executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><strong>1. 熟悉Executor框架；</strong></p>
<p>注：所有的线程池都基于Executor接口，ExecutorService接口继承于Executor，提供了对线程池生命周期的管理，Executors提供了默认的几种创建线程池的工厂方法。</p>
<p><strong>2. 熟练掌握ThreadPoolExecutor的使用，熟悉ThreadPoolExecutor中各个参数使用及含义；</strong></p>
<p>注：当默认提供的线程池不能满足自己的需求，我们就需要通过ThreadPoolExecutor定制线程池。</p>
<p><strong>3. 线程池还有诸多细节；</strong></p>
<p>注：如何合理配置线程池的大小，继承ThreadPoolExecutor对其进行扩展（beforeExecutor，afterExecutor，terminated）</p>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>Java并发编程实战</p>
<p><a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="noopener">聊聊并发 — Java线程池的分析和使用</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a> — 很详细的一篇博客，其中还讨论了线程池的实现细节</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/06/28/计算机网络-详解P2P对等网络（二）—Chord算法研究与分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/28/计算机网络-详解P2P对等网络（二）—Chord算法研究与分析/" itemprop="url">
                  计算机网络--详解P2P对等网络（二）—Chord算法研究与分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-28 21:24:59" itemprop="dateCreated datePublished" datetime="2018-06-28T21:24:59+08:00">2018-06-28</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">4.9k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">4 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="结构化与非结构化网络"><a href="#结构化与非结构化网络" class="headerlink" title="结构化与非结构化网络"></a><strong>结构化与非结构化网络</strong></h2><p>非结构化的P2P网络是指网络节点之间不存在组织关系，节点之间完全是对等的，比如第一代P2P网络Napster。</p>
<p>结构化的P2P网络与非结构化恰好相反，我们认为网络在逻辑上存在一个人为设计的结构，比如Chord假定网络是一个环，Kadelima则假定为一颗二叉树。有了这些逻辑结构，就给我们资源查找引入了更多的算法和思路。</p>
<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>我们在 <strong>计算机网络–详解P2P对等网络（一）—BitTorrent协议</strong> 这一篇博客中讲述了BT下载的过程：在对等用户拿到种子文件的时候，首先会联系tracker服务器，然后加入用户集群，并在用户集群中寻找自己所需的内容，最后与拥有内容的对等用户进行联系。</p>
<p>从BT下载的过程中引出本节所要讨论的问题：<strong>如何高效的从用户集群中找出哪些对等用户拥有你正在寻求的具体内容？</strong></p>
<p>在历史中有三种比较典型的模型来解决这个问题：</p>
<ul>
<li><p>Napster：使用一个中心服务器接收所有的查询，服务器告知去哪下载其所需要的数据。存在的问题是中心服务器单点失效导致整个网络瘫痪。</p>
</li>
<li><p>Gnutella：使用消息洪泛（message flooding）来定位数据。一个消息被发到用户集群内每一个节点，直到找到其需要的数据为止。存在的问题是消息数与节点数成线性关系，导致网络负载较重。</p>
</li>
<li><p>SN型：超级节点（Super Node），SN保存网络中节点的索引信息，这一点和中心服务器类型一样，但是网内有多个SN，其索引信息会在这些SN中进行传播，所以整个系统的崩溃几率就会小很多。尽管如此，网络还是有崩溃的可能。</p>
</li>
</ul>
<p>关于P2P网络拓扑结构更详细的内容，请参考：<strong><a href="http://www.intsci.ac.cn/users/luojw/P2P/ch02.html" target="_blank" rel="noopener">P2P网络的拓扑结构</a></strong>。</p>
<p>现在的研究结果中，Chord、Pastry、CAN和Tapestry等常用于构建结构化P2P的分布式哈希表系统。</p>
<p>Chord算法是麻省理工学院（MIT）提出的一种基于DHT技术的结构化P2P路由协议，具有完全分布式、负载均衡、可用性及可扩展性好、命名方式灵活等特点。本文主要对Chord算法展开分析。</p>
<hr>
<h2 id="分布式哈希表（DHT）"><a href="#分布式哈希表（DHT）" class="headerlink" title="分布式哈希表（DHT）"></a><strong>分布式哈希表（DHT）</strong></h2><p>对于本节问题的思考，我们可以给出一种基本的解决方案：每个对等节点维护了一张路由表（索引），这张路由表只保存了少量有关其他节点的信息，这个特点意味着它保持最新索引的代价不会很昂贵。其次，每个节点可以快速的查看索引中的表项，否则，它就不是个有效的索引。最后，每个节点可以同时使用索引，即使其他节点来来去去，这个属性意味着索引的性能随着节点数量的增长反而越来越好~</p>
<p>该解决方案就被称为分布式哈希表，因为对等节点所维护的路由表就是一张索引表，而索引的基本功能就是将一个关键字映射到一个值。这简直就是一张哈希表，但是我们的解决方案是分布式版本。我们可以再看一下维基对于DHT的定义：</p>
<blockquote>
<p>分布式哈希表（distributed hash table，缩写DHT）：分布式计算系统中的一类，用来将一个关键值（key）的集合分散到所有在分布式系统中的节点，并且可以有效地将消息转送到唯一一个拥有查询者提供的关键值的节点（Peers）。这里的节点类似散列表中的存储位置。<strong>分布式散列表通常是为了拥有极大节点数量的系统，而且在系统的节点常常会加入或离开（例如网络断线）而设计的。在一个结构性的<a href="https://zh.wikipedia.org/wiki/%E8%A6%86%E7%9B%96%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">覆盖网络（overlay network）</a>中，参加的节点需要与系统中一小部分的节点沟通，这也需要使用分布式散列表。</strong></p>
</blockquote>
<p>上述我特意加粗的语句，正是对P2P网络架构的描述。</p>
<p>如果对于DHT的概念还抱有一定的疑惑，可以在网上搜寻更白话的说明，博主不再进行贴出。</p>
<h3 id="DHT与一致性哈希"><a href="#DHT与一致性哈希" class="headerlink" title="DHT与一致性哈希"></a><strong>DHT与一致性哈希</strong></h3><p>如上所述，<strong>DHT的主要想法是把网络上资源的存取像哈希表一样，可以简单而快速地进行put、get</strong>。与一致性哈希相比，DHT更强调的是资源的存取，而不管添加删除节点时产生的资源震荡的问题。与一致性哈希相同的是，DHT也只是一个概念，具体细节留给各实现。</p>
<p>当前这些P2P实现可以被作为DHT的具体实现，再次列举一些有代表性的实现：</p>
<blockquote>
<p>Chord、CAN、Tapestry、Pastry、Apache Cassandra、Kadelima、P-Grid、BitTorrent DHT</p>
</blockquote>
<hr>
<h2 id="Chord算法"><a href="#Chord算法" class="headerlink" title="Chord算法"></a><strong>Chord算法</strong></h2><h3 id="Chord是什么？"><a href="#Chord是什么？" class="headerlink" title="Chord是什么？"></a><strong>Chord是什么？</strong></h3><p>Chord是一个算法，也是一个协议。作为一个算法，Chord可以从数学的角度严格证明其正确性和收敛性；作为一个协议，Chord详细定义了每个环节的消息类型。当然，Chord之所以受追捧，还有一个主要原因就是Chord足够简单，3000行的代码就足以实现一个完整的Chord。</p>
<h3 id="Chord概述"><a href="#Chord概述" class="headerlink" title="Chord概述"></a><strong>Chord概述</strong></h3><p>Chord的实现方式如下：给定一个关键字Key，将其映射到某个节点。为此，采用相同哈希函数（SHA-1）为每个节点和关键字产生一个m bit的ID，并按照ID大小构成环形拓扑。节点所产生的ID被称为<strong>节点标识符</strong>，关键字所产生的ID我们称它为<strong>关键字ID</strong>。运行Chord的主机相互连接构成Chord网络，这是一个建立在IP网络之上的覆盖（overlay）网络。每个节点N有2个邻居：以顺时针为正方向排列在N之前的第1个节点称为N的前继（predecessor），在N之后的第1个节点称为N的后继（successor）。如下图（蓝色节点为节点ID，白色节点为关键字ID）：</p>
<p><img src="Chord环.png" alt="此处输入图片的描述"></p>
<p>同一致性哈希一样，资源放置在关键字ID的后继节点上，如上图，资源2被放置在节点3中。</p>
<h3 id="Finger表"><a href="#Finger表" class="headerlink" title="Finger表"></a><strong>Finger表</strong></h3><p>我们在本篇博客<strong><a href="#分布式哈希表（DHT）">分布式哈希表（DHT）</a></strong>一节中已经讲过，每个对等节点都会维护一张路由表，以便在用户集群中寻找拥有所需资源的其他对等节点。这张路由表就被称为Finger表，Finger表的表项大小为m，由两列数据项组成，如下：</p>
<table>
<thead>
<tr>
<th>ID+2的i次方</th>
<th>successor</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>其中ID就代表节点标识符，i表示Finger表中表项的下标，从0开始，successor则表示存储资源的后继节点。</p>
<p>举个例子：我们现在有一个<code>m = 3</code>的Chord环，它可以容纳2的3次方，也就是8个节点。现在有4台机器，假设它们经过哈希之后所产生的ID为0，1，2，6，那么机器1中将要维护的Finger表如下：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>ID+2的i次方</th>
<th>successor</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>其中ID+2的i次方表示的是关键字ID。</p>
<p>对于上表的解释，由一致性哈希可知：</p>
<p>机器1本地存储着关键字ID为1的数据，机器2本地存储着关键字ID为2的数据，机器6本地存储着关键字ID为3，4，5，6的数据，机器0本地存储着关键字ID为7，0 的数据。</p>
<p>与此同时，如上表，机器1上，还存储着关键字ID为2，3，5的数据所在的机器地址。比如，机器1知道，关键字ID为5的数据存储在机器6上面。</p>
<h3 id="Chord的查找"><a href="#Chord的查找" class="headerlink" title="Chord的查找"></a><strong>Chord的查找</strong></h3><p>Chord采取幂次逼近查询法。任何一个节点收到查询关键字ID为“K”的请求时，首先检查K是否落在该节点标识和它的后继节点标识之间，如果是的话，这个后继节点就是存储目标(K, V)对的节点。否则，节点将查找它的Finger表，找到表中<strong>节点标识符最大但不超过K</strong>的节点，并将这个查询请求转发给该节点。通过重复这个过程，最终可以定位到K的后继节点，即存储有目标(K, V)对的节点。</p>
<p>比如，当机器1接收到查询关键字ID为7的数据在哪台机器上时，它发现关键字ID“7”并不在该节点标识符和它的后继节点标识符之间，因此它查找节点标识符最大但没有超过7的节点，为6，于是将查询请求转发到机器6上。</p>
<p>机器6的路由表按照上述规则进行生成，如下（环形拓扑）：</p>
<table>
<thead>
<tr>
<th>i</th>
<th>ID+2的i次方</th>
<th>successor</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>7</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>机器6上的路由表指出：关键字ID为7的数据在机器0上… …重复这个过程，最终可找到保存关键字ID为7的资源的节点。</p>
<p>通过在每台机器上保存m项的路由信息，上面的方式可以做到O(logN)的查询时间复杂度。另外，比如Amazon Dynamo在论文中所说：通过在每台机子上保存足够多的路由信息，理论上可以做到O(1)时间的查询（相应的，节点间冗余信息也会更多）。</p>
<h3 id="节点的加入"><a href="#节点的加入" class="headerlink" title="节点的加入"></a><strong>节点的加入</strong></h3><p>新节点的加入需要一个称为向导的已知节点（n0）进行协助，任何一个运行在Chord网络中的节点都可以充当这个角色。加入过程包括新节点本身的Join操作和被其他节点发现2个阶段。如下图所示，假设np和ns是Chord网络中相邻两节点，n为新节点，它加入网络后应该位于np和ns节点之间。</p>
<p><img src="Chord节点的加入.png" alt="这里写图片描述"></p>
<p>新节点的加入有三个操作：</p>
<blockquote>
<ul>
<li>Join() ：n加入一个Chord环，已知其中有一个向导节点n0；</li>
<li>Stabilize(): 每个节点在后台周期性的进行此项操作，查询自身节点的后继节点的前序节点是否是自身，如果不是自身，说明有新加入的节点，此时将自身的后继节点修改为新加入的节点；</li>
<li>Notify(n): n通知其他节点它的存在，若此时其他节点没有前序节点或n比其现有的前序节点更加靠近自身，则将n设置为前序节点。</li>
</ul>
</blockquote>
<p>在了解了上述三个操作之后，我们讨论一下n节点加入的具体过程：</p>
<ol>
<li>n请求向导为它查找后继 (即ns)，并初始化自身Finger表，按照Finger表的定义，此时只有n对自身属性进行了设置，其他节点并不知道新节点的加入（如上图a）；</li>
<li>在n节点将自身的后继节点修改为ns后，会对ns进行Notify(n)操作，即n节点通知ns它的存在，此时ns标记n成为自己的前序节点；</li>
<li>所有节点会在后台周期性的进行Stabilize操作，此时np发现ns的前序结点已不是自身，则np将自己的后继节点修改为n；</li>
<li>np对n进行Notify(np)操作，n接到通知，将np修改为自己的前序节点。</li>
</ol>
<p>在这里有一个问题：<strong>向导节点如何帮助新加入的节点寻找它的后继节点以及新加入的节点如何初始化其Finger表？</strong></p>
<p>第一点：对于新节点n，通过向向导节点提交查找n自身节点标识符的请求，向导节点检索其后继；<br>第二点：新节点通过向向导节点请求<code>ID + 2的m次方</code>从而构建Finger表。</p>
<h3 id="节点的失效"><a href="#节点的失效" class="headerlink" title="节点的失效"></a><strong>节点的失效</strong></h3><p>节点的失效是节点没有通知其他节点而突然离开网络，这通常由主机崩溃或IP网络断开等意外原因造成，此时失效节点的前继保存的后继信息变得不可用，从而造成Chord环的断裂。为了处理这个问题，需要周期性的对节点的前序和后继进行探测。如果节点n发现其后继或前序已经失效，则从Finger表中顺序查找第1个可用节点进行替换，并重建Finger表。对前序节点失效的处理仍需要借助于Notify消息。考虑上图中的例子，ns虽然能够感知n的失效却无法进行修复。由于上述对后继失效的处理过程能够保证Chord环后继链的正确性，因此np通过在Stabilize中向新后继ns发送Notify，把ns的前继改成np。值得注意的是，其他节点也可能在Finger表项中保存有失效节点的记录，因此需要多次Stabilize，把失效信息扩散到Chord网络中。虽然这种方法最终能够保证Chord网络的完整性，但在节点频繁进出的情况下，其效率仍须更深入地研究。</p>
<h3 id="节点的退出"><a href="#节点的退出" class="headerlink" title="节点的退出"></a><strong>节点的退出</strong></h3><p>由于节点失效处理方法是稳定的，因此节点的退出可看作为失效而不采取其他附加措施。但基于效率的考虑，节点n退出时进行如下操作：1. 把n后继节点的前继改成n的前继；2. 把n前继节点的后继改成n的后继；3. 从n前继的Finger表中删除n。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>熟悉DHT、一致性哈希、Chord算法之间的概念及联系；</li>
<li>熟悉Chord算法的思想（Finger表的构建、Chord查询、节点的加入等）；</li>
<li>了解P2P网络的一些其它拓扑结构。</li>
</ol>
<p>PS：关于Chord算法数学角度上的证明与分析，有兴趣的同学可以自行查阅相关资料~</p>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>计算机网络（第五版） — Andrew S. TanenBaum/David J. Wetherall</p>
<p><a href="http://www.yeolar.com/note/2010/04/06/p2p-chord/#id18" target="_blank" rel="noopener">结构化P2P网络chord算法研究与分析</a></p>
<p><a href="https://www.cnblogs.com/hapjin/p/5760463.html" target="_blank" rel="noopener">分布式哈希算法</a></p>
<p><a href="https://www.cnblogs.com/gnuhpc/archive/2012/01/13/2321476.html" target="_blank" rel="noopener">【学术之门之P2P算法研读】P2P中的Chord算法</a></p>
<p><a href="https://blog.csdn.net/chen77716/article/details/6059575" target="_blank" rel="noopener">Chord算法（原理）</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/06/26/查找-深入理解一致性哈希算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/26/查找-深入理解一致性哈希算法/" itemprop="url">
                  查找--深入理解一致性哈希算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-26 21:06:58" itemprop="dateCreated datePublished" datetime="2018-06-26T21:06:58+08:00">2018-06-26</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">2.7k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">2 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：本篇博客只是讲述了一致性哈希的思想，我们会在之后讲述分布式哈希表以及一致性哈希的一种实现（Chord算法）。</strong></p>
<h2 id="什么是一致性哈希算法？"><a href="#什么是一致性哈希算法？" class="headerlink" title="什么是一致性哈希算法？"></a><strong>什么是一致性哈希算法？</strong></h2><p>引用自维基百科：</p>
<blockquote>
<p>一致性哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量，n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位几乎需要对所有关键字进行重新映射。</p>
</blockquote>
<p><strong>总结</strong>：一致性哈希算法主要关注的是在分布式架构中，当节点数目发生变化的时候（增加/删除），怎样使再哈希的数据量最少。</p>
<hr>
<h2 id="一致性哈希的引出"><a href="#一致性哈希的引出" class="headerlink" title="一致性哈希的引出"></a><strong>一致性哈希的引出</strong></h2><p>在分布式系统中，节点的宕机、某个节点加入或者移出集群是常事。对于分布式存储而言，假设存储集群中有10台机器（node），如果采用传统Hash方式对数据分片（item）(即数据根据哈希函数映射到某台机器上存储)，哈希函数应该是这样的：hash(item) % 10。根据上面的介绍，当node数发生变化（增加、移除）后，数据会被重新“打散”，导致大部分数据不能落到原来的节点上，从而导致大量数据需要迁移，而这种移动会造成网络的负载。</p>
<p>那么，一个亟待解决的问题就变成了：当node数发生变化时，如何保证尽量少引起迁移呢？即当增加或者删除节点时，对于大多数item，保证原来分配到的某个node，现在仍然应该分配到那个node，将数据迁移量降到最低。</p>
<hr>
<h2 id="一致性哈希的原理及优劣"><a href="#一致性哈希的原理及优劣" class="headerlink" title="一致性哈希的原理及优劣"></a><strong>一致性哈希的原理及优劣</strong></h2><p><img src="一致性哈希环结构.png" alt="此处输入图片的描述"></p>
<p>传统的Hash算法将对应的key哈希到一个具有2^32次方（int）个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。也就是将传统的线性哈希表构造成环形哈希表。</p>
<p>我们来看一下如何将数据映射到环形哈希表上：</p>
<p>如上图，有三台机器（node），四个数据项（item），每台机器对应着一个n位的ID（采用机器的IP或者机器唯一的别名作为哈希函数的输入值），并且映射到环中，每个查询键，也是一个n位的ID，节点的ID和查询键对应着相同的映射空间。三台机器将整个环分割成了三部分，分别是(1,3)，(3,2)，(2,1)。</p>
<p>机器1负责存储落在(2,1)范围内的数据，机器2负责存储落在(3,2)范围内的数据…..</p>
<p>也就是说，对数据进行Hash时，数据的地址会落在环上的某个点上，<strong>数据就存储在该点的顺时针方向上的那台机器上</strong>。</p>
<p>这种数据存储的方式，相比于普通哈希方式，有明显的优势：当添加新机器或者删除机器时，不会影响到全部数据的存储，而只是影响到这台机器上所存储的数据(落在这台机器所负责的环上的数据)。</p>
<p>而这种思想，也就是<strong>一致性哈希</strong>。我们举个例子来感受一下使用一致性哈希的好处：</p>
<blockquote>
<p>比如，机器1被移除了，那落在(2,1)范围内的数据全部需要由机器3来存储，也就只影响到落在(2,1)这个范围内的数据。同时，扩容也很方便，比如在(1,3)这段环上再添加一台机器4，只需要将3上的一部分数据拷贝到机器4上即可。</p>
</blockquote>
<p>虽然一致性Hash算法解决了节点变化导致的数据迁移问题，但是，我们回过头来再看看数据分布的均匀性：</p>
<p><img src="一致性哈希数据的分布.png" alt="此处输入图片的描述"></p>
<p>数据被传统的哈希算法“打散”后，是可以比较均匀分布的。但是引入一致性哈希算法后，为什么就不均匀呢？数据本身的哈希值并未发生变化，变化的是判断数据哈希后应该落到哪个节点的算法变了。</p>
<p>这三个节点Hash后，在环上分布不均匀，导致了每个节点实际占据环上的区间大小不一，数据随机映射到每个节点的概率就有较大差别，换个说法，也就是不能实现较好的负载均衡。</p>
<p>举个例子：机器1的配置很高，性能很好，而机器3的配置很低。但是，如上图，大部分数据由于某些特征都哈希到(1,3)这段环上，直接就导致了机器3的存储压力很大。</p>
<hr>
<h2 id="虚拟节点的引入"><a href="#虚拟节点的引入" class="headerlink" title="虚拟节点的引入"></a><strong>虚拟节点的引入</strong></h2><p>当我们将node进行哈希后，这些值并没有均匀地落在环上，因此，最终会导致，这些节点所管辖的范围并不均匀，最终导致了数据分布的不均匀。</p>
<p>为了解决一致性哈希的不足，从而引入了虚拟节点的概念。</p>
<p>引入虚拟节点，可以有效地防止物理节点（机器）映射到哈希环中出现不均匀的情况。比如上图中的机器1、2、3都映射在环的左半边上。</p>
<p>一般，虚拟节点会比物理节点多很多，并可均衡分布在环上，从而提高负载均衡的能力。</p>
<p><img src="一致性哈希虚拟节点.png" alt="此处输入图片的描述"></p>
<ol>
<li>如果虚拟节点与物理机器映射得好，某一台物理机器宕机后，其上的数据可由其他若干台物理机器共同分担；</li>
<li>如果新添加一台机器，它可以对应多个不相邻环段上的虚拟节点，从而使得Hash的数据存储得更分散。</li>
</ol>
<hr>
<h2 id="如何判定一致性哈希算法的好坏？"><a href="#如何判定一致性哈希算法的好坏？" class="headerlink" title="如何判定一致性哈希算法的好坏？"></a><strong>如何判定一致性哈希算法的好坏？</strong></h2><ol>
<li><strong>平衡性(Balance)</strong>：平衡性是指哈希的结果能够尽可能分布到所有的缓冲（服务器节点）中去，这样可以使得所有的缓冲空间都得到利用，很多哈希算法都能够满足这一条件；</li>
<li><strong>单调性(Monotonicity)</strong>：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中，哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区；</li>
<li><strong>分散性(Spread)</strong>：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性；</li>
<li><strong>负载(Load)</strong>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>
</ol>
<p><strong>注</strong>：对于第四点来说，好的一致性哈希算法，应该将同一用户的请求映射到相同的机器上，因为一个缓冲区始终处理同一个用户的请求是比较容易实现的（Cookie），如果将不同用户的不同请求映射到相同的缓冲区中，既有可能增大机器的负载，而且不容易实现。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>熟悉一致性哈希算法的特点及原理；</li>
<li>熟悉一致性哈希算法的优劣与改进（虚拟节点）；</li>
<li>掌握为什么会出现一致性哈希算法；</li>
<li>了解一致性哈希算法的另一种改进（线性空间的引入）—详见<a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">一致性哈希算法的理解与实践</a>。</li>
</ol>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">一致性哈希算法的理解与实践</a></p>
<p><a href="http://www.cnblogs.com/hapjin/p/4737207.html" target="_blank" rel="noopener">一致性哈希算法学习及JAVA代码实现分析</a></p>
<p><a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">每天进步一点点—五分钟理解一致性哈希算法(consistent hashing)</a></p>
<p><a href="https://www.cnblogs.com/hapjin/p/5760463.html" target="_blank" rel="noopener">分布式哈希算法</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/06/21/计算机网络-详解P2P对等网络（一）—BitTorrent协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/计算机网络-详解P2P对等网络（一）—BitTorrent协议/" itemprop="url">
                  计算机网络--详解P2P对等网络（一）—BitTorrent协议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-21 11:15:10" itemprop="dateCreated datePublished" datetime="2018-06-21T11:15:10+08:00">2018-06-21</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">6.4k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">6 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：本篇文章内容借鉴自：<a href="http://azard.me/blog/2015/10/24/introduction-to-bittorrent/" target="_blank" rel="noopener">浅入浅出BitTorrent协议</a>，其中加入了博主的部分原创，感谢，侵删~</strong></p>
<h2 id="对等网络的概念"><a href="#对等网络的概念" class="headerlink" title="对等网络的概念"></a><strong>对等网络的概念</strong></h2><p>以下定义主要摘抄自维基百科与中科院计算技术研究所：</p>
<blockquote>
<p>对等式网络（peer-to-peer，简称P2P），又称点对点技术，是<strong>无中心服务器、依靠用户群（peers）交换信息的互联网体系</strong>。它的作用在于，网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络中的每个用户端既是资源（服务和内容）提供者（Server），又是资源获取者（Client），任何一个节点无法直接找到其他节点，必须依靠其用户群进行信息交流。</p>
</blockquote>
<hr>
<h2 id="对等网络的模型"><a href="#对等网络的模型" class="headerlink" title="对等网络的模型"></a><strong>对等网络的模型</strong></h2><p>P2P网络的简易模型图如下：</p>
<p><img src="P2P网络简易模型.png" alt="此处输入图片的描述"></p>
<p>如图，我们可以总结出P2P网络的一些特征：</p>
<ol>
<li><strong>非中心化</strong>：P2P是全分布式系统，网络中的资源和服务分散在所有的节点上，信息的传输和服务的实现都直接在节点之间进行，可以无需中间环节和服务器介入。</li>
<li><strong>可扩展性</strong>：用户可以随时加入该网络，系统的资源和服务能力随之同步扩充。理论上其可扩展性几乎可以认为是无限的。</li>
<li><strong>健壮性</strong>：因为服务是分散在各个节点之间的，部分节点或网络遭到破坏对其他部分的影响很小，故P2P具有耐攻击、高容错的特点。P2P网络一般在部分结点失效时能够自动调整整体拓扑，保持其它结点的连通性。P2P网络通常都是以自组织的方式建立起来的，并允许结点自由地加入和离开。</li>
<li><strong>高性价比</strong>：P2P架构可以有效地利用互联网中散布的大量普通结点，将计算任务或存储资料分布到所有结点上。利用其中闲置的计算能力或存储空间，达到高性能计算和海量存储的目的。</li>
<li><strong>隐私保护</strong>：在P2P网络中，由于信息的传输分散在各节点之间进行而无需经过某个集中环节，用户的隐私信息被窃听和泄漏的可能性大大缩小。</li>
<li><strong>负载均衡</strong>：由于每个节点既是服务器又是客户端，减少了传统C/S模型中对服务器计算能力、存储的要求，同时因为资源分布在多个节点，更好的实现了整个网络的负载均衡。</li>
</ol>
<hr>
<h2 id="BitTorrent协议"><a href="#BitTorrent协议" class="headerlink" title="BitTorrent协议"></a><strong>BitTorrent协议</strong></h2><p>BitTorrent协议，简称BT协议，是一种互联网上新兴的P2P传输协议（即BT是一种特殊的P2P）。</p>
<h3 id="出现的历史原因"><a href="#出现的历史原因" class="headerlink" title="出现的历史原因"></a><strong>出现的历史原因</strong></h3><p>随着全球接入互联网人数的增长，对互联网应用的服务端要求越来越高，吞吐量和并发量逐步加大。像国外的Google、Amazon，国内的阿里、百度等大型互联网企业十分关注如何使用集群、负载均衡等技术来提高网站的并发和吞吐量。但对于保存大文件给用户下载的中小型网站，在互联网爆发式增长下，用户数量越来越多，传输的文件越来越大，使用一台或几台服务器和传统的FTP、HTTP协议难以满足用户对下载速度的需求（受限于庞大的用户请求量、硬盘读取速度、带宽等）。BitTorrent协议解决了这些问题。</p>
<h3 id="BT下载流程"><a href="#BT下载流程" class="headerlink" title="BT下载流程"></a><strong>BT下载流程</strong></h3><blockquote>
<p>无论是BT还是PT，还是FTP，都是一种下载方式，或者学术点的讲法，叫文件传输。</p>
</blockquote>
<p>BT下载通过一个P2P下载软件（点对点下载软件）来实现，克服了传统下载方式的局限性，具有下载的人越多，文件下载速度就越快的特点。其好处是不需要资源发布者拥有高性能服务器就能迅速有效地把发布的资源传向其他的BT客户软件使用者，而且大多数的BT软件都是免费的。</p>
<p>BT下载架构模型图：</p>
<p><img src="BT下载架构模型图.png" alt="此处输入图片的描述"></p>
<p>现在，我们已经清楚了BT下载的架构模型，对于BT下载流程的讨论，我们跟随BT协议所引出的三个问题来进行：</p>
<blockquote>
<ol>
<li>一个对等用户如何找到具有自己想下载内容的其他对等用户？</li>
<li>对等用户们如何复制内容以便为大家提供高速下载？</li>
<li>对等用户们如何相互鼓励上传内容给他人同时为自己下载内容？</li>
</ol>
</blockquote>
<h4 id="B-encode"><a href="#B-encode" class="headerlink" title="B encode"></a><strong>B encode</strong></h4><p>在解决这三个问题之前，先简单介绍下B encode，因为在BitTorrent协议中的数据几乎都是用B encode进行编码的。它是一种作用类似于XML和JSON的数据组织格式，可以表达字符串、整数两种基本类型，列表、字典两种数据结构，它的语法规则十分简单。</p>
<ul>
<li>字节串按如下方式编码：</li>
</ul>
<blockquote>
<p>&lt;以十进制ASCII编码的串长度&gt;:&lt;串数据&gt;<br>例：“4:spam”表示字节串“spam”</p>
</blockquote>
<ul>
<li>整数按如下方式编码：</li>
</ul>
<blockquote>
<p>i&lt;以十进制ASCII编码的整数&gt;e<br>例：“i3e”表示整数“3”</p>
</blockquote>
<ul>
<li>列表按如下方式编码：</li>
</ul>
<blockquote>
<p>l&lt;内容&gt;e<br>开始的“l”与结尾的“e”分别是开始和结束分隔符。lists可以包含任何B编码的类型，包括整数、串、dictionaries和其他的lists。<br>例：l4:spam4:eggse 表示含有两个串的lists:[“spam”、“eggs”]</p>
</blockquote>
<ul>
<li>字典按如下方式编码：</li>
</ul>
<blockquote>
<p>d&lt;内容&gt;e<br>开始的“d”与结尾的“e”分别是开始和结束分隔符。注意键（key）必须被B编码为串。值可以是任何B编码的类型，包括整数、串、lists和其他的dictionaries。键（key）必须是串，并且以排序的顺序出现（以原始串排列，而不是以字母数字顺序）。<br>例：d3:cow3:moo4:spam4:eggse表示dictionary { “cow” =&gt; “moo”, “spam” =&gt; “eggs” }</p>
</blockquote>
<h4 id="torrent文件与tracker服务器"><a href="#torrent文件与tracker服务器" class="headerlink" title="torrent文件与tracker服务器"></a><strong>torrent文件与tracker服务器</strong></h4><p>现在，我们考虑上述中的第一个问题：<strong>一个对等用户如何找到具有自己想下载内容的其他对等用户？</strong></p>
<p>在P2P网络系统的最初阶段，并不是所有的用户都拥有所有的内容，首先需要一个内容的发布者。作为内容的发布者，BitTorrent可以为每个发布者（内容提供商）创建一个内容描述文件，即.torrent文件，也就是我们平常所说的<strong>种子文件</strong>。</p>
<p>种子文件是一种指定格式的文件，包含了两类关键信息，<strong>一类信息是tracker服务器的URL，一类信息是一个大小相等的块的清单</strong>。tracker服务器可以将用户引导至种子文件的内容，也就是将用户引导至拥有当前用户所需下载内容的其他对等节点处，块清单则组成了内容。</p>
<p>关于种子文件具体的组成结构，它使用B encode表示，<strong>整个是一个字典数据结构</strong>，它有多个key值，包括一些是可选的，这里介绍最关键的上述两类信息的键值对：</p>
<blockquote>
<ul>
<li>info：存储资源文件的元信息<ul>
<li>piece length</li>
<li>pieces</li>
<li>name/path</li>
</ul>
</li>
<li>announce：描述tracker服务器的URL</li>
</ul>
</blockquote>
<p><strong>info</strong>：info键对应的值又是一个字典结构，<strong>BT协议将一个文件分成若干块，便于客户端从各个主机下载各个块</strong>。其中的<strong>piece length</strong>键值对表示一个块的长度，通畅情况下是2的n次方，根据文件大小有所权衡，通长越大的文件piece length越大以减少piece的数量，降低piece数量一方面降低了种子文件保存块信息数目的大小，一方面也减少了下载时需要对块做的确认操作，加快下载速度。目前块的大小通常是256KB，512KB或者1MB。</p>
<p><strong>pieces</strong>：表示每个块的正确性验证信息，每一块均对应一个唯一的SHA1散列值。该键对应的值是所有块的SHA1散列值（每个块所对应的散列值大小为20字节）连接而成的字符串。</p>
<p><strong>name/path</strong>：表示具体文件的信息。因为<strong>BitTorrent协议允许将数个文件和文件夹作为一个BT下载进行发布</strong>，因此下载方可以根据需要勾选某一些下载文件。注意，这里将数个文件也砍成一个数据流，因此一个piece如果在文件边界上，可能包含不同文件的信息。</p>
<p><strong>announce</strong>：保存的是tracker服务器的URL，在一些扩展协议中，announce可以保存多个tracker服务器作为备选。</p>
<p>生成好种子文件之后，为了下载由种子文件所描述的内容，一个对等用户首先需要和此种子文件取得联系。这个种子文件通常被放在服务器上，可以通过HTTP或者FTP协议供用户下载这个种子文件。相比于直接将整个资源文件提供给用户下载，只传输一个种子文件大大降低了服务器的负荷。</p>
<p>在取得种子文件后，我们可以通过BitTorrent协议提供的一些工具（BitTorrent软件客户端）来打开这个种子文件，客户端会根据种子文件的name/path元信息告诉我们这个种子文件可以下载到（假设）一个.mkv文件，一个字幕文件，在这个阶段我可以进行一些勾选，选择下载某些而不是全部的资源。</p>
<p>资源选择确定后，客户端就开始了下载。客户端的第一步任务根据种子文件上的tracker服务器的URL使用HTTP进行GET请求——tracker服务器维护着一个正在主动上传和下载该内容的所有其他对等用户列表，我们将这一组对等用户称为<strong>用户群</strong>，对等用户可以随时离开群（以及返回），只要他们及时向tracker服务器进行报告即可——这个请求包含了很多参数，这里只介绍从客户端发送到tracker的请求中最关键的几个参数。</p>
<blockquote>
<ul>
<li>info_hash</li>
<li>peer_id</li>
<li>ip</li>
<li>port</li>
</ul>
</blockquote>
<p><strong>info_hash</strong>：种子文件中info键所对应的值的SHA1散列，可以被tracker服务器用来索引唯一的对应资源。</p>
<p><strong>peer_id</strong>：20Byte的串，没有任何要求，被tracker服务器用于记录客户端的名字。</p>
<p><strong>ip</strong>：可以从HTTP GET请求中直接获取，放在参数中可以解决使用代理进行HTTP GET的情况，tracker服务器可以记录客户端的IP地址。</p>
<p><strong>port</strong>：客户端监听的端口号，用于接收Response。一般情况下为BitTorrent协议保留的端口号：6881-6889，tracker服务器会记录下端口号用于通知其他客户端。</p>
<p>在tracker服务器收到客户端的HTTP GET请求后，会返回B encode形式的text/plain文本，同样是一个字典数据结构，其中最关键的一个键值对是peers，它的值是个字典列表结构，列表中的每一项都是如下的字典结构：</p>
<blockquote>
<ul>
<li>peers<ul>
<li>peer_id</li>
<li>ip</li>
<li>port</li>
</ul>
</li>
</ul>
</blockquote>
<p>这些信息在每个客户端连接tracker服务器的时候都发送过，并且被Tracker服务器保存了下来。新来的客户端自然要获取到这些下载中或者已下载完的客户端的ip，port等信息，有了这些信息，客户端就不需要像FTP或者HTTP协议一样持续找服务器获取资源，可以从这些其他客户端上请求获取资源。</p>
<h4 id="peer-to-peer"><a href="#peer-to-peer" class="headerlink" title="peer to peer"></a><strong>peer to peer</strong></h4><p>如上所述，如果对第一个问题进行简单的总结，那么自己想要下载的内容就交由种子文件进行确定，而如何寻找拥有这些资源的其他对等用户，则需要tracker服务器的帮助。</p>
<p>那么，我们现在思考第二个问题：<strong>对等用户们如何复制内容以便为大家提供高速下载？</strong></p>
<p>客户端从tracker服务器获取到若干其他下载者(peer)的ip和port信息，会进行请求并维持跟每一个peer的连接状态。一个客户端和每一个peer的状态主要有下列状态信息：</p>
<blockquote>
<ul>
<li>choke：远程客户端拒绝响应本客户端的任何请求。</li>
<li>interested：远程客户端对本客户端的数据感兴趣，当本客户端unchoked远程客户端后，远程客户端会请求数据。</li>
</ul>
</blockquote>
<p>所以应该有4个参数，分别表示本客户端对远程客户端是否choke，是否interested，远程客户端对本客户端是否choke，是否interested。当一个客户端对一个远程peer感兴趣并且那个远程peer没有choke这个客户端，那么这个客户端就可以从远程peer下载块(block)。当一个客户端没有choke一个peer，并且那个peer对这个客户端感兴趣时，这个客户端就会上传块(block)。</p>
<p><strong>补充一点</strong>：由于内容发布者本来就拥有所有的块，因此在生成种子文件的时候，内容发布者首先会根据种子文件将内容重新下载一遍，在这个过程中就会联系tracker服务器，然后将自己的信息记录在其所维护的用户列表上。</p>
<p>其实上述所讲的概念已经解答了第二个问题，每一个对等节点在参与一个用户群期间，都可同时从其他对等节点处下载缺少的块，并给其他对等节点上传本身拥有并且他们所需要的块。如果每个对等节点都这样做，那么经过短暂的一段时间后，所有的块都将成为广泛可用——加入用户群的用户越多，块被交易的越频繁，下载速度越快。</p>
<p>对第二个问题的答案进行一个简单的总结：对等用户们通过在下载块的同时也会上传块，从而为大家提供高速下载。</p>
<p>我们再进行一些补充，上面也提到了，在交易块的过程中，端与端之间会进行通信：</p>
<p>首先会发送握手报文，告诉远程客户端本客户端的一些信息，包括info_hash和peer_id。</p>
<p>接下来的所有报文有如下几种类型：</p>
<blockquote>
<ul>
<li>keep-alive：告诉远程客户端这个通信还在维持，否则超过2分钟没有任何报文远程客户端会将通信关闭</li>
<li>choke</li>
<li>unchoke</li>
<li>interested</li>
<li>not interested</li>
<li>bitfield：告诉对方我已经有的piece</li>
<li>have：告诉对方某个piece已经成功下载并且通过hash校验</li>
<li>request：请求某个块(block)<ul>
<li>index: 整数，指定从零开始的piece索引</li>
<li>begin: 整数，指定piece中从零开始的字节偏移</li>
<li>length: 整数，指定请求的长度</li>
</ul>
</li>
<li>piece：返回请求的块(block)的数据，是真正的资源信息<ul>
<li>index: 整数，指定从零开始的piece索引</li>
<li>begin: 整数，指定piece中从零开始的字节偏移</li>
<li>block: 数据块</li>
</ul>
</li>
</ul>
</blockquote>
<p>经过这些报文在<strong>本地客户端和若干个远程客户端</strong>之间的来回传递，就能够获取到资源文件。</p>
<h4 id="PT下载"><a href="#PT下载" class="headerlink" title="PT下载"></a><strong>PT下载</strong></h4><p>在解决了前两个问题之后，我们来考虑第三个问题：<strong>对等用户们如何相互鼓励上传内容给他人同时为自己下载内容？</strong></p>
<p>我们也可以看到，在P2P网络中，起初必须有一个内容的提供者，并且在健康的P2P网络中，每个peer都应当同时扮演客户端与服务器两个角色，那些只想从系统中获取资源而没有实物贡献的节点我们称之为“搭便车”或“吸血鬼”，如果这样的用户太多，那系统将无法正常工作。</p>
<p><strong>PT</strong>全称Private Tracker，与BT最大的不同点分别为可进行私密范围下载，及可统计每个用户的上传及下载量。从技术上可以简单的看作有一个tracker服务器会对用户的下载上传进行统计，分享率不够就禁止用户下载，在一定程度上可以防止只下载而不上传的用户存在。关于PT下载更详细的内容，博主不在这里进行讨论，有兴趣的同学可以自行查阅相关资料。</p>
<hr>
<h2 id="一个有趣的小问题"><a href="#一个有趣的小问题" class="headerlink" title="一个有趣的小问题"></a><strong>一个有趣的小问题</strong></h2><p>迅雷作为国内首屈一指的BT下载工具，为什么有时在下载接近完成的最后，一些数据总是传输的非常慢呢？</p>
<p>基于现实情况分析，有些人下载完成后关掉下载任务，提供较少量数据给其他用户，为尽量避免这种行为，在非官方BitTorrent协议中存在超级种子的算法。这种算法允许文件发布者分几步发布文件，发布者不需要一次提供文件所有内容，而是慢慢开放下载内容的比例，延长下载时间。此时，速度快的人由于未下载完必须提供给他人数据，速度慢的人有更多机会得到数据。由此往往造成用户卡在任务的99%，下载1G的任务要上传3G之多的数据。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>熟悉P2P网络的特点及优势；</li>
<li>熟悉BitTorrent协议的基本内容；</li>
<li>熟悉BT下载的过程（种子文件以及tracker服务器）；</li>
<li>掌握诸如<strong>用户群</strong>、<strong>吸血鬼</strong>等名词含义；</li>
<li>了解种子文件的组成格式——B编码；</li>
<li>了解peer与peer之间的通信报文格式；</li>
<li>能独立回答出关于BitTorrent协议的三个问题。</li>
</ol>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>计算机网络（第五版） — Andrew S. TanenBaum/David J. Wetherall</p>
<p><a href="http://azard.me/blog/2015/10/24/introduction-to-bittorrent/" target="_blank" rel="noopener">浅入浅出BitTorrent协议</a></p>
<p><a href="https://blog.csdn.net/lanchunhui/article/details/51870418#t2" target="_blank" rel="noopener">P2P（对等网络）、PT下载与BT下载</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/06/18/计算机网络-详解CDN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/18/计算机网络-详解CDN/" itemprop="url">
                  计算机网络--详解CDN
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-18 20:35:04" itemprop="dateCreated datePublished" datetime="2018-06-18T20:35:04+08:00">2018-06-18</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">6.5k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">6 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：本文内容摘抄自<a href="https://segmentfault.com/a/1190000010631404#articleHeader3" target="_blank" rel="noopener">CDN详解 — 不挑食的程序员</a>，博主在其基础上进行了少量修改并加入了部分原创，感谢，侵删~</strong></p>
<p>之前我们已经学习过缓存机制以及Web代理，但对于大型网站的构建，这些还远远不够。要想真正的构建一个流行的网站，内容分发网络（Content Delivery Network）简称CDN，是一项不可或缺的技术。</p>
<hr>
<h2 id="什么是CDN？"><a href="#什么是CDN？" class="headerlink" title="什么是CDN？"></a><strong>什么是CDN？</strong></h2><p>以下内容摘自维基百科：</p>
<blockquote>
<p>内容分发网络（CDN）是指一种通过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，<strong>更快、更可靠</strong>地将音乐、图片、视频、应用程序及其他文件发送给用户。</p>
</blockquote>
<p>如果对整个CDN系统做一个简单的描述：</p>
<blockquote>
<p>CDN系统主要由4大部分组成，每部分都由集群所构成。这4部分分别由CDN专属DNS服务器、全局负载均衡设备、区域负载均衡设备、CDN缓存服务器（边缘节点）构成。除过CDN专属DNS服务器，其他3部分集群都有源服务器上对应资源的全部或部分副本。CDN系统通过各部分的负载均衡算法，最终指示客户端使用附近最优的边缘节点中的一台缓存服务器作为服务端，从而提高Web应用的性能。</p>
</blockquote>
<hr>
<h2 id="CDN的基本工作过程"><a href="#CDN的基本工作过程" class="headerlink" title="CDN的基本工作过程"></a><strong>CDN的基本工作过程</strong></h2><p>在传统的Web模型中，发出请求后一般要经过如下几个步骤：</p>
<ol>
<li>用户在自己的浏览器中输入要访问的网站域名。</li>
<li>浏览器向<strong>本地DNS服务器</strong>请求对该域名的解析。</li>
<li>本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。</li>
<li>本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以<strong>迭代方式</strong>向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。</li>
<li>浏览器得到域名解析结果，就是该域名相应的服务设备的IP地址 。</li>
<li>浏览器获取IP地址之后，经过标准的TCP握手流程，建立TCP连接。</li>
<li>浏览器向服务器发起HTTP请求。</li>
<li>服务器将用户请求内容传送给浏览器。</li>
<li>经过标准的TCP挥手流程，断开TCP连接。</li>
</ol>
<p>在网站和用户之间加入CDN以后，用户不会有任何与原来不同的感觉。从宏观上来看，一个典型的CDN用户访问调度流程如下：</p>
<ol>
<li>当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，则本地DNS系统会将域名的解析权交给CNAME指向的<strong>CDN专用DNS服务器</strong>。</li>
<li>CDN的DNS服务器将CDN的 <strong>全局负载均衡设备</strong> IP地址返回给用户。</li>
<li>用户向CDN的全局负载均衡设备发起URL访问请求。</li>
<li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的<strong>区域负载均衡设备</strong>，并将请求转发到此设备上。</li>
<li>基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的<strong>缓存服务器节点</strong>，并从缓存服务器节点处得到<strong>缓存服务器的IP地址</strong>，最终将得到的IP地址返回给全局负载均衡设备：</li>
</ol>
<ul>
<li>根据用户IP地址，判断哪一个边缘节点距用户最近；</li>
<li>根据用户所请求的URL中携带的内容名称，判断哪一个边缘节点上有用户所需内容；</li>
<li>查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。</li>
</ul>
<ol start="6">
<li>全局负载均衡设备把服务器的IP地址返回给用户。</li>
<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li>
</ol>
<p>CDN全局负载均衡设备与CDN区域负载均衡设备根据用户IP地址，将域名解析成相应节点中缓存服务器的IP地址，实现用户就近访问，从而提高服务端响应内容的速度。</p>
<p>理论上，最简单的CDN网络只有一个CDN专用DNS服务器，一个全局负载均衡设备，然后各节点一台缓存服务器，即可运行。</p>
<hr>
<h2 id="CDN的部署架构"><a href="#CDN的部署架构" class="headerlink" title="CDN的部署架构"></a><strong>CDN的部署架构</strong></h2><p><strong>CDN系统设计的首要目标是尽量减少用户的访问响应时间</strong>，为达到这一目标，CDN系统应该尽量将用户所需要的内容存放在距离用户最近的位置。也就是说，负责为用户提供内容服务的缓存设备应部署在物理上的网络边缘位置，我们称这一层为CDN边缘层。CDN系统中负责全局性管理和控制的设备组成中心层，中心层同时保存着基本上最完善的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。</p>
<p>不同CDN系统设计之间存在差异，中心层可能具备用户服务能力，也可能不直接提供服务，只向下级节点提供内容。如果CDN网络规模较大，边缘层设备直接向中心层请求内容或服务会造成中心层设备压力过大，就要考虑在边缘层和中心层之间部署一个区域层，负责一个区域的管理和控制，也保存部分内容副本供边缘层访问。</p>
<p>实际上，边缘层、区域层、中心层分别对应于边缘节点、区域负载均衡设备、全局负载均衡设备。</p>
<p>节点是CDN系统中最基本的部署单元，<strong>每个节点都是由服务器集群组成</strong>。一个CDN系统由大量的、地理位置上分散的POP（point-of-presence）节点组成，为用户提供就近的内容访问服务。</p>
<p>CDN节点网络主要包含CDN骨干点和POP点。CDN骨干点和CDN POP点在功能上不同。</p>
<p>中心和区域节点一般称为骨干点，主要作为内容分发和边缘未命中时的服务点；</p>
<p>边缘节点又被称为POP（point-of-presence）节点，CDN POP点主要作为直接向用户提供服务的节点。</p>
<p>从节点构成上来说（微观上），<strong>CDN骨干点、POP点都由缓存设备和本地负载均衡设备构成</strong>，它与全局负载均衡设备及区域负载均衡设备属于不同视角下的东西，可以分开实现，也可以抽象出接口，对上层透明。</p>
<p>缓存设备和本地负载均衡设备的连接方式有两种：一种是旁路方式，一种是穿越方式。我们只说穿越方式。</p>
<p>在穿越方式下，SLB（Server Load Balancer）本地负载均衡一般由L4-7交换机实现，SLB向外提供可访问的公网IP地址，我们可以将其称之为VIP。每台缓存服务器仅分配私网IP地址，该台SLB下的所有缓存服务器构成一个服务组。所有用户请求和媒体流都经过该SLB设备，再由SLB设备进行向上向下转发。SLB实际上承担了NAT（Network Address Translation，网络地址转换）功能，向用户屏蔽了单台缓存服务器设备的IP地址。</p>
<p>也就是说，我们所访问的全局负载均衡设备，区域负载均衡设备，CDN边缘节点服务器的IP地址，实际上都是VIP。这种方式是CDN系统中应用较多的方式，优点是具有较高的安全性和可靠性。</p>
<hr>
<h2 id="CDN的功能架构"><a href="#CDN的功能架构" class="headerlink" title="CDN的功能架构"></a><strong>CDN的功能架构</strong></h2><p>CDN基于这样的原理：</p>
<ol>
<li>挑选最优设备为用户提供服务；</li>
<li>如果某个内容被很多用户所需要，它就被缓存到距离用户最近的节点中。</li>
</ol>
<p>CDN公司在整个互联网上部署数以百计的CDN服务器（Cache），这些服务器通常在运营商的IDC(互联网数据中心Internet Data Center）中，尽量<strong>靠近接入网络和用户</strong>。当内容的提供者更新内容时，<strong>CDN向缓存服务器重新分发这些被刷新的内容</strong>。CDN提供一种机制，当用户请求内容时，该内容能够由以最快速度交付的缓存服务器来向用户提供，这个挑选”最优”的过程就叫做<strong>负载均衡</strong>。被选中的最优缓存服务器可能最靠近用户，或者有一条与用户之间条件最好的路径。</p>
<p>关于国内有名的CDN公司，我们熟知的包括阿里云、腾讯云、百度云等等，他们都对外提供CDN服务。</p>
<p>至于IDC，请戳：<a href="https://www.zhihu.com/question/40534161/answer/95912666" target="_blank" rel="noopener">云、CDN、IDC 三个概念的区别是什么？有什么相互包含和影响 - DADAman的回答 - 知乎 </a></p>
<p>从功能上划分，典型的CDN系统架构由<strong>分发服务系统、负载均衡系统和运营管理系统</strong>三大部分组成。</p>
<hr>
<h3 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a><strong>分发服务系统</strong></h3><p>该系统的主要作用是实现<strong>将内容从内容源中心向边缘的推送和存储，承担实际的内容数据流的全网分发工作和面向最终用户的数据请求服务</strong>。分发服务系统最基本的工作单元就是许许多多的缓存服务器，缓存服务器负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时缓存服务器还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。</p>
<p>一般来说，<strong>根据承载内容类型和服务种类的不同，分发服务系统会分为多个子服务系统</strong>，如网页加速子系统、流媒体加速子系统、应用加速子系统等。每个子服务系统都是一个分布式服务集群，由一群功能近似的、在地理位置上分布部署的缓存服务器或缓存服务器集群组成，彼此间相互独立。每个子服务系统设备集群的数量根据业务发展和市场需要的不同，少则几十台，多则可达上万台，对外形成一个整体，共同承担分发服务工作。缓存服务器设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。</p>
<p>分发服务系统在承担内容的更新、同步和响应用户需求的同时，还需要向上层的调度控制系统提供每个缓存服务器的健康状况信息、响应情况，有时还需要提供内容分布信息，以便调度控制系统根据设定的策略决定由哪个缓存服务器（组）来响应用户的请求最优。</p>
<hr>
<h3 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a><strong>负载均衡系统</strong></h3><p>负载均衡系统是一个CDN系统的神经中枢，主要功能是<strong>负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址</strong>。大多数CDN系统的负载均衡系统是分级实现的，这里以最基本的两级调度体系进行简要说明。一般而言，两级调度体系分为<strong>全局负载均衡（GSLB）和本地负载均衡（SLB）</strong>。</p>
<p>我们刚说的全局负载均衡设备及区域负载均衡设备都属于全局负载均衡，本地负载均衡设备则属于本地负载均衡。</p>
<p>其中，全局负载均衡（GSLB）主要根据用户就近性原则，通过对每个服务节点进行”最优”判断，确定向用户提供服务的缓存服务器集群的物理位置。<strong>最通用的GSLB实现方法是基于DNS解析的方式实现</strong>，也有一些系统采用了应用层重定向等方式来解决。<strong>本地负载均衡（SLB）主要负责节点内部的设备负载均衡</strong>，当用户请求从 GSLB调度到SLB时，SLB会根据节点内各缓存服务器设备的实际能力或内容分布等因素对用户进行重定向，常用的本地负载均衡方法有基于4层调度、基于7层调度、链路负载调度等。</p>
<hr>
<h3 id="运营管理系统"><a href="#运营管理系统" class="headerlink" title="运营管理系统"></a><strong>运营管理系统</strong></h3><p>CDN的运营管理系统与一般的电信运营管理系统类似，分为运营管理和网络管理两个子系统。</p>
<p>运营管理子系统是CDN系统的业务管理功能实体，负责处理业务层面的与外界系统交互所必需的一些收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p>
<p>网络管理子系统实现对CDN系统的网络设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源进行集中化管理操作的界面，通常是基于Web方式实现的。</p>
<p>在CDN系统中，不仅分发服务系统和调度控制系统是分布式部署的，运营管理系统也是分布式部署的，每个节点都是运营管理数据的生成点和采集点，通过日志和网管代理等方式上报数据。可以说，CDN本身就是一个大型的具有中央控制能力的分布式服务系统。</p>
<p>试着使用一下腾讯云提供的CDN服务吧，或许会对你理解运营管理系统有帮助。</p>
<hr>
<h2 id="为什么需要CDN？"><a href="#为什么需要CDN？" class="headerlink" title="为什么需要CDN？"></a><strong>为什么需要CDN？</strong></h2><p>当下的互联网应用都包含大量的静态内容，但静态内容以及一些准动态内容又是最耗费带宽的，特别是针对全国甚至全世界的大型网站，如果这些请求都指向主站的服务器的话，不仅是主站服务器受不了，单端口500M左右的带宽也扛不住，所以大多数网站都需要CDN服务。</p>
<p>根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响，任何的企业都渴望自己站点有更快的访问速度。而HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP/IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。</p>
<p>这就是你使用CDN的第一个也是最重要的原因：为了加速网站的访问。</p>
<p>除了加速网站的访问之外，CDN还有一些作用：</p>
<p><strong>1. 实现跨运营商、跨地域的全网覆盖</strong></p>
<p>互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。阿里云在国内有500+节点，海外300+节点，覆盖主流国家和地区不是问题，可以确保CDN服务的稳定和快速。</p>
<p><strong>2. 保障你的网站安全</strong></p>
<p>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。</p>
<p><strong>3. 异地备援</strong></p>
<p>当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。</p>
<p><strong>4. 节约成本</strong></p>
<p>投入使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</p>
<p><strong>5. 让你更专注业务本身</strong></p>
<p>CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。</p>
<hr>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a><strong>其它</strong></h2><h3 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a><strong>流量劫持</strong></h3><p>其实，CDN本身就是一种DNS劫持，只不过是良性的。不同于黑客强制DNS把域名解析到自己的钓鱼IP上，CDN则是让DNS主动配合，把域名解析到临近的服务器上。</p>
<p>劫持通常分为两类：</p>
<ol>
<li><p><strong>域名劫持</strong>，又称<strong>DNS劫持</strong>，通常是指域名指向到非正常IP（恶意IP），该恶意IP通过反向代理的方式，在能返回网页正常内容的情况，可能插入恶意代码、监听网民访问、劫持敏感信息等操作。通常验证一个域名是否被劫持的方法是PING一个域名，如果发现PING出来的IP不是您的服务器真实IP，则可以确定被劫持了。</p>
</li>
<li><p><strong>数据劫持</strong>，通常由电信运营商中某些员工等勾结犯罪分子，在公网中进行数据支持，插入，此类情况极隐蔽，不会改变用户域名解析IP，而是直接数据流经运营商宽带时在网页中挺入内容，此类情况，建议网页启用HTTPS加密，可以解决这一问题（通信是加密的，运营商无法插入恶意内容）。</p>
</li>
</ol>
<p>如果使用CDN服务，当源站向CDN返回被劫持的内容时，此时CDN将获取不到正确的网页内容（而是经运营商篡改强制植入广告的页面），此时可能导致该内容在CDN中长时间缓存，发现这种问题，可以清理CDN缓存，一般即可恢复正常。</p>
<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a><strong>CDN缓存</strong></h3><p>CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循HTTP标准协议，通过HTTP缓存机制来设置CDN边缘节点数据缓存时间。</p>
<p>当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求（back to the source request），从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p>
<p>CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p>
<p>CDN缓存时间会对回源率产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大了访问延时；若CDN缓存时间太长，会带来数据更新慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p>
<p>CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用刷新缓存功能来强制CDN节点上的缓存过期，保证客户端在访问时，拉取到最新的数据。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>熟悉CDN系统的请求与响应流程；</li>
<li>熟悉CDN系统的部署架构及功能架构；</li>
<li>掌握CDN系统中全局负载均衡与本地负载均衡的相关概念；</li>
<li>掌握CDN系统中全局负载均衡设备、区域负载均衡设备、本地负载均衡设备间各个的功能及相关概念；</li>
<li>了解使用CDN的好处；</li>
<li>了解流量劫持与CDN缓存。</li>
</ol>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="https://www.zhihu.com/question/21771529/answer/190036779" target="_blank" rel="noopener">如何自己架设部署CDN — 视界云</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/05/25/计算机组成原理-64位CPU装载32位操作系统，它的寻址能力还是4GB吗？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/25/计算机组成原理-64位CPU装载32位操作系统，它的寻址能力还是4GB吗？/" itemprop="url">
                  计算机组成原理--64位CPU装载32位操作系统，它的寻址能力还是4GB吗？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-25 23:20:56" itemprop="dateCreated datePublished" datetime="2018-05-25T23:20:56+08:00">2018-05-25</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机组成原理/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">4.5k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">4 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>借由这个问题，今天我们就把 32 位 CPU、64 位 CPU、32 位操作系统、64 位操作系统之间的区别与联系彻底搞清楚。对于这个问题，博主也是一知半解了好长时间啊~</p>
<hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><h3 id="32位的CPU与64位CPU"><a href="#32位的CPU与64位CPU" class="headerlink" title="32位的CPU与64位CPU"></a><strong>32位的CPU与64位CPU</strong></h3><p>以下内容摘自维基百科：</p>
<blockquote>
<p>64 位 CPU 是指 CPU 内部的通用寄存器的宽度为 64 比特，支持整数的 64 比特宽度的算术与逻辑运算。那么 32 位 CPU 同理。</p>
<p>一个 CPU，联系外部的数据总线与地址总线，可能有不同的宽度；术语“64位”也常用于描述这些总线的大小。不过这一术语也可能指电脑指令集的指令长度，或其它的数据项。去掉进一步的条件，“64位”电脑架构一般具有 64 位宽的整数型寄存器，它可支持 64 位“区块”的整数型数据。</p>
<p>64 位架构无疑可应用在需要处理大量数据的应用程序，如数字视频、科学运算、和早期的大型数据库。</p>
</blockquote>
<p>那么 <strong>32 位 CPU 与 64 位 CPU 到底有什么区别</strong>？</p>
<ol>
<li><strong>数据处理能力增强</strong>：64 位 CPU 通用寄存器的位宽增加一倍，这也就意味着 64 位 CPU 可以一次性处理 64bit 的整形数据；</li>
<li><strong>内存寻址能力增强</strong>：如果是 32 位 CPU 的话，它的地址总线最多不会超过 32，那么它所能达到的寻址范围也就不会超过 2 的 32 次方字节（存储单元以字节为单位），也就是 4GB，而如果是 64 位处理器的话，它所能达到的寻址范围理论上就会是 2 的 64 次方字节（上亿 GB）。</li>
</ol>
<p><strong>补充</strong>：一般处理器多少位是指通用寄存器的长度，当然数据线需要与之相同；地址线则不需要与之相等，好比 intel 64 位处理器则是 40 位地址总线，最大支持 1TB 的内存寻址。</p>
<h3 id="32位操作系统与64位操作系统"><a href="#32位操作系统与64位操作系统" class="headerlink" title="32位操作系统与64位操作系统"></a><strong>32位操作系统与64位操作系统</strong></h3><p>平时我们所说的 32 位操作系统也被称为 X86 系统，x64 代表 64 位操作系统，关于它的简略解释：<a href="https://www.zhihu.com/question/49601232/answer/309709569" target="_blank" rel="noopener">为什么32位的计算机系统不叫x32而叫x86呢？</a></p>
<p>关于 32 位操作系统与 64 位操作系统的区别如下：</p>
<ol>
<li><p>32 位操作系统既可以运行在 32 位的 CPU 上，也可以运行在 64 位的 CPU 上，只不过，运行在 64 位 CPU 上的话，就有点“大马拉小车”的感觉了——无法发挥出 CPU 的全部能力。</p>
</li>
<li><p>64 位操作系统只能运行在 64 位的 CPU 上，因此如果一个操作系统是 64 位，那么它的 CPU 架构也必定是 64 位。</p>
</li>
<li><p>64 位操作系统相比于 32 位操作系统的优势正如上述 64 位 CPU 与 32 位 CPU 的优势一样。</p>
</li>
</ol>
<hr>
<h2 id="总线结构与主板构成"><a href="#总线结构与主板构成" class="headerlink" title="总线结构与主板构成"></a><strong>总线结构与主板构成</strong></h2><p><strong>注：以下两部分内容摘抄自：<a href="https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html" target="_blank" rel="noopener">32位系统最大只能支持4GB内存之由来</a>~</strong></p>
<p>在解决本文标题所述的问题之前，我们再来了解一些关于总线结构与主板构成的相关知识。</p>
<p>说起总线大家肯定不陌生，而且大家平时肯定跟它打过交道，我们在用U盘拷贝数据的时候先要把U盘通过USB接口与电脑相连才能拷贝。USB接口实际上就是一种总线，一般称这种总线为USB总线（也叫做通用串行总线）。在很久之前是没有USB总线的，那个时候每个外设各自采用自己的接口标准，举个最简单的例子：鼠标生产厂商采用鼠标特有的接口，键盘生产厂商用键盘特有的接口，这样一来的话，PC机上就必须提供很多接口，这样一来增加了硬件设计难度和成本，直到后来USB接口的出现，它统一了很多外设接口的标准，不仅使得用户可以很方便地连接一些外设，更增强了PC的可扩展性。所以现在大家看到的鼠标、键盘、U盘、打印机等等这些外设都可以直接通过USB接口直接插到电脑上的。</p>
<p>在计算机系统中总线是非常重要的一个概念，正是因为有了总线，所有的组成部件才能一起正常协同分工合作。在很久以前的PC机中，采用的是三总线结构，即：数据总线、地址总线、控制总线。它们分别用来传输不同类型的数据，数据总线用来传输数据，地址总线用来传输地址，控制总线用来传输一些控制信号。</p>
<p>随着时代的发展，这种简单的总线结构逐渐被淘汰。下面这幅图是现代计算机采用的结构：</p>
<p><img src="计算机总线结构.jpg" alt="此处输入图片的描述"></p>
<p>事实上这也是现代主板所采用的结构，当然可能部分地方有略微不同（大体结构是差不多的），仔细观察过主板构成的朋友可能对上面一幅图很熟悉。在主板上主要有两大主要部分：北桥（North Bridge也称Host Bridge）和南桥（South Bridge）。北桥主要负责CPU和内存、显卡这些部件的数据传送，而南桥主要负责I/O设备、外部存储设备以及BIOS之间的通信。现在有些主板已经没有北桥了，因为芯片厂商已经把北桥所负责的功能直接集成到CPU中了（不过暂且我们以上副图的模型来讨论）。</p>
<p>在上副图中，我没有画出数据总线和地址总线等，因为在某些总线标准中它们被集成到一起了，比如在PCI总线中，地址总线和数据总线总是分时复用的（也就是说假如PCI总线有32位数据总线，这32位总线在某个时刻可以充当数据总线的作用，在下一时刻可以充当地址总线的作用）。有的总线同时提供了数据总线和地址总线。</p>
<p>下面来说一下几个主要总线和南北桥的作用：</p>
<ol>
<li><p>FSB总线：即前端总线（Front Side Bus），CPU和北桥之间的桥梁，CPU和北桥传递的所有数据必须经过FSB总线，可以这么说，FSB总线的频率直接影响到CPU访问内存的速度。</p>
</li>
<li><p>北桥：北桥是CPU和内存、显卡等部件进行数据交换的唯一桥梁，也就是说CPU想和其他任何部分通信必须经过北桥。北桥芯片中通常集成的还有内存控制器等，用来控制与内存的通信。现在的主板上已经看不到北桥了，它的功能已经被集成到CPU当中了。</p>
</li>
<li><p>PCI总线：PCI总线是一种高性能局部总线，其不受CPU限制，构成了CPU和外设之间的高速通道。比如现在的显卡一般都是用的PCI插槽，PCI总线传输速度快，能够很好地让显卡和CPU进行数据交换。</p>
</li>
<li><p>南桥：主要负责I/O设备之间的通信，CPU要想访问外设必须经过南桥芯片。</p>
</li>
</ol>
<p>在了解了这些基础东西之后，下面来讲解一下为何 32 位系统最大只支持 4GB 内存。（是的，就算是 64 位的 CPU，装载 32 位的操作系统，它的寻址能力还是 4GB。）</p>
<hr>
<h2 id="对于标题的解释"><a href="#对于标题的解释" class="headerlink" title="对于标题的解释"></a><strong>对于标题的解释</strong></h2><p>在使用计算机时，其最大支持的内存是由<strong>操作系统</strong>和<strong>硬件</strong>两方面决定的。</p>
<p>先说一下硬件方面的因素，在上面已经提到了地址总线，在计算机中 CPU的地址总线数目 决定了CPU 的 寻址 范围，这种由地址总线对应的地址称作为物理地址。假如CPU有32根地址总线（一般情况下32位的CPU的地址总线是32位，也有部分32位的CPU地址总线是36位的，比如用做服务器的CPU），那么提供的可寻址物理地址范围 为 232=4GB（在这里要注意一点，我们平常所说的32位CPU和64位CPU指的是CPU一次能够处理的数据宽度，即位宽，不是地址总线的数目）。自从64位CPU出现之后，一次便能够处理64位的数据了，其地址总线一般采用的是36位或者40位（即CPU能够寻址的物理地址空间为64GB或者1T）。在CPU访问其它任何部件的时候，都需要一个地址，就像一个快递员送快递，没有地址他是不知道往哪里送达的，举个例子，CPU想从显存单元读取数据，必须知道要读取的显存单元的实际物理地址才能实现读取操作，同样地，从内存条上的内存单元读取数据也需要知道内存单元的物理地址。换句话说，CPU访问任何存储单元必须知道其物理地址。</p>
<p>用户在使用计算机时能够访问的最大内存不单是由CPU地址总线的位数决定的，还需要考虑操作系统的实现。实际上用户在使用计算机时，进程所访问到的地址是逻辑地址，并不是真实的物理地址，这个逻辑地址是操作系统提供的，CPU在执行指令时需要先将指令的逻辑地址变换为物理地址才能对相应的存储单元进行数据的读取或者写入（注意逻辑地址和物理地址是一一对应的）。</p>
<p>对于32位的windows操作系统，其逻辑地址编码采用的地址位数是32位的，那么操作系统所提供的逻辑地址寻址范围是4GB，而在intel x86架构下，采用的是内存映射技术(Memory-Mapped I/O, MMIO)，也就说将4GB逻辑地址中一部分要划分出来与BIOS ROM、CPU寄存器、I/O设备这些部件的物理地址进行映射，那么逻辑地址中能够与内存条的物理地址进行映射的空间肯定没有4GB了，看下面这幅图就明白了：</p>
<p><img src="CPU寻址.jpg" alt="此处输入图片的描述"></p>
<p>所以当我们装了32位的windows操作系统，即使我们买了4GB的内存条，实际上能被操作系统访问到的肯定小于4GB，一般情况是3.2GB左右。假如说地址总线位数没有32位，比如说是20位，那么CPU能够寻址到1MB的物理地址空间，此时操作系统即使能支持4GB的逻辑地址空间并且假设内存条是4GB的，能够被用户访问到的空间不会大于1MB（当然此处不考虑虚拟内存技术），所以用户能够访问到的最大内存空间是由硬件和操作系统两者共同决定的，两者都有制约关系。</p>
<p>于64位的操作系统，其逻辑地址编码采用的地址位数是40位，能够最大支持1T的逻辑地址空间。考虑一种情况，假如CPU是64位的，地址总线位数是40位，操作系统也是64位的，逻辑地址编码采用的地址位数也是40位，内存条大小是64GB，那么是不是内存条的64GB全部都能被利用了呢？答案是不一定，因为这里面还要考虑一个因素就是内存控制器，内存控制器位于北桥之内（现在基本都是放在CPU里面了），内存控制器的实际连接内存的地址线决定了可以支持的内存容量，也就是说内存控制器与内存槽实际连接的地址线如果没有40位的话，是无法完全利用64GB的内存条的存储空间的。当然对于内存控制器这个问题几乎可以不用考虑，因为现在大多数的内存控制器至少都采用的是40位地址总线。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>对于以上所述，我进行一下简单的总结：</p>
<blockquote>
<p>一个计算机，它的内存访问能力是由硬件和软件共同决定的。硬件层面就指 CPU 的寻址能力，也就是地址总线的个数。软件层面，指的就是操作系统。实际上我们（进程）在进行内存访问的时候，访问的都是逻辑地址，而逻辑地址是由操作系统提供的。对于 32 位的操作系统，其逻辑地址编码采用的地址位数是 32 位，那么操作系统所提供的逻辑地址寻址范围就是 4GB。从这个方面来说，纵使你的 CPU 实际寻址能力为 2 的 64 次方，由于操作系统只提供 4GB 的逻辑地址，那 CPU 透过操作系统所能访问到的内存大小也就只有4GB了。</p>
</blockquote>
<p>对与上述总结，我还有一个简单的补充：</p>
<p>在和我的大神小伙伴讨论的时候，他对于“为什么 64 位 CPU 装载 32 位操作系统，它的寻址能力还是 4GB”这个问题的解答，只说了一句话：“32 位操作系统没有对应 64 位的寻址指令”。在细细品味之后，觉得颇有道理，我对于这句话的浅显理解是：32 位操作系统没有对应 64 位的寻址指令，所以它不能提供 4GB 以上的逻辑地址，所以 64 位 CPU 透过 32 位操作系统，它的寻址能力依旧是 4GB。</p>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>维基百科：<a href="https://zh.wikipedia.org/wiki/64%E4%BD%8D%E5%85%83" target="_blank" rel="noopener">64位</a></p>
<p><a href="https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html" target="_blank" rel="noopener">32位系统最大只能支持4GB内存之由来</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/04/27/Java并发-synchronized实现原理及锁优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/Java并发-synchronized实现原理及锁优化/" itemprop="url">
                  Java并发--synchronized实现原理及锁优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-27 11:38:27" itemprop="dateCreated datePublished" datetime="2018-04-27T11:38:27+08:00">2018-04-27</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java并发/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.6k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">9 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：本文中的部分内容摘抄自他人博客，如有侵权，请联系我，侵删~</strong></p>
<p>本篇博客主要讲述 synchronized 关键字的实现原理以及 JDK 1.6 后对 synchronized 的种种优化。synchronized 的使用不再赘述。</p>
<hr>
<h2 id="博主目前依旧存在的疑惑"><a href="#博主目前依旧存在的疑惑" class="headerlink" title="博主目前依旧存在的疑惑"></a><strong>博主目前依旧存在的疑惑</strong></h2><p>请在阅读完此篇博客之后，帮助博主回答这三个问题：</p>
<ol>
<li>多线程争夺 Monitor 的具体过程是怎样的？是根据 ObjectMonitor 中的 _count 值判断当前 Monitor 是否被锁定吗？</li>
<li>JVM 如果检测到在单线程环境下执行同步代码（StringBuffer），是会进行锁消除呢，还是会使用偏向锁？</li>
<li>对于偏向锁的撤销过程及膨胀过程，博主只是在一些博客的基础上给出了自己的理解！不权威，建议阅读源码，博主对这部分知识的讲解持怀疑态度，如果在阅读的过程中发现博主对偏向锁的撤销与膨胀理解有误，请指出，感激不尽~（网上基本上没有从源码角度分析的，对于偏向锁撤销与升级的详细过程也是众说纷纭）</li>
</ol>
<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>我们先来看一份代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对其进行 javap 反编译分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">javap -c SynchronizedTest.class</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">"SynchronizedTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">xiyoulinux</span>.<span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> org.xiyoulinux.SynchronizedTest();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: aload_1</span><br><span class="line">       <span class="number">5</span>: monitorexit</span><br><span class="line">       <span class="number">6</span>: goto          <span class="number">14</span></span><br><span class="line">       <span class="number">9</span>: astore_2</span><br><span class="line">      <span class="number">10</span>: aload_1</span><br><span class="line">      <span class="number">11</span>: monitorexit</span><br><span class="line">      <span class="number">12</span>: aload_2</span><br><span class="line">      <span class="number">13</span>: athrow</span><br><span class="line">      <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>     <span class="number">6</span>     <span class="number">9</span>   any</span><br><span class="line">           <span class="number">9</span>    <span class="number">12</span>     <span class="number">9</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比 javap 的输出结果，我们做一个简单的总结：</p>
<blockquote>
<p><strong>同步方法</strong>：synchronized 方法会被翻译成普通的方法调用。在 JVM 字节码层面并没有任何特别的指令来实现被 synchronized 修饰的方法。在 Class 文件的方法表中将该方法的 access_flags 字段中的 synchronized 标志位置 1，表示该方法是同步方法并使用调用该方法的对象（对象锁）或该方法所属的 Class（类锁） 做为锁对象。</p>
<p><strong>同步块</strong>：monitorenter 指令插入到同步代码块的开始位置，monitorexit 指令插入到同步代码块的结束位置，JVM 需要保证每一个 monitorenter 都有一个 monitorexit 与之相对应。任何对象都有一个 monitor 与之相关联，当且一个 monitor 被持有之后，他将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 所有权，即尝试获取对象的锁。（关于上述字节码中一个 monitorenter 指令为什么对应两个 monitorexit 指令我们稍后进行说明）</p>
</blockquote>
<hr>
<h2 id="synchronized底层语义原理"><a href="#synchronized底层语义原理" class="headerlink" title="synchronized底层语义原理"></a><strong>synchronized底层语义原理</strong></h2><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a><strong>Java对象头</strong></h3><p>要深入理解 synchronized 的实现原理，先来了解一下 Java 对象头。</p>
<p>对象在堆中由三部分组成：</p>
<blockquote>
<ol>
<li>对象头</li>
<li>实例变量</li>
<li>填充数据</li>
</ol>
</blockquote>
<ul>
<li><strong>实例变量</strong>：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</li>
<li><strong>填充数据</strong>：由于虚拟机要求对象起始地址必须是 8 字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</li>
<li><strong>对象头</strong>：HotSpot 虚拟机的对象头主要包括两部分数据：<strong>Mark Word（标记字段）、Class Point（类型指针）</strong>。其中 Class Point 是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。它还用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li>
</ul>
<p>Java 对象头一般占有两个字宽（在 32 位虚拟机中，1 个字宽等于 4 字节，也就是 32bit），但是如果对象是数组类型，则需要三个字宽，因为 JVM 虚拟机可以通过 Java 对象的元数据信息确定 Java 对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p>
<p>对象头的存储结构如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>32/64 bit</td>
<td>Mark Word</td>
<td>存储对象的 hashCode 或锁信息等。</td>
</tr>
<tr>
<td>32/64 bit</td>
<td>Class Metadata Address</td>
<td>存储到对象类型数据的指针</td>
</tr>
<tr>
<td>32/64 bit</td>
<td>Array length</td>
<td>数组的长度（如果当前对象是数组）</td>
</tr>
</tbody>
</table>
<p>32 位 JVM 的 Mark Word 的默认存储结构如下：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>25bit</th>
<th>4bit</th>
<th>1bit是否是偏向锁</th>
<th>2bit 锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>无锁状态</td>
<td>对象HashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到 JVM 的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如 32 位 JVM 下，除了上述列出的 Mark Word 默认存储结构外，还有如下可能变化的结构：</p>
<p><img src="Java对象头.jpg" alt="此处输入图片的描述"></p>
<h3 id="Monitor（管程）"><a href="#Monitor（管程）" class="headerlink" title="Monitor（管程）"></a><strong>Monitor（管程）</strong></h3><ul>
<li>什么是 Monitor（管程）？</li>
</ul>
<blockquote>
<p>我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。所有的 Java 对象都是天生的 Monitor，在 Java 的设计中 ，每一个 Java 对象都带了一把看不见的锁，它叫做内置锁或者 Monitor 锁。</p>
</blockquote>
<p>观察 Mark Word 存储结构的那张图（上图）：</p>
<blockquote>
<p>这里我们主要分析一下重量级锁也就是通常说 synchronized 的对象锁，锁标识位为 10，其中指针指向的是 monitor 对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在 Java 虚拟机(HotSpot)中，monitor 是由 ObjectMonitor 实现的，其主要数据结构如下：（位于 HotSpot 虚拟机源码 ObjectMonitor.cpp 文件，C++实现）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;          <span class="comment">// 记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL;       <span class="comment">// 处于 wait 状态的线程，会被加入到 _WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span>;</span><br><span class="line">    _Responsible  = NULL;</span><br><span class="line">    _succ         = NULL;</span><br><span class="line">    _cxq          = NULL;</span><br><span class="line">    FreeNext      = NULL;</span><br><span class="line">    _EntryList    = NULL;       <span class="comment">// 处于等待锁 block 状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span>;</span><br><span class="line">    _SpinClock    = <span class="number">0</span>;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObjectMonitor 中有两个队列，_WaitSet 和 _EntryList，用来保存 ObjectWaiter 对象列表( 每个等待锁的线程都会被封装成 ObjectWaiter 对象)，_owner 指向持有 ObjectMonitor 对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的 monitor 后会把 monitor 中的 _owner 变量设置为当前线程，同时 monitor 中的计数器 _count 加 1。若线程调用 wait() 方法，将释放当前持有的 monitor，_owner 变量恢复为 null，_count 自减 1，同时该线程进入 _WaitSet 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor（锁）并复位变量的值，以便其它线程进入获取 monitor(锁)。</p>
<p>由此看来，monitor 对象存在于每个 Java 对象的对象头中(存储的是指针)，synchronized 便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因，同时也是 notify/notifyAll/wait 等方法存在于顶级对象 Object 中的原因（锁可以是任意对象，所以可以被任意对象调用的方法是定义在 object 类中）。</p>
<h3 id="synchronized方法底层原理"><a href="#synchronized方法底层原理" class="headerlink" title="synchronized方法底层原理"></a><strong>synchronized方法底层原理</strong></h3><p>我们在引言部分对 synchronized 方法已经做了一个简单的总结，现在对它进行一点补充：</p>
<blockquote>
<p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层操作系统的 Mutex Lock 来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方从 JVM 层面对 synchronized 进行了较大优化，所以现在的 synchronized 锁效率也优化得很不错了。Java 6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，关于锁优化的内容，我们稍后再谈。</p>
</blockquote>
<h3 id="synchronized代码块底层原理"><a href="#synchronized代码块底层原理" class="headerlink" title="synchronized代码块底层原理"></a><strong>synchronized代码块底层原理</strong></h3><p>在引言部分，我们对 synchronized 代码块也做了一个简单的总结。同样，对其做一点补充：</p>
<blockquote>
<p>当执行 monitorenter 指令时，当前线程将试图获取对象锁所对应的 monitor 的持有权，当对象锁的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有对象锁的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值会加 1。倘若其他线程已经拥有对象锁的 monitor 的所有权，那当前线程将被阻塞，直到正在执行的线程执行完毕，即 monitorexit 指令被执行，执行线程将释放 monitor 并设置计数器值为 0，其他线程将有机会持有 monitor。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个 monitorexit 指令。</p>
</blockquote>
<hr>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a><strong>锁优化</strong></h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a><strong>自旋锁与自适应自旋</strong></h3><p>如前面所述，synchronized 在 JDK 1.6 之前之所以被称为“重量级锁”，是因为对于互斥同步的性能来说，影响最大的就是阻塞的实现。挂起线程与恢复线程的操作都需要转入<strong>内核态</strong>中完成。从用户态转入内核态是比较耗费系统性能的。</p>
<p>研究表明，大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环，使当前线程不放弃处理器的执行时间(这也是称为自旋的原因)，在经过若干次循环后，如果得到锁，就顺利进入临界区。</p>
<p>但是自旋不能代替阻塞，首先，自旋锁需要多处理器或一个处理器拥有多个核心的 CPU 环境，这样才能保证两个及以上的线程并行执行（一个是获取锁的执行线程，一个是进行自旋的线程）。除了对处理器数量的要求外，自旋虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间比较短，自旋的效果就比较好，否则只是白白占用了 CPU 资源，带来性能上的浪费。</p>
<p>那么自旋就需要有一定的限度，如果自旋超过了一定的次数后，还没有成功获取锁，就只能进行挂起了，这个次数默认是 10。</p>
<p>在 JDK 1.4.2 中引入了自旋锁，在 JDK 1.6 中引入了自适应自旋锁。自适应意味自旋的时间不再固定：</p>
<blockquote>
<p>如果同一个锁对象上，自旋等待刚刚成功获取锁，并且持有锁的线程正在运行，那么虚拟机就会认为此次自旋也很有可能成功，进而它将允许自旋等待持续相对更长的时间，比如 100 个循环。如果对于某个锁，自旋很少成功获取过，那么在以后获取这个锁时将可能自动省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机也就会越来越“聪明”。</p>
</blockquote>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a><strong>锁消除</strong></h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java 虚拟机在 JIT 编译时(关于 JIT 编译可以参考我的这篇博客：<a href="https://blog.csdn.net/championhengyi/article/details/78918920" target="_blank" rel="noopener">JVM–解析运行期优化与JIT编译器</a>)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。</p>
<p>锁消除的主要判定依据来源于逃逸分析技术的支持(关于逃逸分析技术可以参考周志明老师所出的《深入理解 Java 虚拟机》一书中第 11 章内容或自行百度)。</p>
<p>也许你会有疑惑，变量是否逃逸，程序员本身应该就可以判断，怎么会存在明知道不存在数据争用的情况下还使用同步？来看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 String 是一个不可变类，因此对字符串的连接操作总是通过新生成的 String 对象来进行的，在 JDK 1.5 之前，javac 编译器会对 String 连接进行自动优化，将连接转换为 StringBuffer 对象的连续 append 操作，在 JDK 1.5 之后，会转化为 StringBuilder 对象的连续 append 操作。也就是说，上述代码经过 javac 优化之后，有可能变为下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringBuffer 是一个线程安全的类，在它的 append 方法中有一个同步块，锁对象就是 sb，但是虚拟机观察变量 sb，发现它是一个局部变量，本身线程安全，并不需要额外的同步机制。因此，这里虽然有锁，但可以被安全的清除，在 JIT 编译之后，这段代码就会忽略掉所有的同步而直接执行。这就是锁消除。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a><strong>锁粗化</strong></h3><p>原则上，我们在使用同步块的时候，总是建议将同步块的作用范围限制的尽量小—使需要同步的操作数量尽可能变小，在存在锁竞争的情况下，等待锁的线程可以尽快的拿到锁。</p>
<p>大部分情况下，上述原则都正确，但是存在特殊情况，如果一系列操作下来，都对同一个对象反复加锁与解锁，甚至加锁与解锁操作出现在循环体中，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。</p>
<p>如上述代码中的 append 方法。如果虚拟机探测到了这样的操作，就会把加锁的同步范围扩展（粗化）到整个操作序列的外部。以上述代码为例，就是扩展到第一个 append 操作之前直至最后一个 append 操作之后，这样只需要加锁一次。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h3><p>偏向锁会偏向第一个获取它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要进行同步。</p>
<p>HotSpot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得（比如在单线程中使用 StringBuffer 类），为了让线程获得锁的代价更低而引入了偏向锁。当锁对象第一次被线程获取的时候，虚拟机把对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操作把获取这个锁的线程 ID 记录在对象的 Mark Word 中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不用进行任何同步操作。</p>
<p>当有另一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p>
<p><img src="偏向锁的获得与撤销.png" alt="此处输入图片的描述"></p>
<p>如上图，当线程 2 争夺锁对象时，偏向模式宣告结束。由线程 2 通知线程 1 进行偏向锁的撤销，此时线程 1 在全局安全点（没有字节码执行的地方）处进行暂停，进行解锁操作。</p>
<p>偏向锁只能被第一个获取它的线程进行 CAS 操作，一旦出现线程竞争锁对象，其它线程无论何时进行 CAS 操作都会失败。</p>
<p>在解锁成功之后，JVM 将判断当前线程的状态，如果还没有执行完同步代码块，则直接将偏向锁膨胀为轻量级锁，然后继续执行同步代码块，否则将偏向锁先撤销为无锁状态，当下一次执行同步代码块的时候再由 JVM 将其膨胀为轻量级锁。</p>
<p>使用偏向锁的优点在于在没有多线程竞争的情况下，只需进行一次 CAS 操作，就可执行同步代码块，但是我们也必须保证撤销偏向锁所耗费的性能资源要低于省去加锁取锁所节省下来的性能资源。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h3><p><strong>偏向锁一旦受到多线程竞争，就会膨胀为轻量级锁。</strong></p>
<p>偏向锁在执行同步块的时候不用做任何同步操作，而轻量级锁是在多线程交替执行同步代码块，不产生线程阻塞的情况下使用 CAS 操作去消除同步使用的互斥量。</p>
<p><strong>轻量级锁加锁</strong>：线程在执行同步块之前，如果同步对象没有被锁定，JVM 会先在当前线程的栈桢中创建用于存储锁记录（Lock Record）的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁，如果自旋还是无法获取到锁，轻量级锁便会膨胀为重量级锁。</p>
<p><strong>轻量级锁解锁</strong>：轻量级解锁时，会使用 CAS 操作来将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图：</p>
<p><img src="轻量级锁及膨胀流程.png" alt="此处输入图片的描述"></p>
<p>如上图，当线程 1 还在使用轻量级锁执行同步代码块的时候，线程 2 尝试争夺轻量级锁，就会失败，失败之后线程 2 并不会直接将轻量级锁膨胀为重量级锁，而是先进行自旋等待，如果成功获取到锁，则不进行锁的膨胀。在线程 2 成功将锁升级之后，线程 2 进行阻塞。线程 1 执行完同步代码块之后尝试 CAS 解锁，解锁失败，发现有线程对锁进行过竞争，则释放锁并唤醒等待线程。</p>
<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a><strong>锁的升级</strong></h3><blockquote>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
</blockquote>
<h3 id="各个状态锁的优缺点对比"><a href="#各个状态锁的优缺点对比" class="headerlink" title="各个状态锁的优缺点对比"></a><strong>各个状态锁的优缺点对比</strong></h3><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>始终得不到锁的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>同步块执行速度较慢。</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>synchronized 的底层实现主要依靠 Monitor（管程）；</li>
<li>从管程我们需要延伸至 Java 对象头这一部分；</li>
<li>了解过 Java 对象头之后，我们可以对 Monitor 的底层实现（ObjectMonitor）再进行简单的了解；</li>
<li>熟悉多线程争夺 Monitor 的过程；</li>
<li>最后分类讨论同步方法与同步块；</li>
<li>熟悉锁粗化、锁消除、自旋与自适应自旋等相关概念；</li>
<li>熟悉偏向锁、轻量级锁、重量级锁的相关概念；</li>
<li>熟悉偏向锁、轻量级锁解锁的过程；</li>
<li>熟悉偏向锁、轻量级锁、重量级锁膨胀的过程。</li>
</ol>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>《深入理解Java虚拟机》–周志明</p>
<p><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></p>
<p><a href="http://ifeve.com/java-synchronized/" target="_blank" rel="noopener">聊聊并发（二）Java SE 1.6中的Synchronized</a></p>
<p><a href="https://juejin.im/entry/589981fc1b69e60059a2156a" target="_blank" rel="noopener">死磕 Java 并发 - 深入分析 synchronized 的实现原理</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">dhengyi</p>
              <p class="site-description motion-element" itemprop="description">忍耐力较诸脑力，尤胜一筹。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">52</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dhengyi</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">273k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">4:08</span>
  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
