<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>H.Y&#39;s BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.dhengyi.name/"/>
  <updated>2019-11-12T15:55:13.095Z</updated>
  <id>https://blog.dhengyi.name/</id>
  
  <author>
    <name>dhengyi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>乐理--基础概念</title>
    <link href="https://blog.dhengyi.name/2019/11/12/%E4%B9%90%E7%90%86-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://blog.dhengyi.name/2019/11/12/乐理-基础概念/</id>
    <published>2019-11-12T15:28:41.000Z</published>
    <updated>2019-11-12T15:55:13.095Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>转载</strong>：<a href="https://www.cnblogs.com/devymex/p/3385179.html" target="_blank" rel="noopener">写给理工科人看的乐理（一）声学基础</a>。</p><p>要学音乐，就得先学乐理。乐理就是音乐的理论，由很多非常精妙的物理、数学和逻辑原理构成的。然而乐理书籍皆非理工科人所写，在我等看来实在是定义不明，论述不清。本系列文章将尝试使用公理化的方式来描述，尽可能对每一个概念和方法都追根溯源。</p><p>乐理的基本内容包括：和声、调式、节奏、结构、曲式。这些内容相互联系交织，单独研究其中任何一部分都不可能。为了给理工科人找一个突破口，本文将从音乐的基本物理原理开始，逐步展开各种概念。我们拒绝以未知解释未知。</p><p>在学习乐理之前我们先要了解一些基本概念。</p><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><p>最普通最基本的声波就是简谐振动所产生的正弦波了。传统乐器一般都依靠简谐振动发声，比如琴弦、簧片、鼓面等，因此发出的也是正弦波。</p><p>以某个固定<a href="https://baike.baidu.com/item/%E9%A2%91%E7%8E%87/19505" target="_blank" rel="noopener">频率</a>进行简谐振动所产生的声波称为纯音，比如音叉的声音或 220HZ 的正弦波。但世界上并不存在绝对的纯音，就像世上没有绝对的化学单质一样。只有由电声设备发出的纯音可以看作非常近似的纯音，座机电话拿起听筒听到的声音就是近似的纯音。与纯音相对的就是复合音，它由多个纯音组合而成，而音乐就是由大量不同的复合音构成的。</p><p>复合音的产生方式有无穷多种，但有两种在音乐中最为常见：一种称为谐波叠加，一种称为拍音叠加。</p><hr><h2 id="谐波"><a href="#谐波" class="headerlink" title="谐波"></a><strong>谐波</strong></h2><p>我们将一个标准的正弦波作为基准，称作基波。谐波就是比基波的频率高整数倍的波，钢琴按下一个键或小提琴拉响一根弦都会在基波的基础上产生多个谐波，音乐人往往将谐波称为“泛音”。例如某个纯音声波的频率是 f，将此纯音作为基波，其谐波的频率可为 2f、3f、4f、……，这些谐波分别称为二次谐波、三次谐波、四次谐波等。如下图所示：</p><p><img src="基波与谐波的关系.png" alt="基波与谐波的关系"></p><p>上图中最上面的是基波，从第二行往下分别是一次谐波、二次谐波等等。若一个复合音由基波及其谐波相叠加构成，则称该复合音为谐波叠加，它的频率为基波频率。基波与谐波叠加构成复合音的过程见下图：</p><p><img src="基波与谐波复合构成复合音.gif" alt="基波与谐波复合构成复合音"></p><p>实际上，所有传统乐器所发出的音都是复合音，由振幅最大的基波和一系列振幅较小的谐波叠加构成。那么我们就可以给出单音的定义了：单音特指单一乐器演奏独立的一个音发出的声波（谐波叠加），其基波的频率称为音高。不同乐器的单音所叠加的谐波在频率和振幅上都不相同，因此乐器的音色千差万别。小提琴的单音就是典型的一种谐波叠加。</p><p>由于每种乐器都有其特别的构造，因此合成一个单音的各个谐波的振幅之比也因乐器而不同。此外，乐器本身的共振所产生的音也混杂于其中，因此不同乐器奏出相同的音高，音色却具有巨大差别，可以让我们轻易分辨。</p><hr><h2 id="拍音"><a href="#拍音" class="headerlink" title="拍音"></a><strong>拍音</strong></h2><p>拍音是另一种复合音，它是由来自同一种乐器或不同乐器的两个单音相互叠加，形成具有规律性强弱变化的振动。与谐波不同的是，拍音一般要求这两个音的振幅相近，但不要求频率为倍数关系。</p><p>由于单音本身就由纯音叠加而来，再将单音相互叠加，情况将会变得非常复杂。因此为方便描述，下文将以纯音的叠加来解释拍音的形成。下图中黄色、红色和蓝色的波型分别为频率 200Hz，250Hz 和 300Hz 的纯音。黄色与蓝色两纯音叠加形成绿色的拍音波形，黄红蓝三纯音叠加形成黑色的拍音波型。</p><p><img src="拍音的形成过程.png" alt="拍音的形成过程"></p><p>分析可知，每当两个单音的波峰相遇就形成拍音的波峰，波谷相遇就形成拍音的波谷，这样的复合音从波型看起来存在周期性的振幅变化，像节拍一般，因此称为拍音。拍音的频率与叠加的两个单音的周期（频率的倒数）的比值相关，如果两个单音的频率都是整数，那么拍音的频率就等于它们周期最小公倍数的倒数。</p><p>频率相差一倍的两个单音叠加形成的拍音，其频率等于较低的音的频率，这样的拍音听起来就像一个音。</p><p>如果两个单音中至少有一个是无理数，那么拍音的情况就要复杂一些了。此时两个单音的波峰永远不会相遇，波谷亦然，只会出现非常接近的情况。如果两个波的波峰以一个近似的周期 s 相互靠得很近，那么不太精确的人耳就会“认为”这两个单音的叠加形成了频率为 1/s 的拍音。我们举例子来说明，比如单音 a 的频率 $f_a=\sqrt{3}$，单音 b 的频率 $f_b=\sqrt{5}$，它们的周期分别为 $s_a=1/f_a$，$s_b=1/f_b$，它们的波形如下图所示：</p><p><img src="频率为根号3的波形（橙）与频率为根号5的波形.png" alt="频率为 \sqrt{3} 的波形（橙）与频率为 \sqrt{5} 的波形"></p><p>无论是看起来还是理论分析，这两个波的波峰永远不可能相遇。下面我们把这两个波进行叠加：</p><p><img src="两个波叠加形成的波形.png" alt="两个波叠加形成的波形"></p><p>波叠加后形成了周期近似为 $3 \times s_a \approx 4 \times s_b$ 的拍音。这是因为 $\sqrt{3} / \sqrt{5} \approx 0.7746$，接近于 0.75，也就是 3:4。因此这个拍音的“听感频率”大约为 $\sqrt{5} / 4$ 到 $\sqrt{3} / 3$ 之间。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>纯音：以某个固定频率进行简谐振动所产生的声波；</li><li>复合音：由多个纯音组合而成，在音乐中两种最为常见——谐波叠加与拍音叠加；</li><li>基波：一个标准的正弦波作为基准；</li><li>谐波：比基波的频率高整数倍的波，音乐人也称谐波为泛音；</li><li>单音：特指单一乐器演奏独立的一个音发出的声波（谐波叠加），其基波的频率称为音高；</li><li>拍音：由来自同一种乐器或不同乐器的两个单音相互叠加，与谐波不同的是，拍音一般要求两个音的振幅相近，但不要求频率为倍数关系。</li></ol><hr><h2 id="音乐分享"><a href="#音乐分享" class="headerlink" title="音乐分享"></a><strong>音乐分享</strong></h2><p>最后，每篇与音乐相关的博客，都在这里贴一首歌曲分享给大家：</p>    <div id="aplayer-vPXKytOc" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="004NXwuk36ixAW" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#000000" data-order="random"></div><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="https://www.cnblogs.com/devymex/p/3385179.html" target="_blank" rel="noopener">写给理工科人看的乐理（一）声学基础</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="乐理" scheme="https://blog.dhengyi.name/categories/%E4%B9%90%E7%90%86/"/>
    
    
      <category term="乐理" scheme="https://blog.dhengyi.name/tags/%E4%B9%90%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>漫谈--大学期间Java Web后端成长计划，帮你斩获大厂Offer</title>
    <link href="https://blog.dhengyi.name/2019/09/22/%E6%BC%AB%E8%B0%88-%E5%A4%A7%E5%AD%A6%E6%9C%9F%E9%97%B4Java-Web%E5%90%8E%E7%AB%AF%E6%88%90%E9%95%BF%E8%AE%A1%E5%88%92%EF%BC%8C%E5%B8%AE%E4%BD%A0%E6%96%A9%E8%8E%B7%E5%A4%A7%E5%8E%82Offer/"/>
    <id>https://blog.dhengyi.name/2019/09/22/漫谈-大学期间Java-Web后端成长计划，帮你斩获大厂Offer/</id>
    <published>2019-09-22T09:33:59.000Z</published>
    <updated>2019-09-22T14:12:02.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>注</strong>：以下所有面试提问的热点问题的归纳都基于博主自身的应聘经历~不同年份、环境有可能不同，仅供参考！</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>今天又碰到一个学弟问我，“我现在比较迷茫，以后想要从事 Java 后端开发的相关工作，却不知如何系统的进行学习，学长能帮忙给一点建议吗？”。</p><p>本人目前也是一枚刚毕业的本科应届生，有幸加入美团从事 Java 后端的开发工作，回想起大学时光的学习历程，不得暗自庆幸，像不知道如何进行系统的学习，毕业后到底应该从事计算机领域哪一方面的工作等等这种类似的疑惑，基本都没有产生（准确的来说，就算是产生了，也会有学长或老师及时的帮你解决(*≧▽≦)）。</p><p>其实这种疑惑的产生应该是每一个在校生所必经的一个阶段，如果说你没有报班，不打算考研，又没有人系统的指导你学习，大学期间只是按部就班的按照课表进行知识与能力的提升，那么等你面临找工作，想要通过大公司的面试，进入一线互联网大厂进行工作，应该还是比较困难的。</p><p>博主在大学期间还算是比较系统的对 Java 后端进行了学习（有很多厉害的学长进行指点），加之在大三春招以及大四秋招期间，面试过不少的大厂（国内一二线互联网公司基本都有涉猎），发觉在 Java 后端这一块，他们提问所对应的知识模块都具有很高的相似性以及复用性，当时就想总结一篇大学期间 Java 后端的一个学习成长路线，解救广大莘莘学子于水火之中，帮助他们尽量不要迷失在庞大且复杂的知识体系中而觉得无从下手。</p><p>这里只是结合我大学四年的学习以及最后的面试经历，给大家提供的一份相对还算靠谱的学习计划，实际情况需要你结合自身发展以及未来规划作出相应的补充与完善，相信在你不断学习的过程中，会对 Java 后端的知识体系越来越明了，从而自行调整学习路线。</p><p>我将对知识的掌握程度分为三个级别：</p><ul><li><strong>了解</strong>：认真学习相关知识的基础概念、使用场景以及功能特性即可。</li><li><strong>掌握</strong>：在了解的基础上需要进行实践，能够将所学知识熟练的运用到代码之中。</li><li><strong>熟悉</strong>：在了解与掌握的基础上需要深挖其实现原理以及性能优化，需要对知识的理解达到一定的深度。</li></ul><p>然后，我将当初觉得面试官最喜欢问的问题所属的领域，分成了如下六个大类，基本上也对应了你在大学期间所要学习并掌握的一些东西。</p><p><strong>P.S.</strong>：</p><ol><li>深挖一个知识点的实现原理以及性能优化等不一定需要通过阅读源码才能实现，学会科学上网，利用网络资源，查询优质技术文章，比直接阅读一堆枯燥的源码要好的多；</li><li>计算机方面大部分的书籍都特别的厚，你不能一个字一个字、一页一页的去阅读它，你要学会找重点目录，找重点知识模块，找你现在急需查漏补缺的地方，首先去攻克它，然后再对自己的知识体系进行不断的补充，而不是一上来就逮住一本书，想要把这本书中的每一个字都啃透，那这个过程必然是十分痛苦且耗时的；</li><li>在<strong>推荐阅读书籍</strong>部分，给出的书本顺序是按照学习成本、效果产出以及正确的学习顺序综合考虑的，也就是说，第一个出现的书籍是你首先需要进行学习并且是我强推的。</li></ol><hr><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><strong>基础知识</strong></h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><strong>计算机网络</strong></h3><p>计算机网络通常被分为 OSI 七层模型或五层模型，说实话，你要问我为什么有了七层模型，还要设计出层级结构与之极其类似的五层模型，这个具体原因我还真说不上来，有兴趣的同学可以自行 Google。总之，我们一般学习计算机网络，都是按照五层模型进行分级学习。</p><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>物理层</td><td>这一层级的知识，我学习的并不是很多，面试官提问的重点也不在这一层级，姑且定义为了解。</td></tr><tr><td>数链层</td><td>本人自觉极少数面试官会提问一些这部分的知识，但这并不影响数链层其所包含知识点的重要性：数链层的差错控制、流量控制、滑动窗口协议、交换机、路由器、网关等等…这些概念都要求掌握，也许这对你的面试结果来说并不重要，但对于你个人的提升以及对计算机网络整体的理解都有非常大的帮助。</td></tr><tr><td>网络层</td><td>重点以及难点，但同样不属于面试官频繁提问的范畴，如果你需要考研，或者进行计算机网络相关的笔试，那么网络层会涉及到 IP 地址、子网掩码、子网网段等等需要你进行计算的相关知识点。除此之外，IP 协议、报文格式、ARP 协议、ICMP 协议等等也都需要你去掌握。这一层还包括一些经典的路由算法，但本人没有进行过学习，面试时也没怎么碰到过，感觉学习成本以及难度较大，暂且定义为了解吧。</td></tr><tr><td>传输层</td><td>重点！重点！重点！重要的事情一般都会说三遍，属于面试时高频提问范畴、什么拥塞控制、滑动窗口协议、三次握手、四次挥手、TCP、UDP…各种经典的问题，各种不同的问法，都能问烂。要求这一层相关概念必须达到熟悉的程度，并能自行扩展相关问题：比如为何需要三次握手，挥手为何需要四次？三次挥手行不行？建议 Google 一些关于传输层的经典面试题，知悉面试套路。</td></tr><tr><td>应用层</td><td>重点！重点！重点！没错，同样属于面试官高频提问范畴，也是与用户接触最频繁的网络层级，熟悉 <strong>HTTP 协议、DNS 协议</strong>。有关 HTTP 协议，同样有大量经典的问题，下去自行了解吧，我就不再赘述了。除此之外，还有 CDN（内容分发）、P2P（对等传输）、HTTPS（对称密钥、公开密钥算法、数字签名）等扩展知识，如果你还掌握了这些（展示自己对知识学习的深度及广度），绝对会给面试官留下不错的印象！</td></tr></tbody></table><p>计算机网络属于 Web 后端的基础知识，打好地基更是作为一名合格程序员所要具备的基本素养，因此不可懈怠有关计算机网络知识的学习。</p><p><strong>推荐阅读书籍</strong>：计算机网络（第七版，谢希仁著）、计算机网络（第五版，特南鲍姆、韦瑟罗尔著，可做进阶使用）、黑皮书就算了吧，如果不打算成为网络方面的专业人才…</p><p><strong>P.S.</strong>：额外吐槽一句，机械工业出版的黑皮书，虽然一个个大名如雷贯耳，封皮以及书本整体给人十分牛逼以及高大上的感觉，但是！对读者来说，简直就是一块难啃的硬骨头！</p><h3 id="数据结构-amp-算法"><a href="#数据结构-amp-算法" class="headerlink" title="数据结构&amp;算法"></a><strong>数据结构&amp;算法</strong></h3><p>说到数据结构与算法，很多同学应该都会觉得这是一座阻挠普通程序员通往优秀的大山，也是将程序员这个群体划分为三六九等的标准。</p><p>我对数据结构与算法同样抱有恐惧以及排斥心理，数据结构以及算法不同于计算机领域中的其它学科。其理论基础偏数学，又要求程序员具有良好的编码能力以及思维方式，可以说是一门很吃智商的学科，其特有的学习提升途径在计算机领域中又显得独树一帜，且被中国广大莘莘学子所讨厌——刷题。没有再比这无聊、痛苦的事情了，高三一年已经刷吐了，因此再次听到这个词，绝大多数人有排斥心理也是正常反应。</p><p>对于数据结构以及算法，怎么说呢？是很重要，并且同样属于计算机科学领域中众多分支学科的基础学科，其重要性可见一斑。但是如果你大学期间不是专业打比赛的，并且未来不会从事人工智能、机器学习、大数据等偏理论、偏科研方向相关的工作，应该不用担心这东西会影响你的面试结果以及未来发展。我初入职场，但依稀记得在哪好像听过一句话：<strong>不会数据结构与算法（这里肯定不是指完全不会，应该是说不要求你这方面非常厉害），不会影响你做架构师</strong>。</p><p>从我以及身边同学春招、秋招所经历的大厂面试情况来看，如果你不满足我上一段所述的条件，想要通过数据结构以及算法部分的面试，只需要掌握大学期间应掌握的、基础的数据结构及算法，并且能够刷掉剑指 Offer 1/3（30 道左右吧，应该） 的题量，问题已经不大了，如果能够刷掉剑指 Offer 2/3 的题量，拿大厂 Offer 应该是完全没有问题的，当然，这里说的刷题，并不是指你对着书本在电脑上敲一遍就完事了，你需要完全理解，并在舍弃书本的情况下，不说每道题能够完美无瑕的写出来，能够完成 80% 左右的正确编码量已经非常不错了。</p><p>如果你在大学期间能够达到 10w 行有效代码量，你的编程能力应该会超越 70% 以上与你一同毕业的人，它将成为你强而有力的竞争手段，而刷题（一定要刷值得去刷的题，不要整天刷一些简单的，不会促进自己成长的题，这不会增加你的有效代码量，更不会提高你的编程能力）则是增加有效代码量的重要手段之一。</p><p>刷题是巩固数据结构与算法学习最好的方式之一，也是最能提升编程能力的有效途径之一。刷题应该是一个不断积累的过程，考虑到刷题所需要花费的时间，最好的方式便是从现在开始，一周七天，每隔三天，一天留出 6 个小时，专门去<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a>刷题。从现在开始每次刷题就当模拟面试笔试，把控好时间，不断提升写题的速度以及正确率，坚持到你找工作的时候，相信笔试以及现场手写代码这一块，将完全不是问题！</p><p><strong>P.S.</strong>：关于牛客网的作用及使用，同学们自行了解。总之，基本是各大公司进行笔试的平台，其自身功能也非常强大，很适合有针对性的训练！</p><p><strong>数据结构</strong>：</p><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>字符串</td><td>字符串也算一种数据结构，其相关题型与算法非常多，掌握相关题型。</td></tr><tr><td>线性表</td><td>掌握数组、链表（双向链表、循环链表等），掌握相关题型。</td></tr><tr><td>栈与队列</td><td>掌握相关题型。</td></tr><tr><td>树</td><td>掌握二叉树及相关题型、哈夫曼树、二叉查找树、平衡二叉树、了解 B- 树、B+ 树、红黑树等。</td></tr><tr><td>图</td><td>如果你面试的岗位不是算法相关，大学期间也没怎么参加过竞赛，图这种数据结构在面试中基本很难被问到，但即使如此，关于图的基本概念，创建图、删除图等这些基本操作还是要掌握的。图主要涉及到一些很经典的算法，例如深搜与广搜，就算在面试中属于低频考点，但在笔试中却属于高频考点。这部分的知识博主掌握的也不是很好，学习成本比较高，总之学习的道路上，合理的时间规划也很重要。</td></tr><tr><td>哈希表</td><td>掌握哈希（散列）算法、哈希表、了解一致性哈希、分布式哈希表。</td></tr></tbody></table><p><strong>算法</strong>：</p><p>学习算法之前，务必先理解时间、空间复杂度的概念，每个算法在学习的过程中，都需要从这两个维度对性能进行考量。</p><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>递归</td><td>熟悉递归算法。</td></tr><tr><td>排序</td><td>熟悉冒泡排序（各种变形）、选择排序、插入排序（希尔排序）、快速排序、归并排序、堆排序。后三个排序属于面试中的高频考点。</td></tr><tr><td>查找</td><td>熟悉二分查找。</td></tr><tr><td>图</td><td>熟悉深度优先搜索、广度优先搜索，了解最小生成树、最短路径（Dijkstra 算法）、拓扑排序等。</td></tr><tr><td>进阶</td><td>贪心算法、动态规划…这两个算法在一些公司的笔试题中会出，已经算是难度偏上的题型了。尤其是动态规划，博主在大学期间学过一段时间，过于抽象是我给它的定义，除了笔试需要，目前感觉，为了找到一份好工作而刻意学习，意义不大（个人看法）。</td></tr></tbody></table><p><strong>推荐阅读书籍</strong>：一句话，别买<strong>算法导论</strong>就行，啃不动的，买回来就只能吃灰或用来垫电脑了。本来想强推我大西邮的教材（数据结构与算法，王曙燕著），结果发现京东上没有卖…算法（第四版，Robert Sedgewick, Kevin Wayne 著）。应该还有很多优秀的书籍，但博主并没有真正的阅读过，也就不做推荐了。</p><hr><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h2><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h3><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>List</td><td>了解 List，了解 List 所属下的所有集合，熟悉 ArrayList、LinkedList。</td></tr><tr><td>Set</td><td>了解 Set，掌握 TreeSet、熟悉 HashSet。</td></tr><tr><td>Map</td><td>了解 Map，掌握 TreeMap、熟悉 JDK 1.7 以及 JDK 1.8 中的 HashMap。</td></tr></tbody></table><p>在学习好这些基本的集合之后，你还需要了解一些非常经典的能够保证线程安全的集合，如：HashTable、ConcurrentHashMap 等等，不要求你现在就能够使用，但是你要了解一下他们为何能够保证线程安全，知悉部分原理。</p><p><strong>推荐阅读书籍</strong>：疯狂 Java 讲义（很全，很详细）、Java 学习笔记（如果你在阅读上本书的过程中觉得有困难，那就先从这本书开始，这也是博主学习 Java 时阅读的第一本书，如今觉得作为入门来说还是不错的，讲的很简单）、Effective Java（没有看过，但是书的大名如雷贯耳）。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a><strong>并发</strong></h3><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>基础</td><td>掌握线程等相关概念，掌握并发编程，能够编写保证线程安全的并发程序。</td></tr><tr><td><strong>实现线程的三种方式</strong></td><td>属于面试高频考点！掌握 Thread &amp; Runnable &amp; Callable，了解 Thread、Runnable、Callable 的异同。</td></tr><tr><td><strong>线程池</strong></td><td>属于面试高频考点！属于面试高频考点！属于面试高频考点！熟悉 Executor 接口，ExecutorService 接口，Executors，ThreadPoolExecutor，线程工厂，阻塞队列，饱和策略等！</td></tr><tr><td>进阶</td><td>这里涉及的模块很多，Java 内存模型与 volatile 关键字，原子变量的使用、synchronized（实现原理） 与读写锁的使用，对象锁与类锁…希望在学习的过程中能达到掌握的水平，如果可以的话，熟悉是更好不过了。</td></tr></tbody></table><p>并发是整个 Java 知识体系中很重要的一个模块，也是面试官很喜欢问的一个模块，更是能够体现你学习深度的一个模块，虽然这个模块的确不太好理解，但是当你得心应手之后，便会感受到并发编程的魅力。</p><p><strong>推荐阅读书籍</strong>：Java 多线程编程核心技术（高洪岩著，很基础地一本书，适合新手看，速度要快，博主当初用了一周的时间看完的）、Java 并发编程的艺术（进阶书籍，博主也是临近毕业才入手，公司 leader 给推荐，没有细看，过了一下目录，觉得应该是非常好的一本书，广度以及深度都不错）、Java 并发编程实战（大学期间看的书籍，起初感觉也是大名如雷贯耳，但是博主在学习的过程中，觉得这本书实在是太难啃了，书籍目录的编排挺不错，但是内容…可以作为参考书籍阅读，需要较强的自学能力，推荐指数不高）。</p><h3 id="IO-NIO"><a href="#IO-NIO" class="headerlink" title="IO/NIO"></a><strong>IO/NIO</strong></h3><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>基础</td><td>了解 IO/NIO，了解两者之间的区别。</td></tr><tr><td>进阶</td><td>NIO 主要应用在 Java 网络编程中，在 Web 开发中使用场景不多，但是博主依稀记得当时面试官也喜欢提问 NIO 的相关知识，因此对于 NIO 的学习还是要有一定的深度。感觉不做网络编程的话，没必要系统的进行学习，在网络上多找一些相关的技术文章学习即可。</td></tr></tbody></table><p><strong>推荐阅读书籍</strong>：同<strong><a href="#集合"> Java 集合</a></strong>。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h3><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>基础</td><td>掌握反射。</td></tr><tr><td>进阶</td><td>如果你不了解反射的原理，学习反射的时候，是很懵逼的，并且看完书本之后印象应该也不是很深刻，所以学习反射这块的知识，我倒是建议可以先从原理入手学习，反射的原理并不难理解，在<strong>深入理解 Java 虚拟机</strong>一书中有详细的解释，具体对应的章节应该是第二章／第六章——“Java 内存区域”／”类文件结构”（记忆可能有误，如果不对的话请自行寻找对应章节）</td></tr></tbody></table><p><strong>推荐阅读书籍</strong>：同<strong><a href="#集合"> Java 集合</a></strong>，可以先从基本看起，留有一个大概的印象，如果在看的过程中发现实在懵逼，可以先将这块的知识放下，等了解了反射的原理之后再回过头进行学习。</p><hr><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><strong>Spring</strong></h2><p>SSM(Spring + Spring MVC + Mybatis) 是如今最流行的 Web 后端框架，也是进入公司后进行编码时所要掌握的基础技术之一，基本上 70% 的企业级 Java Web 项目都基于 SSM 框架进行搭建。</p><p>但是我并不建议在大学期间将主要精力放在如何掌握众多框架的使用上，像博主大学期间就只学过 Spring（Spring MVC 是 Spring 的一个子集）。我一直觉得，框架这种东西，版本迭代日新月异，甚至今天还很流行的框架，在下个月就有可能被更好用的框架所替代，因此对于框架的学习，绝不在多，而在精。除此之外，面试官比较注重你对技术理解的深度，凡事喜欢问原理，如果你对框架的掌握程度都停留在使用层面，那必定是无法让面试官满意的。</p><p>基本上同种类框架的设计思想、实现方式背后都能够提炼出众多共性，当你深入理解了一种类型的框架后，就算有新的框架被设计出来，你也能够比别人更迅速的掌握。</p><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>IOC</td><td>熟悉 IOC，最好可以自己用 Java 实现一个简易的 IOC，不难，也就 1000 行带一点的代码量（可以从网上找找灵感）。推荐阅读优质博客先快速了解 IOC 的基本概念，然后阅读 “Spring 实战” 第 1 章 1.1 节的内容。</td></tr><tr><td>Bean</td><td>熟悉 Bean、了解 Spring 容器。推荐阅读优质博客快速了解 Bean 的概念，然后阅读 “Spring 实战” 第 2 章，第 3 章的内容。</td></tr><tr><td>AOP</td><td>熟悉 AOP 及两种实现原理（Java 动态代理以及 CGLIB 动态代理）。推荐阅读优质博客快速了解 AOP 的概念，然后阅读 “Spring 实战” 第 4 章的内容。</td></tr><tr><td>Spring MVC</td><td>掌握 DispatcherServlet，掌握 Spring MVC 的使用。阅读 “Spring 实战” 第 5 章。</td></tr><tr><td>推荐阅读 “Spring 实战” 章节</td><td>除了上述提到的章节，推荐阅读第 7 章 7.1 节，7.3 节，第 16 章，第 17 章的内容（第 16 章以及第 17 章的具体内容我并没有读过，只不过是想让大家了解一下 REST 接口以及异步消息等概念，企业级应用中用的挺多的）。</td></tr></tbody></table><p><strong>推荐阅读书籍</strong>：Spring 实战（第 4 版，Craig Walls 沃尔斯著，看这本书的时候，里面的大量内容，甚至大量章节可以跳过，看完没用）、Spring 技术内幕：深入解析 Spring 架构与设计原理（第 2 版，计文柯著，听说挺不错的，博主没看过）。</p><p><strong>P.S.</strong>：对于框架的掌握必须要快，并且能够抓住重点（这时候如果有人能带着你入门 Spring，便会得到事半功倍的效果），你才能腾出时间去了解框架背后的原理。博主当初就是自学 Spring 框架，看 Spring 实战（现在觉得这本书里废话简直不要太多）的时候花费了大量的时间，现在回过头来看，当初学到的很多东西已经过时，而 Spring 最核心的三个概念：Bean、IOC、AOP，哪至于用那么久的时间去掌握。</p><hr><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><strong>JVM</strong></h2><p>说起 JVM，那应该属于博主在大学期间的强项了，当时对 Java 虚拟机一直抱有敬畏以及探索之心，觉得学好 Java 虚拟机就相当于抓住了 Java 语言的根源，要说整个 Java 体系中的基础，还有什么能比 JVM 更基础的呢？当然这个观点并不正确的，并且非常偏激，博主只是在这里提一下，以回味大学时的美好时光。</p><p>事实（面试经历）证明，面试官对于 JVM，并不会问的特别详细，其所问知识的所属范畴也具有非常强的规律性，博主就直接根据大学时阅读过的 “深入理解 Java 虚拟机” 一书中的目录，给大家总结出需要掌握的重要知识点。</p><p>阅读 “深入理解 Java 虚拟机” 一书之前，我先帮助大家剔除不需要阅读的章节：</p><table><thead><tr><th>章节</th><th>章节名</th></tr></thead><tbody><tr><td>第 1 章</td><td>走近 Java。</td></tr><tr><td>第 4 章</td><td>虚拟机性能监控与故障处理工具（可以了解一下 JVM 中的一些常用命令：jstack、jmap 等，防止面试时被问到）。</td></tr><tr><td>第 5 章</td><td>调优案例分析与实战。</td></tr><tr><td>第 6 章 第 4、5、6 节</td><td>字节码指令简介（可以进行了解，好像在阅读字节码文件时会用到，面试时不问）、公有设计和私有实现、Class 文件结构的发展。</td></tr><tr><td>第 8 章 第 4 节</td><td>基于栈的字节码解释执行引擎。</td></tr><tr><td>第 9 章</td><td>类加载及执行子系统的案例与实战。</td></tr><tr><td>第 10 章</td><td>早期（编译期）优化。</td></tr><tr><td>第 11 章</td><td>晚期（运行期）优化。</td></tr></tbody></table><p>下表便是我觉得大家在本科期间需要掌握并熟悉的 JVM 相关知识，标粗的知识点是面试时可能会问的，需要重点关注下。下表中知识点的出现顺序可以作为学习顺序，感觉会更快的入门 JVM。</p><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>类文件结构</td><td>对应第 6 章内容，属于面试低频考点，但阅读完后会使你对 Java 类的认识更加深刻。</td></tr><tr><td><strong>虚拟机类加载机制</strong></td><td>对应第 7 章内容，属于面试低频考点，<strong>类加载过程</strong>以及<strong>双亲委派模型</strong>在面试中可能略有涉及，阅读完后会对 Java 类文件被 JVM 加载至内存然后运行这一过程有比较清晰的认识。</td></tr><tr><td><strong>Java 内存区域与内存溢出异常</strong></td><td>对应第 2 章内容，属于笔试高频考点，<strong>Java 内存区域</strong>属于面试高频考点，应该就是这一章会使你明白<strong>反射的原理</strong>，阅读完后会对 Java 变量，Java 对象有全新的认识。</td></tr><tr><td><strong>垃圾收集器与内存分配策略</strong></td><td>对应第 3 章内容，<strong>属于面试高频考点！属于面试高频考点！属于面试高频考点！</strong>在这一章中你需要十分熟悉<strong>分代收集算法</strong>与<strong>内存分配与回收策略</strong>，考烂了都！除此之外，还需掌握一些<strong>垃圾收集器</strong>的概念以及功能特性，以防面试时被问到。</td></tr><tr><td><strong>虚拟机字节码执行引擎</strong></td><td>对应第 8 章内容，属于面试低频考点，阅读后会对方法调用的过程以及多态有全新的认识。</td></tr><tr><td><strong>Java 语法糖的味道</strong></td><td>对应第 10 章 10.3 小节内容，属于面试低频考点，笔试高频考点，整天都在用 Java 语法糖，你确定不去深入的了解它吗？</td></tr><tr><td><strong>Java 内存模型与线程</strong></td><td>对应第 12 章内容，<strong>Java 内存模型</strong>属于面试高频考点，也是难点，学好 Java 内存区域／Java 内存模型，你便可以设计出线程安全的并发程序！</td></tr><tr><td>线程安全与锁优化</td><td>对应第 13 章内容，属于面试低频考点，但如果在面试过程中能够讲到<strong>锁优化</strong>，那绝对会带给面试官不少的惊喜。</td></tr></tbody></table><p><strong>推荐阅读书籍</strong>：深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 2 版，周志明著）。</p><hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h2><p>数据库在 Java Web 后端中的地位绝对比你想象中的要高得多得多，Java + 框架 + 数据库是组成每一个 Web 应用的基本单元，数据库对于 Java Web 的重要性，不压于 JVM 对于 Java 的重要性，数据结构与算法对于整个计算机科学的重要性！</p><p>数据库的种类非常多，可以将所有类型的数据库分为两种，一种就是以 MySQL 为代表的关系型（持久化）数据库，另一种便是以 Redis 为代表的内存型（键值对存储）数据库。</p><p>MySQL 以及 Redis 也是面试时的高频考点。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a><strong>MySQL</strong></h3><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>SQL 语句</td><td>属于面试及笔试高频考点，除基本的增删改查语句之外，子查询、联结查询、聚集函数….都是需要掌握的。平时不建议刻意去记忆，能读懂 SQL 语句就行，但是面试及笔试时经常要手写 SQL 语句，这时候你就要做一个充分的准备了。</td></tr><tr><td>存储引擎</td><td>属于面试高频考点，了解 InnoDB 与 MyISAM 的异同。</td></tr><tr><td>索引</td><td>属于面试高频考点，熟悉索引的适用场景以及功能特性，了解索引的实现原理。</td></tr><tr><td>外键约束</td><td>属于面试高频考点，熟悉外键适用场景、功能特性。</td></tr><tr><td>事务</td><td>属于面试中频考点，但很重要。熟悉事务适用场景、功能特性，熟悉事务的隔离级别（脏读、幻读等）、死锁等。</td></tr><tr><td>乐观锁 &amp; 悲观锁</td><td>属于面试高频考点，熟悉乐观锁 &amp; 悲观锁的适用场景、功能特性。</td></tr><tr><td>范式</td><td>属于面试低频考点，但有必要进行掌握。</td></tr><tr><td>实践</td><td>必须要学会简易数据库的设计！建议做一个 Web 项目，数据库中表的数量不少于 5（如何设计好实体表以及关系表，数据什么时候可以适当冗余？）。</td></tr><tr><td>进阶</td><td>如果有额外的时间精力，了解 B- 树，B+ 树，B+ 树应该是 MySQL 目前所采用的数据结构，了解一些亿级数据存储所需要掌握的高级技术——主从复制、分库分表…。</td></tr></tbody></table><p><strong>推荐阅读书籍</strong>：《阿里巴巴 Java 开发手册》– MySQL 数据库 小节，希望能知悉每条规范背后产生的原因。</p><p>再推荐一本被称作是 MySQL 数据库的圣经给大家：高性能 MySQL（第 3 版，Baron Schwartz，Peter Zaitsev，Vadim Tkachenko 著），这本书肯定不适合入门，听说读完这本书在 MySQL 领域就能达到专家级别…之前有学长读过，据说只需读完两章内容就可以给面试官吹逼…</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><p>数据库其实一直是博主的弱项，对于 MySQL 以及 Redis 都没有进行过系统的学习，都是在网络上找的技术博客进行零散的学习，尤其是 Redis，博主也只是稍有了解，当初面试的时候，基本上只要面试官提起 Redis，我都会尴尬的一笑（不会），因此这里目前无法给大家提供有用的建议，大家如果有好的建议，欢迎在评论区留言~</p><p><strong>推荐阅读书籍</strong>：<strong>Redis 设计与实现（黄健宏著）</strong>、Redis 实战（约西亚 L.卡尔森（Josiah，L.，Carlson）著）。Redis 实战是博主买的一本书，大概翻了一下，类似于 Spring 实战，内容偏实践，基本没有涉及 Redis 的设计思想以及实现原理，至于 Redis 设计与实现身边有好多同学都在看，听说很不错，内容也很有深度，如果有时间有兴趣的话，强烈推荐阅读~</p><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a><strong>设计模式</strong></h2><p>有许多种设计模式，以下列出来的是博主目前掌握的，其中前 4 个设计模式是项目中最常用也是面试官最常考的，对付面试掌握前 4 个足矣。</p><table><thead><tr><th>简介</th><th>详细</th></tr></thead><tbody><tr><td>单例模式</td><td>熟悉单例模式，熟悉如何在多线程下安全的创建单例，熟悉创建单例的各种方式（目前使用枚举进行单例的创建是最好的方式）。</td></tr><tr><td>工厂模式</td><td>熟悉工厂模式，熟悉工厂模式在线程池中的应用。</td></tr><tr><td>观察者模式</td><td>熟悉观察者模式，了解观察者模式与发布-订阅模式的异同。</td></tr><tr><td>代理模式</td><td>熟悉代理模式，熟悉代理模式在 AOP 实现原理中的应用。</td></tr><tr><td>其他模式</td><td>了解装饰者模式、策略模式、行为模式。</td></tr></tbody></table><p><strong>推荐阅读书籍</strong>：无。我觉得设计模式的学习是不需要买一本书细细去看的，这东西在了解过后要真正的实践，是需要技术、经验、工程、业务等多方面能力的沉淀。起码，现在我们只需要掌握这些设计模式的思想就行。</p><hr><h2 id="项目-amp-实习经历"><a href="#项目-amp-实习经历" class="headerlink" title="项目&amp;实习经历"></a><strong>项目&amp;实习经历</strong></h2><p>一般来说，想要在本科期间拿到大厂的 Offer，除了有扎实的基本功外，简历上还需要有 2-3 个拿的出手的项目（至少有一个项目是值得去讲给面试官听的）。这些项目不一定要求有多少代码量，更好的选择是这个项目解决了什么问题、或是项目中使用了哪些比较可讲的技术，甚至是我上面所说的，自己实现一个简易的 IOC 等等，都可以作为一个项目。</p><p>除了项目之外，如果你在大三下学期参加春招，能够找到一份不错的实习，那么这份经历在秋招的时候也会成为你一个强而有力的竞争点，毕竟在春招的时候就能进入大厂工作，本身就是对你能力的一份证明。不过在实习的时候也别光傻傻的干活了，毕竟咱们的主战场仍然是秋招，自身技术上的提升可不能因为实习而耽搁了。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>说了这么多，事实上只要你大学期间好好学习，在追求技术广度的同时不放过深度，最后的结果都不会太差。然后，如果经济条件允许的话，报个好的培训班吧（差的就别去了），真的会事半功倍，也不用愁没项目可做。</p><p>最后，欢迎大家对本篇博客作出补充及提出批评~</p><h3 id="大四秋招应聘简历"><a href="#大四秋招应聘简历" class="headerlink" title="大四秋招应聘简历"></a><strong>大四秋招应聘简历</strong></h3><div class="row">    <embed src="./dhengyi-Java开发工程师.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="漫谈" scheme="https://blog.dhengyi.name/categories/%E6%BC%AB%E8%B0%88/"/>
    
    
      <category term="Java Web" scheme="https://blog.dhengyi.name/tags/Java-Web/"/>
    
      <category term="面试" scheme="https://blog.dhengyi.name/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Geek--使用Hexo下的NexT.Mist主题进行博客搭建</title>
    <link href="https://blog.dhengyi.name/2019/07/31/Geek-%E4%BD%BF%E7%94%A8Hexo%E4%B8%8B%E7%9A%84NexT-Mist%E4%B8%BB%E9%A2%98%E8%BF%9B%E8%A1%8C%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.dhengyi.name/2019/07/31/Geek-使用Hexo下的NexT-Mist主题进行博客搭建/</id>
    <published>2019-07-31T08:19:43.000Z</published>
    <updated>2019-09-29T16:18:17.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="搭建成果"><a href="#搭建成果" class="headerlink" title="搭建成果"></a><strong>搭建成果</strong></h2><p>我使用的是 NexT 主题下的 Mist Scheme。博客展示：<a href="http://blog.dhengyi.name/">H.Y’s BLOG</a>。</p><p>在博客底部有关于所使用的 Hexo 以及 NexT 主题的版本号，各个版本的配置文件之间也许会有差距，但这不足以影响大家参照本篇博客从而构建自己喜欢的博客样式。</p><p>按照NexT官方文档的说法，如果大家的NexT版本还停留在5.x及以前，强烈建议大家将版本升级至6.x~</p><hr><h2 id="使用Hexo与NexT"><a href="#使用Hexo与NexT" class="headerlink" title="使用Hexo与NexT"></a><strong>使用Hexo与NexT</strong></h2><p>Hexo官方使用文档：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a>。</p><p>NexT主题官方使用文档：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a>。</p><p>基本上，按照上述两个文档，你就可以搭建出一个漂亮且可用的博客了，但如大家所见，我的博客中还有诸多扩展功能，这篇文章主要介绍如何将你的博客修饰的更加漂亮！</p><p><strong>注</strong>：在Hexo中有两份主要的配置文件，其名称都是<code>_config.yml</code>。其中，一份位于站点根目录下，主要包含Hexo本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><p>为了描述方便，在以下说明中，将前者称为<strong>站点配置文件</strong>， 后者称为<strong>主题配置文件</strong>。</p><hr><h2 id="升级NexT主题"><a href="#升级NexT主题" class="headerlink" title="升级NexT主题"></a><strong>升级NexT主题</strong></h2><p>更新操作何其不易，官方文档何其简陋：<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/DATA-FILES.md" target="_blank" rel="noopener">Hexo 3-DATA-FILES</a>。</p><hr><h2 id="主页修饰"><a href="#主页修饰" class="headerlink" title="主页修饰"></a><strong>主页修饰</strong></h2><h3 id="修改Favicon图标"><a href="#修改Favicon图标" class="headerlink" title="修改Favicon图标"></a><strong>修改Favicon图标</strong></h3><p>Favicon是favorites icon的缩写，亦被称为website icon（网页图标）、page icon（页面图标）或urlicon（URL图标），也就是网站标签页上的小图标。</p><p>首先推荐一个下载favicon图标的网站：<a href="https://www.easyicon.net/" target="_blank" rel="noopener">easyicon</a>。如果这个网站不能进行下载的话，就在<a href="http://ico.58pic.com/" target="_blank" rel="noopener">图标宝</a>网站进行下载，至于图标的大小，应该是没有限制的。</p><p>在<strong>主题配置文件</strong>中定位到如下代码可以修改网站的Favicon图标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon.ico</span><br><span class="line">  medium: /images/favicon.ico</span><br><span class="line">  apple_touch_icon: /images/favicon.ico</span><br><span class="line">  safari_pinned_tab: /images/favicon.ico</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure><p>默认NexT主题的Favicon图标是存放在<code>hexo-site/themes/next/source/images/</code>目录下的。</p><h3 id="修改LOGO字体"><a href="#修改LOGO字体" class="headerlink" title="修改LOGO字体"></a><strong>修改LOGO字体</strong></h3><p>也许有一些人不知道博客的LOGO是什么，就是我博客首页中显示的<code>H.Y&#39;s BLOG</code>，在<strong>主题配置文件</strong>中进行如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Font settings for Logo.</span><br><span class="line"># Fallback to `global` font settings.</span><br><span class="line">logo:</span><br><span class="line">  external: true</span><br><span class="line">  family: Kalam</span><br><span class="line">  size: 60x</span><br></pre></td></tr></table></figure><p>你可以在<a href="https://www.google.com/fonts" target="_blank" rel="noopener">Google Fonts</a>中寻找你喜欢的字体。</p><h3 id="添加菜单项"><a href="#添加菜单项" class="headerlink" title="添加菜单项"></a><strong>添加菜单项</strong></h3><p>如果想要在菜单栏中添加“音乐”一项，首先应在站点根目录下运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page music</span><br></pre></td></tr></table></figure><p>然后在<strong>主题配置文件</strong>中进行如下修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># `||` 后的值来自 FontAwesome icon。在 FontAwesome icon 中可以选择自己喜欢的 icon，直接填写 icon 对应的英文名即可。</span><br><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  caprice: /caprice/ || align-left</span><br><span class="line">  music: /music/ || music</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure><p>如果我们使用的是简体中文，还需修改<code>hexo-site\themes\next\languages\zh-CN.yml</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首页</span><br><span class="line">  archives: 归档</span><br><span class="line">  categories: 分类</span><br><span class="line">  tags: 标签</span><br><span class="line">  about: 关于</span><br><span class="line">  search: 搜索</span><br><span class="line">  schedule: 日程表</span><br><span class="line">  sitemap: 站点地图</span><br><span class="line">  commonweal: 公益 404</span><br><span class="line">  caprice: 碎语</span><br><span class="line">  music: 音乐</span><br></pre></td></tr></table></figure><h3 id="启用本地搜索"><a href="#启用本地搜索" class="headerlink" title="启用本地搜索"></a><strong>启用本地搜索</strong></h3><p>在站点的根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>编辑<strong>站点配置文件</strong>，新增以下内容到任意位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><p>编辑<strong>主题配置文件</strong>，启用本地搜索功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>此功能在<code>localhost:4000</code>好像无法进行测试，需要将页面部署至GitPage上，才能正常使用。</p><h3 id="圆形侧栏头像"><a href="#圆形侧栏头像" class="headerlink" title="圆形侧栏头像"></a><strong>圆形侧栏头像</strong></h3><p><code>hexo-site\themes\next\source\css\_custom\custom.styl</code>中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 圆形侧栏头像</span><br><span class="line">.site-author-image &#123;</span><br><span class="line">    border: 2px solid rgb(255, 255, 255);</span><br><span class="line">    border-radius: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// author-name大小</span><br><span class="line">.site-author-name &#123;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加RSS订阅"><a href="#添加RSS订阅" class="headerlink" title="添加RSS订阅"></a><strong>添加RSS订阅</strong></h3><p>关于RSS的介绍，我发现阮一峰老师讲解的特别简单与清楚：<a href="http://www.ruanyifeng.com/blog/2006/01/rss.html" target="_blank" rel="noopener">如何使用RSS</a>。</p><p>总结一下，我们可以通过在线型RSS阅读器或桌面型RSS阅读器来订阅自己喜欢的RSS内容，以后只要打开相关的RSS阅读器，就可以看到来自你订阅的不同网站的所有内容了。</p><p>想要在我们的博客中添加RSS订阅，其实非常简单，我们只需要安装hexo-generator-feed插件，然后在<strong>站点配置文件</strong>与<strong>主题配置文件</strong>进行相应参数的设置就可以了。</p><p>具体操作流程参考<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a>。其中<strong>Options</strong>一栏中的内容对相应的配置参数进行了详细的解释。</p><p>也可以参考我本人的设置，在<strong>站点配置文件</strong>中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># RSS订阅（下载完插件后，以下两行代码应该是直接有的，不需要添加）</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line"></span><br><span class="line"># Feed Atom</span><br><span class="line">feed:</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br></pre></td></tr></table></figure><h3 id="底部显示红心"><a href="#底部显示红心" class="headerlink" title="底部显示红心"></a><strong>底部显示红心</strong></h3><p>编辑<strong>主题配置文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Icon between year and copyright info.</span><br><span class="line">icon:</span><br><span class="line">  # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons</span><br><span class="line">  # `heart` is recommended with animation in red (#ff0000).</span><br><span class="line">  name: heart</span><br><span class="line">  # If you want to animate the icon, set it to true.</span><br><span class="line">  animated: true</span><br><span class="line">  # Change the color of icon, using Hex Code.</span><br><span class="line">  color: &quot;#ff0000&quot;</span><br></pre></td></tr></table></figure><hr><h2 id="文章页修饰"><a href="#文章页修饰" class="headerlink" title="文章页修饰"></a><strong>文章页修饰</strong></h2><h3 id="使用blockquote标签"><a href="#使用blockquote标签" class="headerlink" title="使用blockquote标签"></a><strong>使用blockquote标签</strong></h3><p>可以看到我的<strong>about页面</strong>以及<strong>music页面</strong>都有特殊的引用块，我们只需给发表的文章中添加如下内容，即可显示相同的样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;快乐的时候，你听的是音乐。难过的时候，你开始懂得了歌词。</span><br><span class="line">&lt;br&gt;**网易云主页：**&lt;a href=&quot;http://music.163.com/#/user/home?id=98967136&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;**dhengyi**&lt;/a&gt;&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure><p>详见：<a href="http://theme-next.iissnan.com/tag-plugins.html#center-blockquote" target="_blank" rel="noopener">内置标签-文本居中的引用</a>。</p><h3 id="添加文章阅读次数"><a href="#添加文章阅读次数" class="headerlink" title="添加文章阅读次数"></a><strong>添加文章阅读次数</strong></h3><p>虽然不蒜子也可以进行文章阅读次数的统计，但由于其只能在文章列表页中显示文章阅读数，因此博主选择使用 LeanCloud 进行博文阅读数的统计，NexT 主题为 6.x 版本的朋友们，请参照官方使用文档：<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md" target="_blank" rel="noopener">LEANCLOUD-COUNTER-SECURITY</a>。</p><p>在配置过程中，需要注意的只有一点，在官方文档的描述中，有一步需要进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在站点配置文件deploy下添加项：</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  # other deployer</span><br><span class="line">  - type: leancloud_counter_security_sync</span><br></pre></td></tr></table></figure><p>博主刚开始误会了其中的意思，导致配置文件出现了语法错误，正确的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: ******</span><br><span class="line">  branch: master</span><br><span class="line">  deploy:</span><br><span class="line">  # other deployer</span><br><span class="line">  - type: leancloud_counter_security_sync</span><br></pre></td></tr></table></figure><p><strong>注</strong>：若你的博客通过 http 方式访问，则需要将主题配置文件中的 <code>security: false</code> 如此设置，LeanCloud 中的 Counter 类才能接收到数据。当 <a href="#使用HTTPS方式访问你的博客">使用HTTPS方式访问你的博客</a> 时，完全按照官方文档进行配置，才会成功。</p><h3 id="添加字数统计与阅读时长"><a href="#添加字数统计与阅读时长" class="headerlink" title="添加字数统计与阅读时长"></a><strong>添加字数统计与阅读时长</strong></h3><p>添加字数统计与阅读时长的方式有很多，我选择使用<a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a>插件。根据我博客所使用的NexT版本，在其<strong>主题配置文件</strong>中，可以直接定位到如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: true</span><br><span class="line">  awl: 3</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure><p>正如此插件中的README所述，这个插件集成在NexT主题中，但是如果想要打开这个插件，还需要在<strong>站点配置文件</strong>中进行一些参数的配置，<strong>站点配置文件</strong>中应该添加的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 字数，阅读时长统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure><h3 id="修改文章字体大小"><a href="#修改文章字体大小" class="headerlink" title="修改文章字体大小"></a><strong>修改文章字体大小</strong></h3><p>NexT主题的字体在默认配置下有点小，我们可以在<code>hexo-site\themes\next\source\css\_variables</code>目录下对<code>base.styl</code>文件进行修改以改变字体大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Font size</span><br><span class="line">$font-size-base           = 15px    // 修改以前是14，我改成了15</span><br><span class="line">$font-size-small          = $font-size-base - 2px</span><br><span class="line">$font-size-smaller        = $font-size-base - 4px</span><br><span class="line">$font-size-large          = $font-size-base + 2px</span><br><span class="line">$font-size-larger         = $font-size-base + 4px</span><br><span class="line"></span><br><span class="line">// Headings font size</span><br><span class="line">$font-size-headings-step    = 2px</span><br><span class="line">$font-size-headings-base    = 24px  // 这个是标题大小，如果你觉得不满意，可以改的更大一点</span><br></pre></td></tr></table></figure><p>修改完之后，保存文件。重新部署hexo，就可以看到博客字体已经变成你想要的大小了。</p><h3 id="修改文章内链接样式"><a href="#修改文章内链接样式" class="headerlink" title="修改文章内链接样式"></a><strong>修改文章内链接样式</strong></h3><p>修改文件<code>hexo-site\themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中选择.post-body是为了不影响标题，选择p是为了不影响首页“阅读全文”的显示样式，颜色可以自己定义。</p><h3 id="小代码块自定义样式"><a href="#小代码块自定义样式" class="headerlink" title="小代码块自定义样式"></a><strong>小代码块自定义样式</strong></h3><p>在<code>hexo-site\themes\next\source\css\_custom\custom.styl</code>文件中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ``内的代码块自定义样式 </span><br><span class="line">code &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码框为圆角"><a href="#代码框为圆角" class="headerlink" title="代码框为圆角"></a><strong>代码框为圆角</strong></h3><p><code>hexo-site\themes\next\source\css\_common\components\highlight\highlight.styl</code>文件修改如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">code &#123;</span><br><span class="line">  padding: 2px 4px;</span><br><span class="line">  word-wrap: break-word;</span><br><span class="line">  color: $code-foreground;</span><br><span class="line">  background: $code-background;</span><br><span class="line">  border-radius: 10px;       // 加圆角</span><br><span class="line">  font-size: $code-font-size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.highlight &#123;</span><br><span class="line">  @extend $code-block;</span><br><span class="line">  // Read values from NexT config and set they as local variables to use as string variables (in any CSS section). </span><br><span class="line">  hexo-config(&apos;codeblock.border_radius&apos;) is a &apos;unit&apos; ? (cbradius = unit(hexo-config(&apos;codeblock.border_radius&apos;), px)) : (cbradius = 1px) </span><br><span class="line">  border-radius: 10px;       // 加圆角</span><br><span class="line">  </span><br><span class="line">  pre &#123;</span><br><span class="line">    border: none;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 10px 0;</span><br><span class="line">    border-radius: 10px;     // 加圆角</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码块复制功能"><a href="#代码块复制功能" class="headerlink" title="代码块复制功能"></a><strong>代码块复制功能</strong></h3><p>事实上，NexT 6.x版本已经集成了clipboard.js插件，在<strong>主题配置文件</strong>中打开就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Manual define the border radius in codeblock</span><br><span class="line">  # Leave it empty for the default 1</span><br><span class="line">  border_radius:</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result</span><br><span class="line">    show_result: true</span><br></pre></td></tr></table></figure><h3 id="修改文章底部-标签"><a href="#修改文章底部-标签" class="headerlink" title="修改文章底部 # 标签"></a><strong>修改文章底部 # 标签</strong></h3><p>编辑<code>hexo-site\themes\next\layout\_macro\post.swig</code>文件，搜索<code>rel=&quot;tag&quot;&gt;#</code>，将#换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。</p><p>其中<code>fa fa-tag</code>可以换成自己喜欢的Font Awesome图标。</p><h3 id="为文章添加版权信息"><a href="#为文章添加版权信息" class="headerlink" title="为文章添加版权信息"></a><strong>为文章添加版权信息</strong></h3><p>打开<strong>主题配置文件</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Declare license on posts</span><br><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="增加侧边阅读百分比进度条"><a href="#增加侧边阅读百分比进度条" class="headerlink" title="增加侧边阅读百分比进度条"></a><strong>增加侧边阅读百分比进度条</strong></h3><p>打开<strong>主题配置文件</strong>，搜索关键字scrollpercent，把false改为true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Scroll percent label in b2t button.</span><br><span class="line">scrollpercent: true</span><br></pre></td></tr></table></figure><h3 id="页面所占宽度调节"><a href="#页面所占宽度调节" class="headerlink" title="页面所占宽度调节"></a><strong>页面所占宽度调节</strong></h3><p>打开<code>hexo-site\themes\next\source\css\_common\components\post\post-expand.styl</code>文件，修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- @media (max-width: 767px)</span><br><span class="line">+ @media (max-width: 1080px)</span><br></pre></td></tr></table></figure><p>打开<code>hexo-site\themes\next\source\css\_variables\base.styl</code>文件，修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- $main-desktop                   = 960px</span><br><span class="line">+ $main-desktop                   = 1080px</span><br><span class="line">- $content-desktop                = 700px</span><br><span class="line">+ $content-desktop                = 810px</span><br></pre></td></tr></table></figure><h3 id="添加Gitalk评论系统"><a href="#添加Gitalk评论系统" class="headerlink" title="添加Gitalk评论系统"></a><strong>添加Gitalk评论系统</strong></h3><p>NexT 主题内集成的评论系统种类非常多，目前使用度以及好评度最高的应属 <a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 评论系统，在对 Valine 评论系统进行一番考量之后，还是决定放弃 Valine，原因主要如下：</p><ol><li>我之前使用的是 <a href="https://www.livere.com/" target="_blank" rel="noopener">LiveRe（来必力）</a>评论系统，各方面使用体验都不错，并没有觉得使用 LiveRe 会拖累网页加载速度。相反，LiveRe 系统不能提供评论提醒是我放弃他的最主要原因。作为一个评论系统，如果没法及时的回复读者的评论，并且读者也无法收到你已回复的通知，那无疑是失败的；</li><li>Valine 以轻量易用著称，并且提供了邮件通知功能，但 Valine 在诸多方面做得差强人意，比如邮件提醒链接无法直达指定文章页，只能通过进入 Leancloud 管理后台查看评论信息，才能确定评论是出现在哪一文章下。除此之外，Valine 所包含的小毛病还有很多，大家可以通过阅读官方文档进行权衡——是否使用 Valine 作为你的评论系统。</li></ol><p>最终，我选择了 <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a> 作为博客的评论系统，Gitalk 有如下特性：</p><ol><li>使用 GitHub 登录，并基于 GitHub Issues 开发，由于我的博客使用 Git Pages 搭建，被托管在 GitHub 服务器上，因此 Gitalk 是一个不错的选择；</li><li>界面简洁漂亮，个人觉得比起 Valine 也不遑多让；</li><li>Gitalk 使用 GitHub 的 Issues 作为评论内容的存储位置，每一篇文章都会对应存储评论仓库下的一个 Issue，此功能可让你通过评论直达指定文章页，弥补了 Valine 的缺点；</li><li>最重要的是，Gitalk 除了会在 GitHub 主页提醒何人何时给你提了一个 Issue——评论，还可以实现<a href="https://www.itfanr.cc/2018/09/17/hexo-add-gitment-review-system/" target="_blank" rel="noopener">钉钉机器人实时提醒</a>，你将不会错过任何一条评论，并且能够给予读者及时的回复，GitHub 主页同样会提醒读者已回复的内容。</li></ol><p>如果要说 Gitalk 比 Valine 麻烦的一点，也许就是评论时需要登录 GitHub 账户，不过换个角度思考，每一个能够实现消息提醒的系统，基本上都需要进行登录操作，而你的博客既然能够托管在 Git Pages 上，我想面向的读者应该大部分都拥有 GitHub 账号。因此，你完全不用担心使用 Gitalk 是否会大幅降低博客评论量这一可能出现的问题~</p><p>将 NexT 主题升级至 v6.6.0 版本及以上时，可直接在主题配置文件中设置 gitalk 相关配置项，而博主的 NexT 主题版本只有 v6.3.0，因此参考 <a href="https://www.itfanr.cc/2019/04/30/hexo-add-gitalk-comment/" target="_blank" rel="noopener">Hexo博客添加Gitalk评论系统</a> 进行配置。</p><hr><h2 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a><strong>扩展功能</strong></h2><h3 id="移动端显示侧边栏"><a href="#移动端显示侧边栏" class="headerlink" title="移动端显示侧边栏"></a><strong>移动端显示侧边栏</strong></h3><p>NexT主题添加这功能，前提是使用的主题模版是Muse或Mist，然后直接在<strong>主题配置文件</strong>中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Enable sidebar on narrow view (only for Muse | Mist).</span><br><span class="line">onmobile: true</span><br></pre></td></tr></table></figure><h3 id="使用hexo-tag-aplayer插件进行音乐播放"><a href="#使用hexo-tag-aplayer插件进行音乐播放" class="headerlink" title="使用hexo-tag-aplayer插件进行音乐播放"></a><strong>使用hexo-tag-aplayer插件进行音乐播放</strong></h3><p>hexo-tag-aplayer的GitHub链接：<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">MoePlayer/hexo-tag-aplayer</a>。<br>aplayer的中文文档链接：<a href="https://aplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">Aplayer</a>。</p><p>安装好插件后，我按文档中<strong>MeingJS支持 (3.0 新功能)</strong>一栏中的操作指引进行执行，最后在<code>hexo-site\source\music\index.md</code>中进行了如下编辑，插件使用成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 音乐</span><br><span class="line">date: 2018-06-02 19:10:27</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;快乐的时候，你听的是音乐。难过的时候，你开始懂得了歌词。</span><br><span class="line">&lt;br&gt;**网易云主页：**&lt;a href=&quot;http://music.163.com/#/user/home?id=98967136&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;**dhengyi**&lt;/a&gt;&lt;/blockquote&gt;</span><br><span class="line"></span><br><span class="line">&#123;% meting &quot;******&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;order:random&quot;  &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; &quot;theme:#000000&quot; %&#125;</span><br></pre></td></tr></table></figure><p>个人主页的id直接使用自己的账号登录网页版网易云音乐在URL栏就可以获取到；播放列表的id值可以通过chrome控制栏显示网页源码然后使用<code>CTRL+SHIFT+C</code>组合键直接点击喜欢的歌单就可以查找到，或是直接在<strong>我的主页</strong>定位到以下网页源码，从中获取播放列表的id：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"/playlist?id=******"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"msk"</span> title=<span class="string">"******"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="使用hexo-tag-dplayer插件进行视频播放"><a href="#使用hexo-tag-dplayer插件进行视频播放" class="headerlink" title="使用hexo-tag-dplayer插件进行视频播放"></a><strong>使用hexo-tag-dplayer插件进行视频播放</strong></h3><p>在Hexo博客中插入视频的方法有多种，使用iframe标签直接进行插入，使用video插件等等，但我还是选择hexo-tag-dplayer，此插件与hexo-tag-aplayer一样，界面清爽简洁美观，功能强大。</p><p>hexo-tag-dplayer的GitHub链接：<a href="https://github.com/MoePlayer/hexo-tag-dplayer" target="_blank" rel="noopener">MoePlayer/hexo-tag-dplayer</a>。<br>dplayer的中文文档链接：<a href="https://dplayer.js.org/#/zh-Hans/" target="_blank" rel="noopener">DPlayer</a>。</p><p>此插件在使用时，只能播放视频直链（也就是浏览器访问后直接是下载界面的那种），获取视频直链的方法我这里有一个特别方便的第三方网站，分享给大家：<a href="https://www.parsevideo.com/" target="_blank" rel="noopener">parse video</a>。一般来说，如果使用dplayer解析直链失败的话，那我们就需要对视频进行下载（自建），然后将视频资源同步到GitHub仓库上，这样做的缺点很明显，如果需要寻求更好的方法，那么我们可以将视频资源下载后再上传至百度云盘，然后获取下载直链。如果你喜欢折腾，那么还可以通过OneDrive自行部署-<a href="https://51.ruyo.net/9946.html" target="_blank" rel="noopener">OneIndex部署教程，利用OneDrive打造专属分享型网盘</a>。</p><p>最后贴上我使用dplayer的源代码：</p><pre><code>{% dplayer "url=Don't forget.mp4" "api=https://api.prprpr.me/dplayer3/" "addition=https://api.prprpr.me/dplayer/v3/bilibili?aid=1256375" "loop=false" "theme=#FADFA3" "autoplay=false" %}</code></pre><p><strong>注</strong>：dplayer支持bilibili弹幕实时同步，上述代码中的api代表引入哔哩哔哩弹幕库解析API，要同步哪个视频的弹幕，只需将addition所对应值中的aid进行改变即可，aid所对应的值为视频的AV号。</p><h3 id="添加fullPage-js页面"><a href="#添加fullPage-js页面" class="headerlink" title="添加fullPage.js页面"></a><strong>添加fullPage.js页面</strong></h3><p>在我博客的菜单栏中有这样一项：<strong>“碎语”</strong>，编写此页面的灵感及页面源码都来自<a href="https://leaferx.online/sentence/" target="_blank" rel="noopener">LEAFER x LAB</a>。</p><p>此页面使用<code>jquery.fullpage</code>进行编写，GitHub链接：<a href="https://github.com/alvarotrigo/fullPage.js/tree/master/lang/chinese#fullpagejs" target="_blank" rel="noopener">alvarotrigo/fullPage.js</a>。因为此页面也是纯静态页面，因此你可以直接根据网页源码copy出一份极度相似的页面，具体的过程我不再描述。</p><p>在网页源码中有如下两行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"https://cdn.webfont.youziku.com/wwwroot/js/wf/youziku.api.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;$youziku.load(<span class="string">".font-JzF"</span>, <span class="string">"d26f1ed13da345c6840959257b24ec98"</span>, <span class="string">"chenwixun-jian"</span>), $youziku.load(<span class="string">".font-TSS"</span>, <span class="string">"720fa84478ad4ca1a8f61a80bed1287e"</span>, <span class="string">"TSSunOld"</span>), $youziku.load(<span class="string">".font-hdj"</span>, <span class="string">"720fa84478ad4ca1a8f61a80bed1287e"</span>, <span class="string">"TSSunOld"</span>), $youziku.draw()&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>我们在自定义页面中使用的字体来自<a href="https://www.youziku.com/" target="_blank" rel="noopener">有字库</a>，上面两行代码就是有字库在网页中<a href="https://www.youziku.com/sdk/MV95ems/592965f5f629d81914b80ad8.html" target="_blank" rel="noopener">JS模式插件</a>的应用。在将字体设置好后，我们还需要将域名配置在有字库的白名单中，并且需要注意的是，JS模式中字体的Accesskey一定要配置为自己的，否则配置在远程上的页面，其字体无法正常显示。</p><p>在我们编写好页面之后，需要将其展示到我们的博客上。因为此页面是自定义页面，所以需要跳过Hexo的渲染过程，否则Hexo会在渲染的过程中产生Error，关于这个问题，在Hexo相关的Issues中已经有了明确的解决方案：编辑<strong>站点配置文件</strong>中的<code>skip_render</code> — <a href="https://github.com/hexojs/hexo/issues/1146" target="_blank" rel="noopener">如何不处理source目录下某个子目录的所有文件，仅仅是将其copy到public目录中对应目录？</a></p><h3 id="添加热文页面"><a href="#添加热文页面" class="headerlink" title="添加热文页面"></a><strong>添加热文页面</strong></h3><p>参考 <a href="http://saili.science/2017/04/02/github-for-win/#hexo-addmenu" target="_blank" rel="noopener">Git Pages 使用指南-添加阅读榜</a>。在统计文章阅读数量时我们用到了 LeanCloud，通过 LeanCloud 提供的 api 编写 js 脚本获取阅读数量信息，并展示在页面上，就可以添加热文页面。</p><p>首先我们需要 <a href="#%E6%B7%BB%E5%8A%A0%E8%8F%9C%E5%8D%95%E9%A1%B9">添加菜单项</a>，并设置中英文和图标。然后在添加菜单项时生成的 index.md 文件中添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 阅读榜 Top <span class="number">30</span></span><br><span class="line">date: <span class="number">2019</span><span class="number">-07</span><span class="number">-24</span> <span class="number">23</span>:<span class="number">32</span>:<span class="number">51</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&#123;% centerquote %&#125;岁月不饶人，我亦未曾饶过岁月&#123;% endcenterquote %&#125;</span><br><span class="line"></span><br><span class="line">&lt;p align=<span class="string">"justfly"</span> id=<span class="string">"heat"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;AV.initialize(<span class="string">"leancloud_app_id"</span>, <span class="string">"leancloud_app_key"</span>);<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="keyword">var</span> num=<span class="number">30</span></span><br><span class="line">  <span class="keyword">var</span> time=<span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> title=<span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> url=<span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> query = <span class="keyword">new</span> AV.Query(<span class="string">'Counter'</span>);</span><br><span class="line">  query.notEqualTo(<span class="string">'id'</span>,<span class="number">0</span>);</span><br><span class="line">  query.descending(<span class="string">'time'</span>);</span><br><span class="line">  query.limit(num);</span><br><span class="line">  query.find().then(<span class="function"><span class="keyword">function</span> (<span class="params">todo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> result=todo[i].attributes;</span><br><span class="line">      time=result.time;</span><br><span class="line">      title=result.title;</span><br><span class="line">      url=result.url;  </span><br><span class="line">      <span class="keyword">var</span> content=<span class="string">"&lt;p&gt;"</span>+<span class="string">"&lt;font color='#e20404'&gt;"</span>+<span class="string">"热度"</span>+time+<span class="string">"℃"</span>+<span class="string">"："</span>+<span class="string">"&lt;a href='"</span>+<span class="string">"https://yourname.github.io"</span>+url+<span class="string">"'&gt;"</span>+title+<span class="string">"&lt;/font&gt;"</span>+<span class="string">"&lt;/a&gt;"</span>+<span class="string">"&lt;/p&gt;"</span>;</span><br><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">"heat"</span>).innerHTML+=content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a><strong>高级使用</strong></h2><h3 id="使用HTTPS方式访问你的博客"><a href="#使用HTTPS方式访问你的博客" class="headerlink" title="使用HTTPS方式访问你的博客"></a><strong>使用HTTPS方式访问你的博客</strong></h3><p>由于我是在腾讯云购买的域名，因此可以在腾讯云官方网站申请免费的 SSL 证书，具体的链接我不再贴出，只要你认真寻找就能发现。</p><p>在申请成功之后，等待 20 分钟左右即可收到签发成功的通知，也可在证书控制台中实时查看审核进度。之后在浏览器中输入 <code>https://域名/</code> ，就可以看到地址栏前面有一个锁头，点开可以查看证书的相关信息~</p><p>按照上述步骤添加了 SSL 证书后，发现如果在地址栏中输入的是 <code>https://域名/</code> 就会有锁头，如果输入的是 <code>http://域名/</code>，则还是 http，并不会自动跳转至 https。其解决方案如下：</p><p>登录 GitHub，进入自己的 GitHub.io 项目中，点击 Setting，往下拉，可以看到有个选项叫 Enforce HTTPS，点击勾选即可。</p><h3 id="让Google与Baidu收录你的博客"><a href="#让Google与Baidu收录你的博客" class="headerlink" title="让Google与Baidu收录你的博客"></a><strong>让Google与Baidu收录你的博客</strong></h3><p>在将整个站点 HTTPS 化之后，我们就可以让 Google 及 Baidu 收录我们的站点了。</p><h4 id="验证站点是否被收录"><a href="#验证站点是否被收录" class="headerlink" title="验证站点是否被收录"></a><strong>验证站点是否被收录</strong></h4><p><strong>Google 验证</strong>：Google 搜索 <code>site:www.oneonecity.xyz</code>，域名换成你自己的，如果没有找到你的博客说明没有被收录！<br><strong>Baidu 验证</strong>：Baidu 搜索 <code>site:www.oneonecity.xyz</code>，同 Google。</p><h4 id="生成Sitemap站点地图"><a href="#生成Sitemap站点地图" class="headerlink" title="生成Sitemap站点地图"></a><strong>生成Sitemap站点地图</strong></h4><p>Sitemap 的主要目的，是避免搜索引擎没有完整的收录整个网页的内容，提交 Sitemap 能够补足搜索引擎的不足，进而加速网页的收录速度，达到搜寻引擎友好的目的。<strong>注意path前面是二个空格缩进</strong>。</p><p>安装 Sitemap 插件，对于国内用户还需要安装 hexo-generator-baidu-sitemap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></p><p>修改站点配置文件中的 URL 为你博客首页，这样是为了保证生成的 sitemap.xml 文件中地址正确：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: https://www.oneonecity.xyz</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><p>在站点配置文件中添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>执行 <code>hexo g</code>，正常情况下会在站点根目录的 public 文件夹下看到两个文件：sitemap.xml 和 baidusitemap.xml；执行 <code>hexo d</code>，输入正确的域名路径，还可访问 sitemap.xml 和 baidusitemap.xml。</p><h4 id="Google收录（未验证）"><a href="#Google收录（未验证）" class="headerlink" title="Google收录（未验证）"></a><strong>Google收录（未验证）</strong></h4><p>进入 <a href="https://www.google.com/webmasters/" target="_blank" rel="noopener">Google Search Console</a>，必须有 Google 账号才能添加站点，没有的话注册一个。</p><p><img src="Google%20Search%20Console.png" alt="Google Search Console"></p><p>点添加属性，把自己的域名输入进去即可，然后 Google 会验证你对网站的所有权，验证方式同百度，我们下文再说。</p><p>验证完成之后，还需要向 Google 提交站点地图。点击控制台–&gt;抓取–&gt;站点地图，点击右上角 <code>添加/测试站点地图</code> 按钮，将你的 sitemap.xml 提交测试，测试成功之后重复该步骤进行添加！</p><p><img src="Google-sitemap.png" alt="Google-sitemap"></p><p>点击控制台–&gt;抓取–&gt;Google 抓取工具，在这里填上需要抓取的 URL，不填的话默认抓取首页，抓取类型分为桌面，智能手机两种，自行根据需要选择。填好 URL 之后，点击抓取，提交至索引，根据提示操作就可以了。</p><h4 id="Baidu收录"><a href="#Baidu收录" class="headerlink" title="Baidu收录"></a><strong>Baidu收录</strong></h4><p>百度提交网址入口：<a href="https://ziyuan.baidu.com/site/siteadd" target="_blank" rel="noopener">站点管理-添加网站</a>。</p><p>在添加网站之后，百度会验证你对网站的所有权，通过验证之后百度会认为你是网站的所有者，然后就能做诸如自动推送、手动推送的高级功能！想要提交 baidusitemap.xml 给百度，通过网站验证是必不可少的一部分。</p><p>百度提供了三种验证方式：文件验证、HTML 标签验证和 CNAME 验证。HTML 标签验证最为麻烦，不在这里赘述，CNAME 是最简单的验证方式，但是博主按照网上教程所述的方式一直未能验证成功，最后使用的是文件验证方式。</p><p><strong>1. 文件验证</strong></p><p><img src="%E7%99%BE%E5%BA%A6%E6%96%87%E4%BB%B6%E9%AA%8C%E8%AF%81.png" alt="百度文件验证"></p><p>如图所示，下载验证文件，其是一个 HTML 文件，里面存放着你的 token 信息！然后将这个文件放在站点根目录的 source 文件夹下，并在站点配置文件中配置如下项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 跳过指定文件的渲染</span><br><span class="line">skip_render: [caprice/**,your_baidu_verify.html]</span><br></pre></td></tr></table></figure><p>编译并部署你的博客：<code>hexo d -g</code>，完成验证。</p><p><strong>2. CNAME验证（未成功）</strong></p><p>如果你绑定了自己的域名，这种方式是最简单的！如图添加一条新的 CNAME 解析：记录类型是 CNAME，主机记录是你的 token，记录值是 <code>zz.baidu.com</code>，其他默认：</p><p><img src="%E7%99%BE%E5%BA%A6CNAME%E9%AA%8C%E8%AF%81.png" alt="百度CNAME验证"></p><p>点击完成验证即可。</p><p>完成验证之后，就可以在数据引入–&gt;链接提交页面下的自动提交中提交 baidusitemap.xml 文件。</p><p>接下来就等待被 Google 和 Baidu 收录吧。</p><h3 id="使用CDN加速博客访问速度"><a href="#使用CDN加速博客访问速度" class="headerlink" title="使用CDN加速博客访问速度"></a><strong>使用CDN加速博客访问速度</strong></h3><p><strong>想要使用 CDN 加速服务的域名必须先完成中国大陆的备案！</strong><br><strong>想要使用 CDN 加速服务的域名必须先完成中国大陆的备案！</strong><br><strong>想要使用 CDN 加速服务的域名必须先完成中国大陆的备案！</strong></p><p>很可惜，博主的 .name 目前并不在工信部可支持备案的域名后缀白名单中！因此强烈建议大家在选择域名的时候尽量购买常用域名，如：.com、.cn 等，如果实在想要突出个性，.info 以及 .zone 都是不错的选择~</p><p>翻阅网络上大多数 CDN 加速网站访问速度的教程，发现大多数都建议将对象存储服务以及 CDN 加速服务搭配使用…博主对 CDN 还算进行过比较深入的学习，在看到这个建议后非常疑惑，加速 Hexo 这种小型静态网站的访问速度只使用 CDN 服务应该能够完全满足需求，何必要上对象存储服务？</p><p>抱着这样的疑惑，博主对对象存储进行了简单的了解，发现对象存储的功能就是存储一些静态资源，并不会提高整个网站的访问速度。对象存储服务应该是提供给那些拥有大量如图片、视频等这种耗费硬盘空间的静态资源并且整个网站的构建、部署是在自家服务器上的应用，而我们的博客已经托管给 GitPage，完全不用担心图片、视频等静态资源会占用大量的硬盘空间。因此博主断定，想要加速网站的访问速度，只使用 CDN 服务即可。</p><p>我的域名是在腾讯云上买的，腾讯云同样提供 CDN 服务，其他云服务厂商情况应该大致相同，除此之外，七牛云提供的 CDN 服务好像也很不错。</p><p>CDN 服务的相关配置非常简单，这里我就不再赘述了，网络上教程很多，大家可以自行寻找。</p><h3 id="博客的备份与迁移"><a href="#博客的备份与迁移" class="headerlink" title="博客的备份与迁移"></a><strong>博客的备份与迁移</strong></h3><p>本来打算将 Hexo 博客迁移至公司电脑上，以便在公司电脑上所写的文章也可以直接发布至个人博客中，但在考虑下述因素后，放弃了这个想法：</p><p>在办公电脑上存在两个 GitHub 账号也不是不行，但是经常听闻某公司某某实习生将公司代码上传至个人 GitHub 的仓库中，综合公司财产安全以及个人职业生涯发展方面的考虑，遂决定还是将办公电脑与个人电脑的使用分离开来（主要还是对 GitHub 的使用不是很熟悉，所以不敢乱搞，哈哈哈~）。</p><p>不过这并不影响你在办公电脑上写一些很棒的文章，然后通过你的个人电脑发布至 Hexo 博客上，因为我们有一个很棒的多人协作、实时同步的 markdown 编辑软件：<a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Cmd Markdown</a>。</p><p>即使如此，对 Hexo 博客进行备份仍旧非常有必要。你的个人电脑终究有淘汰的一天，此时就必须将 Hexo 博客迁移至新电脑中，而对博客进行备份乃是能够成功迁移的第一步。</p><p><code>hexo g</code> 命令是根据 _config.yml，source 目录文件以及 themes 目录下文件生成博客文件的。因此，我们需要备份的文件如下：</p><table><thead><tr><th>文件（夹）</th><th>说明</th></tr></thead><tbody><tr><td>scaffolds/</td><td>博客文章模板</td></tr><tr><td>source/</td><td>所有的博客文章</td></tr><tr><td>themes/</td><td>网站主题</td></tr><tr><td>.gitignore</td><td>push时需忽略的文件</td></tr><tr><td>_config.yml</td><td>站点配置文件</td></tr><tr><td>package.json</td><td>依赖包的名称和版本号</td></tr></tbody></table><p>.gitignore 文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a><strong>备份</strong></h4><p>由于配置文件和主题文件需要经常更改，采用 GitHub 创建博客分支的方式进行备份。</p><p>克隆 GitHub 上生成的静态文件到你的备份文件夹中：<code>git clone https://github.com/yourname/xxxx.github.io.git</code></p><p>克隆后将除 .git 文件外其他所有文件删除，目的是为了得到版本管理文件夹 .git。.git 文件为隐藏文件，可直接将可见文件全部删除。</p><p>将需要备份的原文件复制到此文件夹，若文件夹是按照上述方式从 GitHub 克隆的，则需要删除主题文件中的版本控制文件夹，以 next 主题为例：<code>rm -rf themes/next/.git*</code>。</p><p>创建名为 backups 的分支：<code>git checkout -b backups</code>，保存所有文件到暂存区：<code>git add .</code>，提交变更：<code>git commit -m &quot;hexo-backups&quot;</code>，提交变更时如果出错，根据相关提示配置即可，最后推送分支到 GitHub，并用 –set-upstream 与 origin 创建关联：<code>git push --set-upstream origin backups</code>。</p><h4 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a><strong>迁移</strong></h4><p>这一部分并未进行实践，因此正确性有待考证，等真正有迁移需要的时候，再对其进行补充或完善~</p><p>在新电脑上建立 blog 文件夹，拉下远程仓库文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 先要安装Git、Node.js环境</span><br><span class="line">git init</span><br><span class="line">git clone origin backups git@github.com:yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:yourname/yourname.github.io.git</span><br><span class="line">git checkout -b backups</span><br><span class="line">git pull origin backups</span><br></pre></td></tr></table></figure><p>重新安装 Hexo 所需组件：<code>npm install</code>。</p><p>然后写文章，部署博客，同时更新 backups 分支（以后必做的一件事，需要保证备份分支处于最新状态）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 新建一个.md文件，并编辑完成自己的博客内容</span><br><span class="line">hexo new post &quot;new blog name&quot;</span><br><span class="line"></span><br><span class="line">hexo d -g</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;UPDATE Blog Source backups&quot;</span><br><span class="line">git push origin backups  # 更新backups分支</span><br></pre></td></tr></table></figure><p>在不同的终端做完以上第一次配置后，以后只需执行以下命令进行更新即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 先pull完成本地与远端的融合</span><br><span class="line">git pull origin backups</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;xx&quot;</span><br><span class="line">git push origin backups</span><br><span class="line"></span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="https://theme-next.org/docs/third-party-services/comments-and-widgets" target="_blank" rel="noopener">NexT-Comments and Widgets</a></p><p><a href="http://saili.science/2017/04/02/github-for-win/" target="_blank" rel="noopener">Git Pages使用指南</a></p><p><a href="https://www.bluelzy.com/articles/change_to_next_theme.html" target="_blank" rel="noopener">弃暗投明-Hexo更换next主题</a></p><p><a href="https://fl4g.cn/2018/08/03/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/" target="_blank" rel="noopener">Hexo博客迁移到其他电脑</a></p><p><a href="https://www.itfanr.cc/2019/04/30/hexo-add-gitalk-comment/" target="_blank" rel="noopener">Hexo博客添加Gitalk评论系统</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Geek" scheme="https://blog.dhengyi.name/categories/Geek/"/>
    
    
      <category term="NexT" scheme="https://blog.dhengyi.name/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Java并发--原子变量类的使用</title>
    <link href="https://blog.dhengyi.name/2018/10/03/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.dhengyi.name/2018/10/03/Java并发-原子变量类的使用/</id>
    <published>2018-10-03T05:51:16.000Z</published>
    <updated>2019-07-13T15:02:03.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>注</strong>：本篇博客主要内容来源于网络，侵删~</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>我们假设你已经熟练掌握了CAS，原子变量类等的相关概念。这篇博客中，我们主要讨论原子变量类的使用。</p><hr><h2 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a><strong>原子变量类</strong></h2><p>原子变量类共12个，分4组：</p><ol><li>计数器：<code>AtomicInteger</code>，<code>AtomicLong</code>，<code>AtomicBoolean</code>，<code>AtomicReference</code>。</li><li>域更新器：<code>AtomicIntegerFieldUpdater</code>，<code>AtomicLongFieldUpdater</code>，<code>AtomicReferenceFieldUpdater</code>。</li><li>数组：<code>AtomicIntegerArray</code>，<code>AtomicLongArray</code>，<code>AtomicReferenceArray</code>。</li><li>复合变量：<code>AtomicMarkableReference</code>，<code>AtomicStampedReference</code>。</li></ol><p>在每组中我会选择其中一个较有代表性的进行分析与举例。</p><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a><strong>AtomicReference</strong></h3><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a><strong>使用说明</strong></h4><p>AtomicReference的作用是对”对象”进行原子操作。</p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReference</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1848883965231344442L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取Unsafe对象，Unsafe的作用是提供CAS操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取相应字段相对Java对象的“起始地址”的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicReference.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// volatile类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">(V initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedObject(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(V expect, V update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getAndSet</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            V x = get();</span><br><span class="line">            <span class="keyword">if</span> (compareAndSet(x, newValue))</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于上述代码只有两点需要强调：</p><ol><li><code>valueOffset = unsafe.objectFieldOffset(AtomicReference.class.getDeclaredField(&quot;value&quot;))</code> 通过相关字段的偏移量获取值比直接使用反射获取相应字段的值性能要好许多；</li><li>关于lazySet，推荐阅读这一篇博客：<a href="http://ifeve.com/juc-atomic-class-lazyset-que/" target="_blank" rel="noopener">JUC中Atomic Class之lazySet的一点疑惑</a>。</li></ol><h4 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a><strong>使用举例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"id:"</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个Person对象，它们的id分别是101和102。</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="number">101</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="number">102</span>);</span><br><span class="line">        <span class="comment">// 新建AtomicReference对象，初始化它的值为p1对象</span></span><br><span class="line">        AtomicReference ar = <span class="keyword">new</span> AtomicReference(p1);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。</span></span><br><span class="line">        ar.compareAndSet(p1, p2);</span><br><span class="line"> </span><br><span class="line">        Person p3 = (Person)ar.get();</span><br><span class="line">        System.out.println(<span class="string">"p3 is "</span>+p3);</span><br><span class="line">        System.out.println(<span class="string">"p3.equals(p1)="</span>+p3.equals(p1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a><strong>AtomicReferenceFieldUpdater</strong></h3><p>接下来所有的原子变量类不再进行源码分析。事实上所有原子变量类的实现都大同小异，感兴趣的同学可以阅读源码。</p><h4 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a><strong>使用说明</strong></h4><p>一个基于反射的工具类，它能对指定类的指定的volatile引用字段进行原子更新。(注意这个字段不能是private的) </p><p>通过调用AtomicReferenceFieldUpdater的静态方法newUpdater就能创建它的实例，该方法要接收三个参数： </p><ol><li>包含该字段的对象的类;</li><li>将被更新的对象的类;</li><li>将被更新的字段的名称。</li></ol><h4 id="使用举例-1"><a href="#使用举例-1" class="headerlink" title="使用举例"></a><strong>使用举例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">volatile</span> String name = <span class="string">"dog1"</span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Dog.class, String.class, <span class="string">"name"</span>);</span><br><span class="line">        Dog dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line">        updater.compareAndSet(dog1, dog1.name, <span class="string">"test"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(dog1.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicReferenceArray"><a href="#AtomicReferenceArray" class="headerlink" title="AtomicReferenceArray"></a><strong>AtomicReferenceArray</strong></h3><h4 id="使用说明-2"><a href="#使用说明-2" class="headerlink" title="使用说明"></a><strong>使用说明</strong></h4><p>可以用原子方式更新其元素的对象引用数组。</p><p>以下是AtomicReferenceArray类中可用的重要方法的列表：</p><table><thead><tr><th>序列</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public AtomicReferenceArray(int length)</td><td>构造函数，创建给定长度的新 AtomicReferenceArray。</td></tr><tr><td>2</td><td>public AtomicReferenceArray(E[] array)</td><td>构造函数，创建与给定数组具有相同长度的新 AtomicReferenceArray，并从给定数组复制其所有元素。</td></tr><tr><td>3</td><td>public boolean compareAndSet(int i, E expect, E update)</td><td>如果当前值==期望值，则将位置i处的元素原子设置为给定的更新值。</td></tr><tr><td>4</td><td>public E get(int i)</td><td>获取位置i的当前值。</td></tr><tr><td>5</td><td>public E getAndSet(int i, E newValue)</td><td>将位置i处的元素原子设置为给定值，并返回旧值。</td></tr><tr><td>6</td><td>public void set(int i, E newValue)</td><td>将位置i处的元素设置为给定值。</td></tr></tbody></table><h4 id="使用举例-2"><a href="#使用举例-2" class="headerlink" title="使用举例"></a><strong>使用举例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子引用数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] source = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReferenceArray&lt;String&gt; atomicReferenceArray = <span class="keyword">new</span> AtomicReferenceArray&lt;String&gt;(source);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; atomicReferenceArray.length(); i++) &#123;</span><br><span class="line">            atomicReferenceArray.set(i, <span class="string">"item-2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Increment());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Compare());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Increment</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; atomicReferenceArray.length(); i++) &#123;</span><br><span class="line">                String add = atomicReferenceArray.getAndSet(i, <span class="string">"item-"</span> + (i+<span class="number">1</span>));</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() </span><br><span class="line">                    + <span class="string">", index "</span> + i + <span class="string">", value: "</span> + add);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; atomicReferenceArray.length(); i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() </span><br><span class="line">                    + <span class="string">", index "</span> + i + <span class="string">", value: "</span> + atomicReferenceArray.get(i));</span><br><span class="line">                <span class="keyword">boolean</span> swapped = atomicReferenceArray.compareAndSet(i, <span class="string">"item-2"</span>, <span class="string">"updated-item-2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"Item swapped: "</span> + swapped);</span><br><span class="line">                <span class="keyword">if</span>(swapped) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() </span><br><span class="line">                        + <span class="string">", index "</span> + i + <span class="string">", updated-item-2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><h4 id="使用说明-3"><a href="#使用说明-3" class="headerlink" title="使用说明"></a><strong>使用说明</strong></h4><p>AtomicStampedReference主要用来解决在使用CAS算法的过程中，可能会产生的<strong>ABA问题</strong>。一般我们会使用带有版本戳version的记录或对象标记来解决ABA问题，AtomicStampedReference<e>实现了这个作用，它通过包装[E, Integer]的元组来对对象标记版本戳stamp。</e></p><p>以下是AtomicStampedReference类中可用的重要方法的列表：</p><table><thead><tr><th>序列</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>public AtomicStampedReference(V initialRef, int initialStamp)</td><td>构造方法，传入引用和戳。</td></tr><tr><td>2</td><td>public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)</td><td>如果当前引用 == 预期值并且当前版本戳 == 预期版本戳，将更新新的引用和新的版本戳到内存。</td></tr><tr><td>3</td><td>public void set(V newReference, int newStamp)</td><td>设置当前引用的新引用和版本戳。</td></tr><tr><td>4</td><td>public boolean attemptStamp(V expectedReference, int newStamp)</td><td>如果当前引用 == 预期引用，将更新新的版本戳到内存。</td></tr></tbody></table><h4 id="使用举例-3"><a href="#使用举例-3" class="headerlink" title="使用举例"></a><strong>使用举例</strong></h4><p>下面的代码分别用AtomicInteger和AtomicStampedReference来对初始值为100的原子整型变量进行更新，AtomicInteger会成功执行CAS操作，而加上版本戳的AtomicStampedReference对于ABA问题会执行CAS失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInt = <span class="keyword">new</span> AtomicInteger(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference atomicStampedRef = <span class="keyword">new</span> AtomicStampedReference(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread intT1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                atomicInt.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">                atomicInt.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread intT2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> c3 = atomicInt.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">                System.out.println(c3);         <span class="comment">// true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        intT1.start();</span><br><span class="line">        intT2.start();</span><br><span class="line">        intT1.join();</span><br><span class="line">        intT2.join();</span><br><span class="line"></span><br><span class="line">        Thread refT1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                atomicStampedRef.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">                atomicStampedRef.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread refT2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> stamp = atomicStampedRef.getStamp();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> c3 = atomicStampedRef.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">                System.out.println(c3);         <span class="comment">// false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        refT1.start();</span><br><span class="line">        refT2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="性能比较：锁与原子变量"><a href="#性能比较：锁与原子变量" class="headerlink" title="性能比较：锁与原子变量"></a><strong>性能比较：锁与原子变量</strong></h2><p>事实上，CAS的性能总是优于锁。我们分两种情况进行讨论。</p><p><strong>1. 线程间竞争程度较高</strong></p><p>对于锁来说，激烈的竞争意味着线程频繁的挂起与恢复，频繁的上下文切换，这些操作都是非常耗费系统资源的；对于CAS算法来说，激烈的竞争意味着线程将对竞争进行频繁的处理（重试，回退，放弃等策略）。</p><p>即使如此，一般来说，CAS算法的性能依旧优于锁。</p><p><strong>2. 线程间竞争程度较低</strong></p><p>较低的竞争程度意味着CAS操作总是能够成功；对于锁来说，虽然锁之间的竞争度也随之下降，但由于获取锁与释放锁的操作不但耗费系统资源，并且其中本身就包含着CAS操作，因此在这种情况下，CAS操作的性能依旧优于锁。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>这篇博客并没有讲述CAS操作以及可能产生的ABA问题，但是我们必须熟悉这两个知识点；</li><li>这篇博客的主要目的是构建起大家对原子变量类的一个认识，以至于在以后的项目开发中，可以去思考如何使用这些原子变量类；</li><li>对于原子变量与锁之间的优势与劣势，性能间的比较，有一个较为清晰的认识。</li></ol><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>Java并发编程实战</p><p><a href="https://www.yiibai.com/java_concurrency/concurrency_atomicreferencearray.html" target="_blank" rel="noopener">Java并发AtomicReferenceArray类</a></p><p><a href="https://www.cnblogs.com/java20130722/p/3206742.html" target="_blank" rel="noopener">用AtomicStampedReference解决ABA问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java并发" scheme="https://blog.dhengyi.name/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.dhengyi.name/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="原子变量类" scheme="https://blog.dhengyi.name/tags/%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java并发--深入理解显式锁</title>
    <link href="https://blog.dhengyi.name/2018/09/27/Java%E5%B9%B6%E5%8F%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%98%BE%E5%BC%8F%E9%94%81/"/>
    <id>https://blog.dhengyi.name/2018/09/27/Java并发-深入理解显式锁/</id>
    <published>2018-09-27T07:46:50.000Z</published>
    <updated>2019-07-13T15:39:15.312Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>注</strong>：本篇博客部分内容引用自：<a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java并发编程：Lock</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>在Java 5.0之前，协调对共享对象的访问可以使用到的机制只有synchronized和volatile。在Java 5.0之后，增加了一种新的机制：ReentrantLock。ReentrantLock并不是一种替代内置锁的方法，而是在内置锁不再适用的情况下，作为一种可选择的高级功能。</p><hr><h2 id="既生synchronized，何生Lock"><a href="#既生synchronized，何生Lock" class="headerlink" title="既生synchronized，何生Lock"></a><strong>既生synchronized，何生Lock</strong></h2><p>synchronized主要在功能上存在一些局限性。</p><p>如果获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p><p>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。</p><p>如果采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，那么当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。</p><p>另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p><p>值得注意的是：<strong>在使用Lock时，我们必须在finally块中释放锁！</strong></p><p>如果在被保护的代码块中抛出了异常，那么这个锁永远都无法被释放。如果没有使用finally来释放锁，当出现问题时，将很难追踪到最初发生错误的位置，因为我们没有记录应该释放锁的位置与时间。</p><p><strong>这就是ReentrantLock不能完全替代synchronized的原因：它更加危险，因为当程序的执行控制离开被保护的代码块时，不会自动清除锁。</strong></p><p><strong>注</strong>：FindBugs可以帮助你找到未释放的锁。</p><h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a><strong>Lock接口</strong></h2><h3 id="认识Lock"><a href="#认识Lock" class="headerlink" title="认识Lock"></a><strong>认识Lock</strong></h3><p>我们先来看一下Lock接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 可中断的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 轮询锁与定时锁</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 本节并不需要关注</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReentrantLock是唯一实现了Lock接口的类</strong>。在获取（释放）ReentrantLock时，有着与进入（退出）同步代码块相同的内存语义，与synchronized一样，ReentrantLock还提供了<strong>可重入</strong>的加锁语义。</p><h3 id="tryLock方法"><a href="#tryLock方法" class="headerlink" title="tryLock方法"></a><strong>tryLock方法</strong></h3><p>tryLock只有在成功获取了锁的情况下才会返回true，如果别的线程当前正持有锁，则会立即返回false！如果为这个方法加上timeout参数，则会等待timeout的时间才会返回false或者在获取到锁的时候返回true。</p><p>在内置锁中，死锁是一个严重的问题，恢复程序的唯一方法是重启程序，而防止死锁的唯一方法就是在构造程序时避免出现不一致的锁顺序。可定时与可轮询的锁提供了另一种方式：避免死锁的发生。</p><p>如果不能获取所有需要的锁，那么可以使用可定时或可轮询的锁获取方式，从而使你重新获得控制权，它会释放已经获得的锁，然后重新尝试获取所有锁。无参数的tryLock一般用作轮询锁，而带有TimeUnit参数的一般用作定时锁。</p><p>考虑如下程序，它将资金从一个账户转入另一个账户。在开始转账之前，首先要获得这两个Account对象的锁，以确保通过原子方式来更新两个账户中的余额，同时又不破坏一些不变性条件，如：“账户的余额不能为负数”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(Account fromAccount, Account toAccount, DollarAmount amount)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InsufficientResourcesException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (fromAccount) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAccount) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span>  <span class="keyword">new</span> InsufficientResourcesException();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fromAccount.debit(amount);</span><br><span class="line">                toAccount.credit(amount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序看似无害，实则会发生死锁。如果两个线程同时调用transferMoney，其中一个线程从X向Y转账，另一个线程从Y向X转账，那么就会发生死锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: transferMoney(myAccount, yourAccount, 10);</span><br><span class="line">B: transferMoney(yourAccount, myAccount, 20);</span><br></pre></td></tr></table></figure><p>如果执行顺序不当，那么A可能获得myAccount的锁并等待yourAccount的锁，然而B此时持有yourAccount的锁并等待myAccount的锁，就会发生死锁。</p><p>我们可以使用tryLock用作轮询锁来解决这样的问题，使用tryLock来获取两个锁，如果不能同时获得，则退回并重新尝试。程序中锁获取的休眠时间包括固定部分和随机部分，从而降低了发生<a href="https://baike.baidu.com/item/%E6%B4%BB%E9%94%81/5096375" target="_blank" rel="noopener">活锁</a>的可能性。如果在指定时间内不能获得所有需要的锁，那么transferMoney将返回一个失败状态，从而使该操作平缓的失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">transferMoney</span><span class="params">(Account fromAcct, Account toAcct, DollarAmount amount, <span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit)</span> <span class="keyword">throws</span> InsufficientResourcesException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> fixedDelay = getFixedDelayComponentNanos(timeout, unit);</span><br><span class="line">    <span class="keyword">long</span> randMod = getRandomDelayModulusNanos(timeout, unit);</span><br><span class="line">    <span class="keyword">long</span> stopTime = System.nanoTime() + unit.toNanos(timeout);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromAcct.lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (toAcct.lock.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fromAccount.getBalance().compareTo(amount) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientResourcesException();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            fromAccount.debit(amount);</span><br><span class="line">                            toAccount.credit(amount);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        toAcct.lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                fromAcct.lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (System.nanoTime() &lt; stopTime) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryLock用作定时锁的程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trySendOnSharedLine</span><span class="params">(String message, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanosToLock = unit.toNanos(timeout) - estimatedNanosToSend(message);</span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock(nanosToLock, NANOSECONDS)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> trySendOnSharedLine(message);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序试图在Lock保护的共享通信线路上发送一条消息，如果不能在指定的时间内完成，代码就会失败。定时的tryLock能够在这种带有时间限制的操作中实现独占加锁的行为。</p><h3 id="lockInterruptibly方法"><a href="#lockInterruptibly方法" class="headerlink" title="lockInterruptibly方法"></a><strong>lockInterruptibly方法</strong></h3><p>lockInterruptibly方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</p><p>由于在lockInterruptibly方法的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly的方法外声明抛出InterruptedException。</p><p>因此lockInterruptibly一般的使用形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">// .....</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，当一个线程获取了锁之后，是不会被interrupt方法中断的。因为单独调用interrupt方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过lockInterruptibly方法获取某个锁时，如果不能获取到，只有在进行等待的情况下，是可以响应中断的。</p><p>定时的tryLock同样能够响应中断，因此当需要实现一个定时的和可中断的锁获取操作时，可以使用tryLock方法。</p><hr><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a><strong>公平锁</strong></h2><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁，这种就是公平锁。</p><p>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p><p>在ReentrantLock中定义了2个静态内部类，一个是NotFairSync，一个是FairSync，分别用来实现非公平锁和公平锁。我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p><pre><code>ReentrantLock lock = new ReentrantLock(true);</code></pre><p>参数为true表示为公平锁，为fasle为非公平锁。默认情况下，如果使用无参构造器，则是非公平锁。</p><p>另外在ReentrantLock类中定义了很多方法，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isFair()            <span class="comment">//判断锁是否是公平锁</span></span><br><span class="line"></span><br><span class="line">isLocked()          <span class="comment">//判断锁是否被任何线程获取了</span></span><br><span class="line"></span><br><span class="line">isHeldByCurrentThread()     <span class="comment">//判断锁是否被当前线程获取了</span></span><br><span class="line"></span><br><span class="line">hasQueuedThreads()          <span class="comment">//判断是否有线程在等待该锁</span></span><br></pre></td></tr></table></figure><p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p><hr><h2 id="在synchronized与ReentrantLock之间进行抉择"><a href="#在synchronized与ReentrantLock之间进行抉择" class="headerlink" title="在synchronized与ReentrantLock之间进行抉择"></a><strong>在synchronized与ReentrantLock之间进行抉择</strong></h2><p>在性能上，Java 5.0中ReentrantLock远远优于内置锁，而在Java 6.0中则是略有胜出。</p><p>我们建议，仅当内置锁不能满足需求时，才可以考虑使用ReentrantLock。</p><p>在Java 8.0中，内置锁的性能已经不压于ReentrantLock，并且未来更可能会继续提升synchronized的性能，毕竟synchronized是JVM的内置属性。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>清楚为什么有Lock接口；</li><li>清楚使用ReentrantLock有什么优缺点；</li><li>掌握如何使用ReentrantLock（定时锁，轮询锁，中断锁以及一些其他功能）；</li><li>能够在synchronized与Lock中做出选择。</li></ol><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>Java并发编程实战</p><p><a href="http://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">Java并发编程：Lock</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java并发" scheme="https://blog.dhengyi.name/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.dhengyi.name/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="显式锁" scheme="https://blog.dhengyi.name/tags/%E6%98%BE%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java并发--深入理解线程池</title>
    <link href="https://blog.dhengyi.name/2018/09/13/Java%E5%B9%B6%E5%8F%91-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://blog.dhengyi.name/2018/09/13/Java并发-深入理解线程池/</id>
    <published>2018-09-13T13:38:05.000Z</published>
    <updated>2019-07-13T15:38:58.986Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a><strong>为什么需要线程池</strong></h2><p>在生产环境中，我们不能无限制的创建线程，主要原因如下：</p><ol><li>线程创建与销毁的代价并不低；</li><li>如果可运行的线程数量多于可用处理器的数量，有些线程将会闲置，大量闲置的线程会消耗系统资源（内存）并给垃圾收集器带来压力；</li><li>大量线程竞争CPU也会造成不小的性能开销。</li></ol><hr><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a><strong>Executor框架</strong></h2><p>Executor框架在Java 5中被引入，其内部使用了线程池机制。它在java.util.cocurrent包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。</p><p>Executor框架包括：线程池，Executor，Executors，ExecutorService等（Callable与Future本篇不进行讨论）。</p><h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a><strong>Executor接口</strong></h3><p>我们先来了解一下其中的Executor接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor接口的定义非常简单，但它却为灵活且强大的异步任务执行框架提供了能够支持多种不同类型任务的执行策略。它提供一种标准的方法将任务的提交过程与执行过程进行了解耦。</p><p>Executor接口基于生产者 — 消费者模型，提交任务的操作相当与生产者，执行任务的线程相当于消费者。</p><p>线程池的实现操作了Executor接口，但现在，我们只关心它是如何将任务提交与任务执行进行解耦的。来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/4 23:29</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskExecutionWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 任务创建</span></span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务提交与执行</span></span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述代码进行修改，将任务的执行改为为每个任务都创建新的线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/5 9:37</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以对其进行修改，使TaskExecutionWebServer的行为类似于单线程的行为，即以同步的方式执行每个任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/5 9:43</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithinThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        command.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用Executor，我们将任务的提交与执行进行了解耦，我们只需采用另一种不同的Executor实现，就完全可以改变应用程序的行为。改变Executor实现或配置所带来的影响要远远小于改变任务提交方式带来的影响。</p><h3 id="Executor的生命周期—ExecutorService接口"><a href="#Executor的生命周期—ExecutorService接口" class="headerlink" title="Executor的生命周期—ExecutorService接口"></a><strong>Executor的生命周期—ExecutorService接口</strong></h3><p>我们已经知道了如何创建一个Executor，但JVM只有在所有非守护线程全部终止后才会退出，因此我们还需讨论一下Executor如何关闭。</p><p>关闭应用程序的方式我们通常分为两种：</p><ol><li>平缓的关闭：完成所有已启动的任务，拒绝接受新任务。</li><li>粗暴的关闭：直接取消所有任务，拒绝接受新任务。</li></ol><p>为了便于管理执行服务的生命周期，Executor扩展了ExecutorService接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 平缓的关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 粗暴的关闭</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 等待终止，通常在调用此方法后会立即调用shutdown，从而产生同步关闭ExecutorService的效果</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... ... 其他用于任务提交的便利方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecutorService的生命周期有三种状态：运行，关闭，终止。</p><p>创建ExecutorService时处于运行态（RUNNING）。我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，在调用这两个方法之一后，线程池将不再接收新任务。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭，且任务缓存队列已经清空或执行结束后才表示线程池关闭成功，进入终止态（TERMINATED），这时调用isTerminaed方法会返回true。</p><h3 id="线程池的创建—Executors"><a href="#线程池的创建—Executors" class="headerlink" title="线程池的创建—Executors"></a><strong>线程池的创建—Executors</strong></h3><p>关于线程池的优势不再多说。我们可以通过Executors中的静态工厂方法创建一个线程池：</p><ol><li><strong>newFixedThreadPool</strong>：创建固定大小的线程池，每当提交一个任务就创建一个线程，直到达到线程池最大数量，如果某个线程发生了Exception异常，线程池会补充一个新线程；</li><li><strong>newCachedThreadPool</strong>：可缓存线程池，如果线程池中有空闲的线程，那么将会回收空闲线程，当任务数量增加时，则添加新的线程，线程池的规模不受限制；</li><li><strong>newSingleThreadExecutor</strong>：单线程Executor，如果此线程出现异常，会创建另一个线程进行替代。它会确保依照任务在队列中的顺序来串行执行；</li><li><strong>newScheduledThreadPool</strong>：创建固定大小线程池并以延迟或定时的方式来执行任务。</li></ol><hr><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a><strong>线程池的使用</strong></h2><h3 id="认识ThreadPoolExecutor"><a href="#认识ThreadPoolExecutor" class="headerlink" title="认识ThreadPoolExecutor"></a><strong>认识ThreadPoolExecutor</strong></h3><p>如果Executors提供默认的静态工厂方法创建的线程池不能满足需求，我们可以通过ThreadPoolExecutor的构造函数实例化一个对象，根据自己的需求定制相应线程池，ThreadPoolExecutor定义了许多构造函数，我们给出最常见的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实通过源码我们可以知道：ThreadPoolExecutor继承了类AbstractExecutorService，抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法，ExecutorService接口继承了Executor接口，因此ThreadPoolExecutor也基于Executor接口。</p><p>我们分模块对上述参数进行描述。</p><h3 id="线程的创建与销毁"><a href="#线程的创建与销毁" class="headerlink" title="线程的创建与销毁"></a><strong>线程的创建与销毁</strong></h3><p>corePoolSize（基本大小），maximumPoolSize（最大大小），keepAliveTime（存活时间）等因素共同负责线程的创建与销毁。</p><p><strong>基本大小</strong>：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。只有在工作队列满时才会创建超出这个数量的线程；<br><strong>最大大小</strong>：线程池中可同时活动的线程数量的上限。若某个线程的空闲时间超过存活时间，则此线程被标记为可回收，并当线程池当前大小超过基本大小时，此线程将被终止。</p><p>newFixedThreadPool工厂方法将线程池的基本大小与最大大小设置为参数中指定的值并且两者相等，且创建的线程池不会超时；newCachedThreadPool工厂方法将线程池的最大大小设为Integer.MAX_VALUE，而将基本大小设置为0，超时设置为1分钟。其他形式的线程池可以通过显式的ThreadPoolExecutor构造函数进行构造。</p><p><strong>注</strong>：在将基本大小设置为0之后，有一些值得注意的事项。只有当线程池中的线程数量等于线程池的基本大小并且工作队列已满的情况下，ThreadPoolExecutor才会创建新的线程。因此，如果线程池的基本大小为0，但工作队列还有容量，那么把任务交给线程池时，只有当线程池的工作队列被填满之后，才会执行任务。这通常不是我们所期望的。（将基本大小设置为0的主要目的为当没有任务执行时，销毁工作线程以免阻碍JVM的退出）</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a><strong>任务队列</strong></h3><p>当任务到达线程池的速率超过了线程池的处理速率，那么新到来的任务将会累积起来，我们在线程池中使用一个由Executor管理的Runnable队列来保存等待执行的任务。使用任务队列的好处在于降低了这些任务对CPU资源的竞争，任务队列可以缓解任务的突增问题，但如果任务持续高速的到来，依旧可能耗尽内存资源（阻塞队列没有边界）。</p><p>任务队列分为三种：有界队列，无界队列，同步移交。</p><p>newFixedThreadPool和newSingleThreadExecutor在默认情况下都使用无界队列：LinkedBlockingQueue。</p><p>我们建议使用有界队列，例如：ArrayBlockingQueue，有界的LinkedBlockingQueue，PriorityBlockingQueue。有界队列有助于避免资源的耗尽。</p><p>在newCachedThreadPool中则使用了SynchronousQueue（Java 5，在Java 6中提供了一个新的非阻塞算法来替代了SynchronousQueue）。SynchronousQueue并不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入SynchronousQueue中，必须要有另一个线程正在等待接收这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，则ThreadPoolExecutor将创建一个新的线程，否则将拒绝这个任务。只有当线程池是无界的或是可以拒绝任务时，SynchronousQueue才具有实际价值。使用这种方式的优势很明显：任务会直接移交给执行它的线程，而不是被首先放在队列中。</p><p>对于Executor，newCachedThreadPool是一种很好的默认选择。</p><p>只有任务独立，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或工作队列则可能导致线程出现“饥饿”死锁问题，此时应使用无界线程池如：newCachedThreadPool。</p><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a><strong>线程工厂</strong></h3><p>线程池中的线程都是由线程工厂进行创建的。默认的线程工厂创建一个新的，非守护的线程。我们可以通过指定一个线程工厂方法，来定制线程池的配置信息。ThreadFactory接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当线程池中创建一个新线程，都会调用这个newThread方法。</p><p>通常，我们都会使用定制的线程工厂方法，我们可能希望实例化一个定制的Thread类用于执行调试信息的记录，可能希望修改线程优先级，或者只是为了给线程取一个更有意义的名字。在如下程序中，我们给出一个自定义的线程工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/12 22:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span><span class="params">(String poolName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolName = poolName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAppThread(r, poolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以在MyAppThread中定制其他行为，包括为线程指定名字，设置自定义的UncaughtExceptionHandler向Logger中写入信息，维护一些统计信息（多少个线程被创建与销毁），在线程被创建或终止时把调试信息写入日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dhengyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/9/12 21:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"MyAppThread"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> debugLifecycle = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger created = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger alive = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = Logger.getAnonymousLogger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(runnable, DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAppThread</span><span class="params">(Runnable runnable, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(runnable, name + <span class="string">"-"</span> + created.incrementAndGet());</span><br><span class="line">        setUncaughtExceptionHandler(</span><br><span class="line">                <span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">                        log.log(Level.SEVERE, <span class="string">"UNCAUGHT in thread"</span> + t.getName(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> debug = debugLifecycle;</span><br><span class="line">        <span class="keyword">if</span> (debug) log.log(Level.FINE, <span class="string">"Created "</span> + getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            alive.incrementAndGet();</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            alive.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (debug) log.log(Level.FINE, <span class="string">"Exiting "</span> + getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsCreated</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> created.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getThreadsAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> alive.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBug</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> debugLifecycle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDebug</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        debugLifecycle = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a><strong>饱和策略</strong></h3><p>当有界队列被填满之后，饱和策略开始发挥作用。我们可以通过ThreadPoolExecutor的setRejectedExecutionHandler方法来选择不同的饱和策略。JDK主要提供了以下几种不同的饱和策略：</p><ol><li>AbortPolicy（中止策略）：默认的饱和策略，会抛出未检查的RejectedExecutionException。我们可以捕获这个异常，并按需编写自己的处理代码。</li><li>DiscardPolicy（抛弃策略）：当任务队列已满，抛弃策略会抛弃该任务。</li><li>DiscardOldestPolicy（抛弃最旧策略）：会抛弃下一个将要执行的任务（入队最早的任务，可以理解为最旧的任务），然后尝试重新提交新任务。</li><li>CallerRunsPolicy（调用者运行策略）：该策略不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者。它不会在线程池中的某个线程中执行任务，而是在调用了execute的线程中执行该任务。因此当工作队列已满，并且线程池中线程数量已达maximumPoolSize时，下一个任务会在调用execute的主线程中执行。由于任务执行需要一定的时间，因此主线程在这段时间内不会调用accept，因此到达的请求将被保存在TCP层的队列中而不是应用程序的队列中。如果持续过载，那么TCP层的缓冲队列也将会被填满，因此同样会抛弃请求。但对于服务器来说，这种过载情况是逐渐向外蔓延开的 — 从线程池队列到应用程序再到TCP层，最终到达客户端，这是一种平缓的性能降低。</li></ol><p>如下，我们使用了“调用者运行”饱和策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(N_THREADS, N_THREADS, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(CAPACITY));</span><br><span class="line"></span><br><span class="line">executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><strong>1. 熟悉Executor框架；</strong></p><p>注：所有的线程池都基于Executor接口，ExecutorService接口继承于Executor，提供了对线程池生命周期的管理，Executors提供了默认的几种创建线程池的工厂方法。</p><p><strong>2. 熟练掌握ThreadPoolExecutor的使用，熟悉ThreadPoolExecutor中各个参数使用及含义；</strong></p><p>注：当默认提供的线程池不能满足自己的需求，我们就需要通过ThreadPoolExecutor定制线程池。</p><p><strong>3. 线程池还有诸多细节；</strong></p><p>注：如何合理配置线程池的大小，继承ThreadPoolExecutor对其进行扩展（beforeExecutor，afterExecutor，terminated）</p><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>Java并发编程实战</p><p><a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="noopener">聊聊并发 — Java线程池的分析和使用</a></p><p><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用</a> — 很详细的一篇博客，其中还讨论了线程池的实现细节</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java并发" scheme="https://blog.dhengyi.name/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.dhengyi.name/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程池" scheme="https://blog.dhengyi.name/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--详解P2P对等网络（二）—Chord算法研究与分析</title>
    <link href="https://blog.dhengyi.name/2018/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AF%A6%E8%A7%A3P2P%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94Chord%E7%AE%97%E6%B3%95%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <id>https://blog.dhengyi.name/2018/06/28/计算机网络-详解P2P对等网络（二）—Chord算法研究与分析/</id>
    <published>2018-06-28T13:24:59.000Z</published>
    <updated>2019-07-13T16:11:20.669Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="结构化与非结构化网络"><a href="#结构化与非结构化网络" class="headerlink" title="结构化与非结构化网络"></a><strong>结构化与非结构化网络</strong></h2><p>非结构化的P2P网络是指网络节点之间不存在组织关系，节点之间完全是对等的，比如第一代P2P网络Napster。</p><p>结构化的P2P网络与非结构化恰好相反，我们认为网络在逻辑上存在一个人为设计的结构，比如Chord假定网络是一个环，Kadelima则假定为一颗二叉树。有了这些逻辑结构，就给我们资源查找引入了更多的算法和思路。</p><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>我们在 <strong>计算机网络–详解P2P对等网络（一）—BitTorrent协议</strong> 这一篇博客中讲述了BT下载的过程：在对等用户拿到种子文件的时候，首先会联系tracker服务器，然后加入用户集群，并在用户集群中寻找自己所需的内容，最后与拥有内容的对等用户进行联系。</p><p>从BT下载的过程中引出本节所要讨论的问题：<strong>如何高效的从用户集群中找出哪些对等用户拥有你正在寻求的具体内容？</strong></p><p>在历史中有三种比较典型的模型来解决这个问题：</p><ul><li><p>Napster：使用一个中心服务器接收所有的查询，服务器告知去哪下载其所需要的数据。存在的问题是中心服务器单点失效导致整个网络瘫痪。</p></li><li><p>Gnutella：使用消息洪泛（message flooding）来定位数据。一个消息被发到用户集群内每一个节点，直到找到其需要的数据为止。存在的问题是消息数与节点数成线性关系，导致网络负载较重。</p></li><li><p>SN型：超级节点（Super Node），SN保存网络中节点的索引信息，这一点和中心服务器类型一样，但是网内有多个SN，其索引信息会在这些SN中进行传播，所以整个系统的崩溃几率就会小很多。尽管如此，网络还是有崩溃的可能。</p></li></ul><p>关于P2P网络拓扑结构更详细的内容，请参考：<strong><a href="http://www.intsci.ac.cn/users/luojw/P2P/ch02.html" target="_blank" rel="noopener">P2P网络的拓扑结构</a></strong>。</p><p>现在的研究结果中，Chord、Pastry、CAN和Tapestry等常用于构建结构化P2P的分布式哈希表系统。</p><p>Chord算法是麻省理工学院（MIT）提出的一种基于DHT技术的结构化P2P路由协议，具有完全分布式、负载均衡、可用性及可扩展性好、命名方式灵活等特点。本文主要对Chord算法展开分析。</p><hr><h2 id="分布式哈希表（DHT）"><a href="#分布式哈希表（DHT）" class="headerlink" title="分布式哈希表（DHT）"></a><strong>分布式哈希表（DHT）</strong></h2><p>对于本节问题的思考，我们可以给出一种基本的解决方案：每个对等节点维护了一张路由表（索引），这张路由表只保存了少量有关其他节点的信息，这个特点意味着它保持最新索引的代价不会很昂贵。其次，每个节点可以快速的查看索引中的表项，否则，它就不是个有效的索引。最后，每个节点可以同时使用索引，即使其他节点来来去去，这个属性意味着索引的性能随着节点数量的增长反而越来越好~</p><p>该解决方案就被称为分布式哈希表，因为对等节点所维护的路由表就是一张索引表，而索引的基本功能就是将一个关键字映射到一个值。这简直就是一张哈希表，但是我们的解决方案是分布式版本。我们可以再看一下维基对于DHT的定义：</p><blockquote><p>分布式哈希表（distributed hash table，缩写DHT）：分布式计算系统中的一类，用来将一个关键值（key）的集合分散到所有在分布式系统中的节点，并且可以有效地将消息转送到唯一一个拥有查询者提供的关键值的节点（Peers）。这里的节点类似散列表中的存储位置。<strong>分布式散列表通常是为了拥有极大节点数量的系统，而且在系统的节点常常会加入或离开（例如网络断线）而设计的。在一个结构性的<a href="https://zh.wikipedia.org/wiki/%E8%A6%86%E7%9B%96%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">覆盖网络（overlay network）</a>中，参加的节点需要与系统中一小部分的节点沟通，这也需要使用分布式散列表。</strong></p></blockquote><p>上述我特意加粗的语句，正是对P2P网络架构的描述。</p><p>如果对于DHT的概念还抱有一定的疑惑，可以在网上搜寻更白话的说明，博主不再进行贴出。</p><h3 id="DHT与一致性哈希"><a href="#DHT与一致性哈希" class="headerlink" title="DHT与一致性哈希"></a><strong>DHT与一致性哈希</strong></h3><p>如上所述，<strong>DHT的主要想法是把网络上资源的存取像哈希表一样，可以简单而快速地进行put、get</strong>。与一致性哈希相比，DHT更强调的是资源的存取，而不管添加删除节点时产生的资源震荡的问题。与一致性哈希相同的是，DHT也只是一个概念，具体细节留给各实现。</p><p>当前这些P2P实现可以被作为DHT的具体实现，再次列举一些有代表性的实现：</p><blockquote><p>Chord、CAN、Tapestry、Pastry、Apache Cassandra、Kadelima、P-Grid、BitTorrent DHT</p></blockquote><hr><h2 id="Chord算法"><a href="#Chord算法" class="headerlink" title="Chord算法"></a><strong>Chord算法</strong></h2><h3 id="Chord是什么？"><a href="#Chord是什么？" class="headerlink" title="Chord是什么？"></a><strong>Chord是什么？</strong></h3><p>Chord是一个算法，也是一个协议。作为一个算法，Chord可以从数学的角度严格证明其正确性和收敛性；作为一个协议，Chord详细定义了每个环节的消息类型。当然，Chord之所以受追捧，还有一个主要原因就是Chord足够简单，3000行的代码就足以实现一个完整的Chord。</p><h3 id="Chord概述"><a href="#Chord概述" class="headerlink" title="Chord概述"></a><strong>Chord概述</strong></h3><p>Chord的实现方式如下：给定一个关键字Key，将其映射到某个节点。为此，采用相同哈希函数（SHA-1）为每个节点和关键字产生一个m bit的ID，并按照ID大小构成环形拓扑。节点所产生的ID被称为<strong>节点标识符</strong>，关键字所产生的ID我们称它为<strong>关键字ID</strong>。运行Chord的主机相互连接构成Chord网络，这是一个建立在IP网络之上的覆盖（overlay）网络。每个节点N有2个邻居：以顺时针为正方向排列在N之前的第1个节点称为N的前继（predecessor），在N之后的第1个节点称为N的后继（successor）。如下图（蓝色节点为节点ID，白色节点为关键字ID）：</p><p><img src="Chord环.png" alt="此处输入图片的描述"></p><p>同一致性哈希一样，资源放置在关键字ID的后继节点上，如上图，资源2被放置在节点3中。</p><h3 id="Finger表"><a href="#Finger表" class="headerlink" title="Finger表"></a><strong>Finger表</strong></h3><p>我们在本篇博客<strong><a href="#分布式哈希表（DHT）">分布式哈希表（DHT）</a></strong>一节中已经讲过，每个对等节点都会维护一张路由表，以便在用户集群中寻找拥有所需资源的其他对等节点。这张路由表就被称为Finger表，Finger表的表项大小为m，由两列数据项组成，如下：</p><table><thead><tr><th>ID+2的i次方</th><th>successor</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>其中ID就代表节点标识符，i表示Finger表中表项的下标，从0开始，successor则表示存储资源的后继节点。</p><p>举个例子：我们现在有一个<code>m = 3</code>的Chord环，它可以容纳2的3次方，也就是8个节点。现在有4台机器，假设它们经过哈希之后所产生的ID为0，1，2，6，那么机器1中将要维护的Finger表如下：</p><table><thead><tr><th>i</th><th>ID+2的i次方</th><th>successor</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>2</td></tr><tr><td>1</td><td>3</td><td>6</td></tr><tr><td>2</td><td>5</td><td>6</td></tr></tbody></table><p>其中ID+2的i次方表示的是关键字ID。</p><p>对于上表的解释，由一致性哈希可知：</p><p>机器1本地存储着关键字ID为1的数据，机器2本地存储着关键字ID为2的数据，机器6本地存储着关键字ID为3，4，5，6的数据，机器0本地存储着关键字ID为7，0 的数据。</p><p>与此同时，如上表，机器1上，还存储着关键字ID为2，3，5的数据所在的机器地址。比如，机器1知道，关键字ID为5的数据存储在机器6上面。</p><h3 id="Chord的查找"><a href="#Chord的查找" class="headerlink" title="Chord的查找"></a><strong>Chord的查找</strong></h3><p>Chord采取幂次逼近查询法。任何一个节点收到查询关键字ID为“K”的请求时，首先检查K是否落在该节点标识和它的后继节点标识之间，如果是的话，这个后继节点就是存储目标(K, V)对的节点。否则，节点将查找它的Finger表，找到表中<strong>节点标识符最大但不超过K</strong>的节点，并将这个查询请求转发给该节点。通过重复这个过程，最终可以定位到K的后继节点，即存储有目标(K, V)对的节点。</p><p>比如，当机器1接收到查询关键字ID为7的数据在哪台机器上时，它发现关键字ID“7”并不在该节点标识符和它的后继节点标识符之间，因此它查找节点标识符最大但没有超过7的节点，为6，于是将查询请求转发到机器6上。</p><p>机器6的路由表按照上述规则进行生成，如下（环形拓扑）：</p><table><thead><tr><th>i</th><th>ID+2的i次方</th><th>successor</th></tr></thead><tbody><tr><td>0</td><td>7</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>2</td><td>2</td><td>2</td></tr></tbody></table><p>机器6上的路由表指出：关键字ID为7的数据在机器0上… …重复这个过程，最终可找到保存关键字ID为7的资源的节点。</p><p>通过在每台机器上保存m项的路由信息，上面的方式可以做到O(logN)的查询时间复杂度。另外，比如Amazon Dynamo在论文中所说：通过在每台机子上保存足够多的路由信息，理论上可以做到O(1)时间的查询（相应的，节点间冗余信息也会更多）。</p><h3 id="节点的加入"><a href="#节点的加入" class="headerlink" title="节点的加入"></a><strong>节点的加入</strong></h3><p>新节点的加入需要一个称为向导的已知节点（n0）进行协助，任何一个运行在Chord网络中的节点都可以充当这个角色。加入过程包括新节点本身的Join操作和被其他节点发现2个阶段。如下图所示，假设np和ns是Chord网络中相邻两节点，n为新节点，它加入网络后应该位于np和ns节点之间。</p><p><img src="Chord节点的加入.png" alt="这里写图片描述"></p><p>新节点的加入有三个操作：</p><blockquote><ul><li>Join() ：n加入一个Chord环，已知其中有一个向导节点n0；</li><li>Stabilize(): 每个节点在后台周期性的进行此项操作，查询自身节点的后继节点的前序节点是否是自身，如果不是自身，说明有新加入的节点，此时将自身的后继节点修改为新加入的节点；</li><li>Notify(n): n通知其他节点它的存在，若此时其他节点没有前序节点或n比其现有的前序节点更加靠近自身，则将n设置为前序节点。</li></ul></blockquote><p>在了解了上述三个操作之后，我们讨论一下n节点加入的具体过程：</p><ol><li>n请求向导为它查找后继 (即ns)，并初始化自身Finger表，按照Finger表的定义，此时只有n对自身属性进行了设置，其他节点并不知道新节点的加入（如上图a）；</li><li>在n节点将自身的后继节点修改为ns后，会对ns进行Notify(n)操作，即n节点通知ns它的存在，此时ns标记n成为自己的前序节点；</li><li>所有节点会在后台周期性的进行Stabilize操作，此时np发现ns的前序结点已不是自身，则np将自己的后继节点修改为n；</li><li>np对n进行Notify(np)操作，n接到通知，将np修改为自己的前序节点。</li></ol><p>在这里有一个问题：<strong>向导节点如何帮助新加入的节点寻找它的后继节点以及新加入的节点如何初始化其Finger表？</strong></p><p>第一点：对于新节点n，通过向向导节点提交查找n自身节点标识符的请求，向导节点检索其后继；<br>第二点：新节点通过向向导节点请求<code>ID + 2的m次方</code>从而构建Finger表。</p><h3 id="节点的失效"><a href="#节点的失效" class="headerlink" title="节点的失效"></a><strong>节点的失效</strong></h3><p>节点的失效是节点没有通知其他节点而突然离开网络，这通常由主机崩溃或IP网络断开等意外原因造成，此时失效节点的前继保存的后继信息变得不可用，从而造成Chord环的断裂。为了处理这个问题，需要周期性的对节点的前序和后继进行探测。如果节点n发现其后继或前序已经失效，则从Finger表中顺序查找第1个可用节点进行替换，并重建Finger表。对前序节点失效的处理仍需要借助于Notify消息。考虑上图中的例子，ns虽然能够感知n的失效却无法进行修复。由于上述对后继失效的处理过程能够保证Chord环后继链的正确性，因此np通过在Stabilize中向新后继ns发送Notify，把ns的前继改成np。值得注意的是，其他节点也可能在Finger表项中保存有失效节点的记录，因此需要多次Stabilize，把失效信息扩散到Chord网络中。虽然这种方法最终能够保证Chord网络的完整性，但在节点频繁进出的情况下，其效率仍须更深入地研究。</p><h3 id="节点的退出"><a href="#节点的退出" class="headerlink" title="节点的退出"></a><strong>节点的退出</strong></h3><p>由于节点失效处理方法是稳定的，因此节点的退出可看作为失效而不采取其他附加措施。但基于效率的考虑，节点n退出时进行如下操作：1. 把n后继节点的前继改成n的前继；2. 把n前继节点的后继改成n的后继；3. 从n前继的Finger表中删除n。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>熟悉DHT、一致性哈希、Chord算法之间的概念及联系；</li><li>熟悉Chord算法的思想（Finger表的构建、Chord查询、节点的加入等）；</li><li>了解P2P网络的一些其它拓扑结构。</li></ol><p>PS：关于Chord算法数学角度上的证明与分析，有兴趣的同学可以自行查阅相关资料~</p><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>计算机网络（第五版） — Andrew S. TanenBaum/David J. Wetherall</p><p><a href="http://www.yeolar.com/note/2010/04/06/p2p-chord/#id18" target="_blank" rel="noopener">结构化P2P网络chord算法研究与分析</a></p><p><a href="https://www.cnblogs.com/hapjin/p/5760463.html" target="_blank" rel="noopener">分布式哈希算法</a></p><p><a href="https://www.cnblogs.com/gnuhpc/archive/2012/01/13/2321476.html" target="_blank" rel="noopener">【学术之门之P2P算法研读】P2P中的Chord算法</a></p><p><a href="https://blog.csdn.net/chen77716/article/details/6059575" target="_blank" rel="noopener">Chord算法（原理）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://blog.dhengyi.name/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="P2P" scheme="https://blog.dhengyi.name/tags/P2P/"/>
    
  </entry>
  
  <entry>
    <title>查找--深入理解一致性哈希算法</title>
    <link href="https://blog.dhengyi.name/2018/06/26/%E6%9F%A5%E6%89%BE-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://blog.dhengyi.name/2018/06/26/查找-深入理解一致性哈希算法/</id>
    <published>2018-06-26T13:06:58.000Z</published>
    <updated>2019-07-14T10:12:51.164Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>注：本篇博客只是讲述了一致性哈希的思想，我们会在之后讲述分布式哈希表以及一致性哈希的一种实现（Chord算法）。</strong></p><h2 id="什么是一致性哈希算法？"><a href="#什么是一致性哈希算法？" class="headerlink" title="什么是一致性哈希算法？"></a><strong>什么是一致性哈希算法？</strong></h2><p>引用自维基百科：</p><blockquote><p>一致性哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量，n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位几乎需要对所有关键字进行重新映射。</p></blockquote><p><strong>总结</strong>：一致性哈希算法主要关注的是在分布式架构中，当节点数目发生变化的时候（增加/删除），怎样使再哈希的数据量最少。</p><hr><h2 id="一致性哈希的引出"><a href="#一致性哈希的引出" class="headerlink" title="一致性哈希的引出"></a><strong>一致性哈希的引出</strong></h2><p>在分布式系统中，节点的宕机、某个节点加入或者移出集群是常事。对于分布式存储而言，假设存储集群中有10台机器（node），如果采用传统Hash方式对数据分片（item）(即数据根据哈希函数映射到某台机器上存储)，哈希函数应该是这样的：hash(item) % 10。根据上面的介绍，当node数发生变化（增加、移除）后，数据会被重新“打散”，导致大部分数据不能落到原来的节点上，从而导致大量数据需要迁移，而这种移动会造成网络的负载。</p><p>那么，一个亟待解决的问题就变成了：当node数发生变化时，如何保证尽量少引起迁移呢？即当增加或者删除节点时，对于大多数item，保证原来分配到的某个node，现在仍然应该分配到那个node，将数据迁移量降到最低。</p><hr><h2 id="一致性哈希的原理及优劣"><a href="#一致性哈希的原理及优劣" class="headerlink" title="一致性哈希的原理及优劣"></a><strong>一致性哈希的原理及优劣</strong></h2><p><img src="一致性哈希环结构.png" alt="此处输入图片的描述"></p><p>传统的Hash算法将对应的key哈希到一个具有2^32次方（int）个桶的空间中，即0~(2^32)-1的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。也就是将传统的线性哈希表构造成环形哈希表。</p><p>我们来看一下如何将数据映射到环形哈希表上：</p><p>如上图，有三台机器（node），四个数据项（item），每台机器对应着一个n位的ID（采用机器的IP或者机器唯一的别名作为哈希函数的输入值），并且映射到环中，每个查询键，也是一个n位的ID，节点的ID和查询键对应着相同的映射空间。三台机器将整个环分割成了三部分，分别是(1,3)，(3,2)，(2,1)。</p><p>机器1负责存储落在(2,1)范围内的数据，机器2负责存储落在(3,2)范围内的数据…..</p><p>也就是说，对数据进行Hash时，数据的地址会落在环上的某个点上，<strong>数据就存储在该点的顺时针方向上的那台机器上</strong>。</p><p>这种数据存储的方式，相比于普通哈希方式，有明显的优势：当添加新机器或者删除机器时，不会影响到全部数据的存储，而只是影响到这台机器上所存储的数据(落在这台机器所负责的环上的数据)。</p><p>而这种思想，也就是<strong>一致性哈希</strong>。我们举个例子来感受一下使用一致性哈希的好处：</p><blockquote><p>比如，机器1被移除了，那落在(2,1)范围内的数据全部需要由机器3来存储，也就只影响到落在(2,1)这个范围内的数据。同时，扩容也很方便，比如在(1,3)这段环上再添加一台机器4，只需要将3上的一部分数据拷贝到机器4上即可。</p></blockquote><p>虽然一致性Hash算法解决了节点变化导致的数据迁移问题，但是，我们回过头来再看看数据分布的均匀性：</p><p><img src="一致性哈希数据的分布.png" alt="此处输入图片的描述"></p><p>数据被传统的哈希算法“打散”后，是可以比较均匀分布的。但是引入一致性哈希算法后，为什么就不均匀呢？数据本身的哈希值并未发生变化，变化的是判断数据哈希后应该落到哪个节点的算法变了。</p><p>这三个节点Hash后，在环上分布不均匀，导致了每个节点实际占据环上的区间大小不一，数据随机映射到每个节点的概率就有较大差别，换个说法，也就是不能实现较好的负载均衡。</p><p>举个例子：机器1的配置很高，性能很好，而机器3的配置很低。但是，如上图，大部分数据由于某些特征都哈希到(1,3)这段环上，直接就导致了机器3的存储压力很大。</p><hr><h2 id="虚拟节点的引入"><a href="#虚拟节点的引入" class="headerlink" title="虚拟节点的引入"></a><strong>虚拟节点的引入</strong></h2><p>当我们将node进行哈希后，这些值并没有均匀地落在环上，因此，最终会导致，这些节点所管辖的范围并不均匀，最终导致了数据分布的不均匀。</p><p>为了解决一致性哈希的不足，从而引入了虚拟节点的概念。</p><p>引入虚拟节点，可以有效地防止物理节点（机器）映射到哈希环中出现不均匀的情况。比如上图中的机器1、2、3都映射在环的左半边上。</p><p>一般，虚拟节点会比物理节点多很多，并可均衡分布在环上，从而提高负载均衡的能力。</p><p><img src="一致性哈希虚拟节点.png" alt="此处输入图片的描述"></p><ol><li>如果虚拟节点与物理机器映射得好，某一台物理机器宕机后，其上的数据可由其他若干台物理机器共同分担；</li><li>如果新添加一台机器，它可以对应多个不相邻环段上的虚拟节点，从而使得Hash的数据存储得更分散。</li></ol><hr><h2 id="如何判定一致性哈希算法的好坏？"><a href="#如何判定一致性哈希算法的好坏？" class="headerlink" title="如何判定一致性哈希算法的好坏？"></a><strong>如何判定一致性哈希算法的好坏？</strong></h2><ol><li><strong>平衡性(Balance)</strong>：平衡性是指哈希的结果能够尽可能分布到所有的缓冲（服务器节点）中去，这样可以使得所有的缓冲空间都得到利用，很多哈希算法都能够满足这一条件；</li><li><strong>单调性(Monotonicity)</strong>：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中，哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区；</li><li><strong>分散性(Spread)</strong>：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性；</li><li><strong>负载(Load)</strong>：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li></ol><p><strong>注</strong>：对于第四点来说，好的一致性哈希算法，应该将同一用户的请求映射到相同的机器上，因为一个缓冲区始终处理同一个用户的请求是比较容易实现的（Cookie），如果将不同用户的不同请求映射到相同的缓冲区中，既有可能增大机器的负载，而且不容易实现。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>熟悉一致性哈希算法的特点及原理；</li><li>熟悉一致性哈希算法的优劣与改进（虚拟节点）；</li><li>掌握为什么会出现一致性哈希算法；</li><li>了解一致性哈希算法的另一种改进（线性空间的引入）—详见<a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">一致性哈希算法的理解与实践</a>。</li></ol><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">一致性哈希算法的理解与实践</a></p><p><a href="http://www.cnblogs.com/hapjin/p/4737207.html" target="_blank" rel="noopener">一致性哈希算法学习及JAVA代码实现分析</a></p><p><a href="https://blog.csdn.net/cywosp/article/details/23397179" target="_blank" rel="noopener">每天进步一点点—五分钟理解一致性哈希算法(consistent hashing)</a></p><p><a href="https://www.cnblogs.com/hapjin/p/5760463.html" target="_blank" rel="noopener">分布式哈希算法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://blog.dhengyi.name/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="一致性哈希" scheme="https://blog.dhengyi.name/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--详解P2P对等网络（一）—BitTorrent协议</title>
    <link href="https://blog.dhengyi.name/2018/06/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AF%A6%E8%A7%A3P2P%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94BitTorrent%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.dhengyi.name/2018/06/21/计算机网络-详解P2P对等网络（一）—BitTorrent协议/</id>
    <published>2018-06-21T03:15:10.000Z</published>
    <updated>2019-07-14T10:18:21.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>注：本篇文章内容借鉴自：<a href="http://azard.me/blog/2015/10/24/introduction-to-bittorrent/" target="_blank" rel="noopener">浅入浅出BitTorrent协议</a>，其中加入了博主的部分原创，感谢，侵删~</strong></p><h2 id="对等网络的概念"><a href="#对等网络的概念" class="headerlink" title="对等网络的概念"></a><strong>对等网络的概念</strong></h2><p>以下定义主要摘抄自维基百科与中科院计算技术研究所：</p><blockquote><p>对等式网络（peer-to-peer，简称P2P），又称点对点技术，是<strong>无中心服务器、依靠用户群（peers）交换信息的互联网体系</strong>。它的作用在于，网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络中的每个用户端既是资源（服务和内容）提供者（Server），又是资源获取者（Client），任何一个节点无法直接找到其他节点，必须依靠其用户群进行信息交流。</p></blockquote><hr><h2 id="对等网络的模型"><a href="#对等网络的模型" class="headerlink" title="对等网络的模型"></a><strong>对等网络的模型</strong></h2><p>P2P网络的简易模型图如下：</p><p><img src="P2P网络简易模型.png" alt="此处输入图片的描述"></p><p>如图，我们可以总结出P2P网络的一些特征：</p><ol><li><strong>非中心化</strong>：P2P是全分布式系统，网络中的资源和服务分散在所有的节点上，信息的传输和服务的实现都直接在节点之间进行，可以无需中间环节和服务器介入。</li><li><strong>可扩展性</strong>：用户可以随时加入该网络，系统的资源和服务能力随之同步扩充。理论上其可扩展性几乎可以认为是无限的。</li><li><strong>健壮性</strong>：因为服务是分散在各个节点之间的，部分节点或网络遭到破坏对其他部分的影响很小，故P2P具有耐攻击、高容错的特点。P2P网络一般在部分结点失效时能够自动调整整体拓扑，保持其它结点的连通性。P2P网络通常都是以自组织的方式建立起来的，并允许结点自由地加入和离开。</li><li><strong>高性价比</strong>：P2P架构可以有效地利用互联网中散布的大量普通结点，将计算任务或存储资料分布到所有结点上。利用其中闲置的计算能力或存储空间，达到高性能计算和海量存储的目的。</li><li><strong>隐私保护</strong>：在P2P网络中，由于信息的传输分散在各节点之间进行而无需经过某个集中环节，用户的隐私信息被窃听和泄漏的可能性大大缩小。</li><li><strong>负载均衡</strong>：由于每个节点既是服务器又是客户端，减少了传统C/S模型中对服务器计算能力、存储的要求，同时因为资源分布在多个节点，更好的实现了整个网络的负载均衡。</li></ol><hr><h2 id="BitTorrent协议"><a href="#BitTorrent协议" class="headerlink" title="BitTorrent协议"></a><strong>BitTorrent协议</strong></h2><p>BitTorrent协议，简称BT协议，是一种互联网上新兴的P2P传输协议（即BT是一种特殊的P2P）。</p><h3 id="出现的历史原因"><a href="#出现的历史原因" class="headerlink" title="出现的历史原因"></a><strong>出现的历史原因</strong></h3><p>随着全球接入互联网人数的增长，对互联网应用的服务端要求越来越高，吞吐量和并发量逐步加大。像国外的Google、Amazon，国内的阿里、百度等大型互联网企业十分关注如何使用集群、负载均衡等技术来提高网站的并发和吞吐量。但对于保存大文件给用户下载的中小型网站，在互联网爆发式增长下，用户数量越来越多，传输的文件越来越大，使用一台或几台服务器和传统的FTP、HTTP协议难以满足用户对下载速度的需求（受限于庞大的用户请求量、硬盘读取速度、带宽等）。BitTorrent协议解决了这些问题。</p><h3 id="BT下载流程"><a href="#BT下载流程" class="headerlink" title="BT下载流程"></a><strong>BT下载流程</strong></h3><blockquote><p>无论是BT还是PT，还是FTP，都是一种下载方式，或者学术点的讲法，叫文件传输。</p></blockquote><p>BT下载通过一个P2P下载软件（点对点下载软件）来实现，克服了传统下载方式的局限性，具有下载的人越多，文件下载速度就越快的特点。其好处是不需要资源发布者拥有高性能服务器就能迅速有效地把发布的资源传向其他的BT客户软件使用者，而且大多数的BT软件都是免费的。</p><p>BT下载架构模型图：</p><p><img src="BT下载架构模型图.png" alt="此处输入图片的描述"></p><p>现在，我们已经清楚了BT下载的架构模型，对于BT下载流程的讨论，我们跟随BT协议所引出的三个问题来进行：</p><blockquote><ol><li>一个对等用户如何找到具有自己想下载内容的其他对等用户？</li><li>对等用户们如何复制内容以便为大家提供高速下载？</li><li>对等用户们如何相互鼓励上传内容给他人同时为自己下载内容？</li></ol></blockquote><h4 id="B-encode"><a href="#B-encode" class="headerlink" title="B encode"></a><strong>B encode</strong></h4><p>在解决这三个问题之前，先简单介绍下B encode，因为在BitTorrent协议中的数据几乎都是用B encode进行编码的。它是一种作用类似于XML和JSON的数据组织格式，可以表达字符串、整数两种基本类型，列表、字典两种数据结构，它的语法规则十分简单。</p><ul><li>字节串按如下方式编码：</li></ul><blockquote><p>&lt;以十进制ASCII编码的串长度&gt;:&lt;串数据&gt;<br>例：“4:spam”表示字节串“spam”</p></blockquote><ul><li>整数按如下方式编码：</li></ul><blockquote><p>i&lt;以十进制ASCII编码的整数&gt;e<br>例：“i3e”表示整数“3”</p></blockquote><ul><li>列表按如下方式编码：</li></ul><blockquote><p>l&lt;内容&gt;e<br>开始的“l”与结尾的“e”分别是开始和结束分隔符。lists可以包含任何B编码的类型，包括整数、串、dictionaries和其他的lists。<br>例：l4:spam4:eggse 表示含有两个串的lists:[“spam”、“eggs”]</p></blockquote><ul><li>字典按如下方式编码：</li></ul><blockquote><p>d&lt;内容&gt;e<br>开始的“d”与结尾的“e”分别是开始和结束分隔符。注意键（key）必须被B编码为串。值可以是任何B编码的类型，包括整数、串、lists和其他的dictionaries。键（key）必须是串，并且以排序的顺序出现（以原始串排列，而不是以字母数字顺序）。<br>例：d3:cow3:moo4:spam4:eggse表示dictionary { “cow” =&gt; “moo”, “spam” =&gt; “eggs” }</p></blockquote><h4 id="torrent文件与tracker服务器"><a href="#torrent文件与tracker服务器" class="headerlink" title="torrent文件与tracker服务器"></a><strong>torrent文件与tracker服务器</strong></h4><p>现在，我们考虑上述中的第一个问题：<strong>一个对等用户如何找到具有自己想下载内容的其他对等用户？</strong></p><p>在P2P网络系统的最初阶段，并不是所有的用户都拥有所有的内容，首先需要一个内容的发布者。作为内容的发布者，BitTorrent可以为每个发布者（内容提供商）创建一个内容描述文件，即.torrent文件，也就是我们平常所说的<strong>种子文件</strong>。</p><p>种子文件是一种指定格式的文件，包含了两类关键信息，<strong>一类信息是tracker服务器的URL，一类信息是一个大小相等的块的清单</strong>。tracker服务器可以将用户引导至种子文件的内容，也就是将用户引导至拥有当前用户所需下载内容的其他对等节点处，块清单则组成了内容。</p><p>关于种子文件具体的组成结构，它使用B encode表示，<strong>整个是一个字典数据结构</strong>，它有多个key值，包括一些是可选的，这里介绍最关键的上述两类信息的键值对：</p><blockquote><ul><li>info：存储资源文件的元信息<ul><li>piece length</li><li>pieces</li><li>name/path</li></ul></li><li>announce：描述tracker服务器的URL</li></ul></blockquote><p><strong>info</strong>：info键对应的值又是一个字典结构，<strong>BT协议将一个文件分成若干块，便于客户端从各个主机下载各个块</strong>。其中的<strong>piece length</strong>键值对表示一个块的长度，通畅情况下是2的n次方，根据文件大小有所权衡，通长越大的文件piece length越大以减少piece的数量，降低piece数量一方面降低了种子文件保存块信息数目的大小，一方面也减少了下载时需要对块做的确认操作，加快下载速度。目前块的大小通常是256KB，512KB或者1MB。</p><p><strong>pieces</strong>：表示每个块的正确性验证信息，每一块均对应一个唯一的SHA1散列值。该键对应的值是所有块的SHA1散列值（每个块所对应的散列值大小为20字节）连接而成的字符串。</p><p><strong>name/path</strong>：表示具体文件的信息。因为<strong>BitTorrent协议允许将数个文件和文件夹作为一个BT下载进行发布</strong>，因此下载方可以根据需要勾选某一些下载文件。注意，这里将数个文件也砍成一个数据流，因此一个piece如果在文件边界上，可能包含不同文件的信息。</p><p><strong>announce</strong>：保存的是tracker服务器的URL，在一些扩展协议中，announce可以保存多个tracker服务器作为备选。</p><p>生成好种子文件之后，为了下载由种子文件所描述的内容，一个对等用户首先需要和此种子文件取得联系。这个种子文件通常被放在服务器上，可以通过HTTP或者FTP协议供用户下载这个种子文件。相比于直接将整个资源文件提供给用户下载，只传输一个种子文件大大降低了服务器的负荷。</p><p>在取得种子文件后，我们可以通过BitTorrent协议提供的一些工具（BitTorrent软件客户端）来打开这个种子文件，客户端会根据种子文件的name/path元信息告诉我们这个种子文件可以下载到（假设）一个.mkv文件，一个字幕文件，在这个阶段我可以进行一些勾选，选择下载某些而不是全部的资源。</p><p>资源选择确定后，客户端就开始了下载。客户端的第一步任务根据种子文件上的tracker服务器的URL使用HTTP进行GET请求——tracker服务器维护着一个正在主动上传和下载该内容的所有其他对等用户列表，我们将这一组对等用户称为<strong>用户群</strong>，对等用户可以随时离开群（以及返回），只要他们及时向tracker服务器进行报告即可——这个请求包含了很多参数，这里只介绍从客户端发送到tracker的请求中最关键的几个参数。</p><blockquote><ul><li>info_hash</li><li>peer_id</li><li>ip</li><li>port</li></ul></blockquote><p><strong>info_hash</strong>：种子文件中info键所对应的值的SHA1散列，可以被tracker服务器用来索引唯一的对应资源。</p><p><strong>peer_id</strong>：20Byte的串，没有任何要求，被tracker服务器用于记录客户端的名字。</p><p><strong>ip</strong>：可以从HTTP GET请求中直接获取，放在参数中可以解决使用代理进行HTTP GET的情况，tracker服务器可以记录客户端的IP地址。</p><p><strong>port</strong>：客户端监听的端口号，用于接收Response。一般情况下为BitTorrent协议保留的端口号：6881-6889，tracker服务器会记录下端口号用于通知其他客户端。</p><p>在tracker服务器收到客户端的HTTP GET请求后，会返回B encode形式的text/plain文本，同样是一个字典数据结构，其中最关键的一个键值对是peers，它的值是个字典列表结构，列表中的每一项都是如下的字典结构：</p><blockquote><ul><li>peers<ul><li>peer_id</li><li>ip</li><li>port</li></ul></li></ul></blockquote><p>这些信息在每个客户端连接tracker服务器的时候都发送过，并且被Tracker服务器保存了下来。新来的客户端自然要获取到这些下载中或者已下载完的客户端的ip，port等信息，有了这些信息，客户端就不需要像FTP或者HTTP协议一样持续找服务器获取资源，可以从这些其他客户端上请求获取资源。</p><h4 id="peer-to-peer"><a href="#peer-to-peer" class="headerlink" title="peer to peer"></a><strong>peer to peer</strong></h4><p>如上所述，如果对第一个问题进行简单的总结，那么自己想要下载的内容就交由种子文件进行确定，而如何寻找拥有这些资源的其他对等用户，则需要tracker服务器的帮助。</p><p>那么，我们现在思考第二个问题：<strong>对等用户们如何复制内容以便为大家提供高速下载？</strong></p><p>客户端从tracker服务器获取到若干其他下载者(peer)的ip和port信息，会进行请求并维持跟每一个peer的连接状态。一个客户端和每一个peer的状态主要有下列状态信息：</p><blockquote><ul><li>choke：远程客户端拒绝响应本客户端的任何请求。</li><li>interested：远程客户端对本客户端的数据感兴趣，当本客户端unchoked远程客户端后，远程客户端会请求数据。</li></ul></blockquote><p>所以应该有4个参数，分别表示本客户端对远程客户端是否choke，是否interested，远程客户端对本客户端是否choke，是否interested。当一个客户端对一个远程peer感兴趣并且那个远程peer没有choke这个客户端，那么这个客户端就可以从远程peer下载块(block)。当一个客户端没有choke一个peer，并且那个peer对这个客户端感兴趣时，这个客户端就会上传块(block)。</p><p><strong>补充一点</strong>：由于内容发布者本来就拥有所有的块，因此在生成种子文件的时候，内容发布者首先会根据种子文件将内容重新下载一遍，在这个过程中就会联系tracker服务器，然后将自己的信息记录在其所维护的用户列表上。</p><p>其实上述所讲的概念已经解答了第二个问题，每一个对等节点在参与一个用户群期间，都可同时从其他对等节点处下载缺少的块，并给其他对等节点上传本身拥有并且他们所需要的块。如果每个对等节点都这样做，那么经过短暂的一段时间后，所有的块都将成为广泛可用——加入用户群的用户越多，块被交易的越频繁，下载速度越快。</p><p>对第二个问题的答案进行一个简单的总结：对等用户们通过在下载块的同时也会上传块，从而为大家提供高速下载。</p><p>我们再进行一些补充，上面也提到了，在交易块的过程中，端与端之间会进行通信：</p><p>首先会发送握手报文，告诉远程客户端本客户端的一些信息，包括info_hash和peer_id。</p><p>接下来的所有报文有如下几种类型：</p><blockquote><ul><li>keep-alive：告诉远程客户端这个通信还在维持，否则超过2分钟没有任何报文远程客户端会将通信关闭</li><li>choke</li><li>unchoke</li><li>interested</li><li>not interested</li><li>bitfield：告诉对方我已经有的piece</li><li>have：告诉对方某个piece已经成功下载并且通过hash校验</li><li>request：请求某个块(block)<ul><li>index: 整数，指定从零开始的piece索引</li><li>begin: 整数，指定piece中从零开始的字节偏移</li><li>length: 整数，指定请求的长度</li></ul></li><li>piece：返回请求的块(block)的数据，是真正的资源信息<ul><li>index: 整数，指定从零开始的piece索引</li><li>begin: 整数，指定piece中从零开始的字节偏移</li><li>block: 数据块</li></ul></li></ul></blockquote><p>经过这些报文在<strong>本地客户端和若干个远程客户端</strong>之间的来回传递，就能够获取到资源文件。</p><h4 id="PT下载"><a href="#PT下载" class="headerlink" title="PT下载"></a><strong>PT下载</strong></h4><p>在解决了前两个问题之后，我们来考虑第三个问题：<strong>对等用户们如何相互鼓励上传内容给他人同时为自己下载内容？</strong></p><p>我们也可以看到，在P2P网络中，起初必须有一个内容的提供者，并且在健康的P2P网络中，每个peer都应当同时扮演客户端与服务器两个角色，那些只想从系统中获取资源而没有实物贡献的节点我们称之为“搭便车”或“吸血鬼”，如果这样的用户太多，那系统将无法正常工作。</p><p><strong>PT</strong>全称Private Tracker，与BT最大的不同点分别为可进行私密范围下载，及可统计每个用户的上传及下载量。从技术上可以简单的看作有一个tracker服务器会对用户的下载上传进行统计，分享率不够就禁止用户下载，在一定程度上可以防止只下载而不上传的用户存在。关于PT下载更详细的内容，博主不在这里进行讨论，有兴趣的同学可以自行查阅相关资料。</p><hr><h2 id="一个有趣的小问题"><a href="#一个有趣的小问题" class="headerlink" title="一个有趣的小问题"></a><strong>一个有趣的小问题</strong></h2><p>迅雷作为国内首屈一指的BT下载工具，为什么有时在下载接近完成的最后，一些数据总是传输的非常慢呢？</p><p>基于现实情况分析，有些人下载完成后关掉下载任务，提供较少量数据给其他用户，为尽量避免这种行为，在非官方BitTorrent协议中存在超级种子的算法。这种算法允许文件发布者分几步发布文件，发布者不需要一次提供文件所有内容，而是慢慢开放下载内容的比例，延长下载时间。此时，速度快的人由于未下载完必须提供给他人数据，速度慢的人有更多机会得到数据。由此往往造成用户卡在任务的99%，下载1G的任务要上传3G之多的数据。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>熟悉P2P网络的特点及优势；</li><li>熟悉BitTorrent协议的基本内容；</li><li>熟悉BT下载的过程（种子文件以及tracker服务器）；</li><li>掌握诸如<strong>用户群</strong>、<strong>吸血鬼</strong>等名词含义；</li><li>了解种子文件的组成格式——B编码；</li><li>了解peer与peer之间的通信报文格式；</li><li>能独立回答出关于BitTorrent协议的三个问题。</li></ol><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>计算机网络（第五版） — Andrew S. TanenBaum/David J. Wetherall</p><p><a href="http://azard.me/blog/2015/10/24/introduction-to-bittorrent/" target="_blank" rel="noopener">浅入浅出BitTorrent协议</a></p><p><a href="https://blog.csdn.net/lanchunhui/article/details/51870418#t2" target="_blank" rel="noopener">P2P（对等网络）、PT下载与BT下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://blog.dhengyi.name/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="P2P" scheme="https://blog.dhengyi.name/tags/P2P/"/>
    
      <category term="BitTorrent协议" scheme="https://blog.dhengyi.name/tags/BitTorrent%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--详解CDN</title>
    <link href="https://blog.dhengyi.name/2018/06/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AF%A6%E8%A7%A3CDN/"/>
    <id>https://blog.dhengyi.name/2018/06/18/计算机网络-详解CDN/</id>
    <published>2018-06-18T12:35:04.000Z</published>
    <updated>2019-07-14T10:20:25.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>注：本文内容摘抄自<a href="https://segmentfault.com/a/1190000010631404#articleHeader3" target="_blank" rel="noopener">CDN详解 — 不挑食的程序员</a>，博主在其基础上进行了少量修改并加入了部分原创，感谢，侵删~</strong></p><p>之前我们已经学习过缓存机制以及Web代理，但对于大型网站的构建，这些还远远不够。要想真正的构建一个流行的网站，内容分发网络（Content Delivery Network）简称CDN，是一项不可或缺的技术。</p><hr><h2 id="什么是CDN？"><a href="#什么是CDN？" class="headerlink" title="什么是CDN？"></a><strong>什么是CDN？</strong></h2><p>以下内容摘自维基百科：</p><blockquote><p>内容分发网络（CDN）是指一种通过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，<strong>更快、更可靠</strong>地将音乐、图片、视频、应用程序及其他文件发送给用户。</p></blockquote><p>如果对整个CDN系统做一个简单的描述：</p><blockquote><p>CDN系统主要由4大部分组成，每部分都由集群所构成。这4部分分别由CDN专属DNS服务器、全局负载均衡设备、区域负载均衡设备、CDN缓存服务器（边缘节点）构成。除过CDN专属DNS服务器，其他3部分集群都有源服务器上对应资源的全部或部分副本。CDN系统通过各部分的负载均衡算法，最终指示客户端使用附近最优的边缘节点中的一台缓存服务器作为服务端，从而提高Web应用的性能。</p></blockquote><hr><h2 id="CDN的基本工作过程"><a href="#CDN的基本工作过程" class="headerlink" title="CDN的基本工作过程"></a><strong>CDN的基本工作过程</strong></h2><p>在传统的Web模型中，发出请求后一般要经过如下几个步骤：</p><ol><li>用户在自己的浏览器中输入要访问的网站域名。</li><li>浏览器向<strong>本地DNS服务器</strong>请求对该域名的解析。</li><li>本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。</li><li>本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以<strong>迭代方式</strong>向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。</li><li>浏览器得到域名解析结果，就是该域名相应的服务设备的IP地址 。</li><li>浏览器获取IP地址之后，经过标准的TCP握手流程，建立TCP连接。</li><li>浏览器向服务器发起HTTP请求。</li><li>服务器将用户请求内容传送给浏览器。</li><li>经过标准的TCP挥手流程，断开TCP连接。</li></ol><p>在网站和用户之间加入CDN以后，用户不会有任何与原来不同的感觉。从宏观上来看，一个典型的CDN用户访问调度流程如下：</p><ol><li>当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，则本地DNS系统会将域名的解析权交给CNAME指向的<strong>CDN专用DNS服务器</strong>。</li><li>CDN的DNS服务器将CDN的 <strong>全局负载均衡设备</strong> IP地址返回给用户。</li><li>用户向CDN的全局负载均衡设备发起URL访问请求。</li><li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的<strong>区域负载均衡设备</strong>，并将请求转发到此设备上。</li><li>基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的<strong>缓存服务器节点</strong>，并从缓存服务器节点处得到<strong>缓存服务器的IP地址</strong>，最终将得到的IP地址返回给全局负载均衡设备：</li></ol><ul><li>根据用户IP地址，判断哪一个边缘节点距用户最近；</li><li>根据用户所请求的URL中携带的内容名称，判断哪一个边缘节点上有用户所需内容；</li><li>查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。</li></ul><ol start="6"><li>全局负载均衡设备把服务器的IP地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li></ol><p>CDN全局负载均衡设备与CDN区域负载均衡设备根据用户IP地址，将域名解析成相应节点中缓存服务器的IP地址，实现用户就近访问，从而提高服务端响应内容的速度。</p><p>理论上，最简单的CDN网络只有一个CDN专用DNS服务器，一个全局负载均衡设备，然后各节点一台缓存服务器，即可运行。</p><hr><h2 id="CDN的部署架构"><a href="#CDN的部署架构" class="headerlink" title="CDN的部署架构"></a><strong>CDN的部署架构</strong></h2><p><strong>CDN系统设计的首要目标是尽量减少用户的访问响应时间</strong>，为达到这一目标，CDN系统应该尽量将用户所需要的内容存放在距离用户最近的位置。也就是说，负责为用户提供内容服务的缓存设备应部署在物理上的网络边缘位置，我们称这一层为CDN边缘层。CDN系统中负责全局性管理和控制的设备组成中心层，中心层同时保存着基本上最完善的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。</p><p>不同CDN系统设计之间存在差异，中心层可能具备用户服务能力，也可能不直接提供服务，只向下级节点提供内容。如果CDN网络规模较大，边缘层设备直接向中心层请求内容或服务会造成中心层设备压力过大，就要考虑在边缘层和中心层之间部署一个区域层，负责一个区域的管理和控制，也保存部分内容副本供边缘层访问。</p><p>实际上，边缘层、区域层、中心层分别对应于边缘节点、区域负载均衡设备、全局负载均衡设备。</p><p>节点是CDN系统中最基本的部署单元，<strong>每个节点都是由服务器集群组成</strong>。一个CDN系统由大量的、地理位置上分散的POP（point-of-presence）节点组成，为用户提供就近的内容访问服务。</p><p>CDN节点网络主要包含CDN骨干点和POP点。CDN骨干点和CDN POP点在功能上不同。</p><p>中心和区域节点一般称为骨干点，主要作为内容分发和边缘未命中时的服务点；</p><p>边缘节点又被称为POP（point-of-presence）节点，CDN POP点主要作为直接向用户提供服务的节点。</p><p>从节点构成上来说（微观上），<strong>CDN骨干点、POP点都由缓存设备和本地负载均衡设备构成</strong>，它与全局负载均衡设备及区域负载均衡设备属于不同视角下的东西，可以分开实现，也可以抽象出接口，对上层透明。</p><p>缓存设备和本地负载均衡设备的连接方式有两种：一种是旁路方式，一种是穿越方式。我们只说穿越方式。</p><p>在穿越方式下，SLB（Server Load Balancer）本地负载均衡一般由L4-7交换机实现，SLB向外提供可访问的公网IP地址，我们可以将其称之为VIP。每台缓存服务器仅分配私网IP地址，该台SLB下的所有缓存服务器构成一个服务组。所有用户请求和媒体流都经过该SLB设备，再由SLB设备进行向上向下转发。SLB实际上承担了NAT（Network Address Translation，网络地址转换）功能，向用户屏蔽了单台缓存服务器设备的IP地址。</p><p>也就是说，我们所访问的全局负载均衡设备，区域负载均衡设备，CDN边缘节点服务器的IP地址，实际上都是VIP。这种方式是CDN系统中应用较多的方式，优点是具有较高的安全性和可靠性。</p><hr><h2 id="CDN的功能架构"><a href="#CDN的功能架构" class="headerlink" title="CDN的功能架构"></a><strong>CDN的功能架构</strong></h2><p>CDN基于这样的原理：</p><ol><li>挑选最优设备为用户提供服务；</li><li>如果某个内容被很多用户所需要，它就被缓存到距离用户最近的节点中。</li></ol><p>CDN公司在整个互联网上部署数以百计的CDN服务器（Cache），这些服务器通常在运营商的IDC(互联网数据中心Internet Data Center）中，尽量<strong>靠近接入网络和用户</strong>。当内容的提供者更新内容时，<strong>CDN向缓存服务器重新分发这些被刷新的内容</strong>。CDN提供一种机制，当用户请求内容时，该内容能够由以最快速度交付的缓存服务器来向用户提供，这个挑选”最优”的过程就叫做<strong>负载均衡</strong>。被选中的最优缓存服务器可能最靠近用户，或者有一条与用户之间条件最好的路径。</p><p>关于国内有名的CDN公司，我们熟知的包括阿里云、腾讯云、百度云等等，他们都对外提供CDN服务。</p><p>至于IDC，请戳：<a href="https://www.zhihu.com/question/40534161/answer/95912666" target="_blank" rel="noopener">云、CDN、IDC 三个概念的区别是什么？有什么相互包含和影响 - DADAman的回答 - 知乎 </a></p><p>从功能上划分，典型的CDN系统架构由<strong>分发服务系统、负载均衡系统和运营管理系统</strong>三大部分组成。</p><hr><h3 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a><strong>分发服务系统</strong></h3><p>该系统的主要作用是实现<strong>将内容从内容源中心向边缘的推送和存储，承担实际的内容数据流的全网分发工作和面向最终用户的数据请求服务</strong>。分发服务系统最基本的工作单元就是许许多多的缓存服务器，缓存服务器负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时缓存服务器还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。</p><p>一般来说，<strong>根据承载内容类型和服务种类的不同，分发服务系统会分为多个子服务系统</strong>，如网页加速子系统、流媒体加速子系统、应用加速子系统等。每个子服务系统都是一个分布式服务集群，由一群功能近似的、在地理位置上分布部署的缓存服务器或缓存服务器集群组成，彼此间相互独立。每个子服务系统设备集群的数量根据业务发展和市场需要的不同，少则几十台，多则可达上万台，对外形成一个整体，共同承担分发服务工作。缓存服务器设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。</p><p>分发服务系统在承担内容的更新、同步和响应用户需求的同时，还需要向上层的调度控制系统提供每个缓存服务器的健康状况信息、响应情况，有时还需要提供内容分布信息，以便调度控制系统根据设定的策略决定由哪个缓存服务器（组）来响应用户的请求最优。</p><hr><h3 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a><strong>负载均衡系统</strong></h3><p>负载均衡系统是一个CDN系统的神经中枢，主要功能是<strong>负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址</strong>。大多数CDN系统的负载均衡系统是分级实现的，这里以最基本的两级调度体系进行简要说明。一般而言，两级调度体系分为<strong>全局负载均衡（GSLB）和本地负载均衡（SLB）</strong>。</p><p>我们刚说的全局负载均衡设备及区域负载均衡设备都属于全局负载均衡，本地负载均衡设备则属于本地负载均衡。</p><p>其中，全局负载均衡（GSLB）主要根据用户就近性原则，通过对每个服务节点进行”最优”判断，确定向用户提供服务的缓存服务器集群的物理位置。<strong>最通用的GSLB实现方法是基于DNS解析的方式实现</strong>，也有一些系统采用了应用层重定向等方式来解决。<strong>本地负载均衡（SLB）主要负责节点内部的设备负载均衡</strong>，当用户请求从 GSLB调度到SLB时，SLB会根据节点内各缓存服务器设备的实际能力或内容分布等因素对用户进行重定向，常用的本地负载均衡方法有基于4层调度、基于7层调度、链路负载调度等。</p><hr><h3 id="运营管理系统"><a href="#运营管理系统" class="headerlink" title="运营管理系统"></a><strong>运营管理系统</strong></h3><p>CDN的运营管理系统与一般的电信运营管理系统类似，分为运营管理和网络管理两个子系统。</p><p>运营管理子系统是CDN系统的业务管理功能实体，负责处理业务层面的与外界系统交互所必需的一些收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p><p>网络管理子系统实现对CDN系统的网络设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源进行集中化管理操作的界面，通常是基于Web方式实现的。</p><p>在CDN系统中，不仅分发服务系统和调度控制系统是分布式部署的，运营管理系统也是分布式部署的，每个节点都是运营管理数据的生成点和采集点，通过日志和网管代理等方式上报数据。可以说，CDN本身就是一个大型的具有中央控制能力的分布式服务系统。</p><p>试着使用一下腾讯云提供的CDN服务吧，或许会对你理解运营管理系统有帮助。</p><hr><h2 id="为什么需要CDN？"><a href="#为什么需要CDN？" class="headerlink" title="为什么需要CDN？"></a><strong>为什么需要CDN？</strong></h2><p>当下的互联网应用都包含大量的静态内容，但静态内容以及一些准动态内容又是最耗费带宽的，特别是针对全国甚至全世界的大型网站，如果这些请求都指向主站的服务器的话，不仅是主站服务器受不了，单端口500M左右的带宽也扛不住，所以大多数网站都需要CDN服务。</p><p>根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响，任何的企业都渴望自己站点有更快的访问速度。而HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP/IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。</p><p>这就是你使用CDN的第一个也是最重要的原因：为了加速网站的访问。</p><p>除了加速网站的访问之外，CDN还有一些作用：</p><p><strong>1. 实现跨运营商、跨地域的全网覆盖</strong></p><p>互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。阿里云在国内有500+节点，海外300+节点，覆盖主流国家和地区不是问题，可以确保CDN服务的稳定和快速。</p><p><strong>2. 保障你的网站安全</strong></p><p>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。</p><p><strong>3. 异地备援</strong></p><p>当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。</p><p><strong>4. 节约成本</strong></p><p>投入使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</p><p><strong>5. 让你更专注业务本身</strong></p><p>CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。</p><hr><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a><strong>其它</strong></h2><h3 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a><strong>流量劫持</strong></h3><p>其实，CDN本身就是一种DNS劫持，只不过是良性的。不同于黑客强制DNS把域名解析到自己的钓鱼IP上，CDN则是让DNS主动配合，把域名解析到临近的服务器上。</p><p>劫持通常分为两类：</p><ol><li><p><strong>域名劫持</strong>，又称<strong>DNS劫持</strong>，通常是指域名指向到非正常IP（恶意IP），该恶意IP通过反向代理的方式，在能返回网页正常内容的情况，可能插入恶意代码、监听网民访问、劫持敏感信息等操作。通常验证一个域名是否被劫持的方法是PING一个域名，如果发现PING出来的IP不是您的服务器真实IP，则可以确定被劫持了。</p></li><li><p><strong>数据劫持</strong>，通常由电信运营商中某些员工等勾结犯罪分子，在公网中进行数据支持，插入，此类情况极隐蔽，不会改变用户域名解析IP，而是直接数据流经运营商宽带时在网页中挺入内容，此类情况，建议网页启用HTTPS加密，可以解决这一问题（通信是加密的，运营商无法插入恶意内容）。</p></li></ol><p>如果使用CDN服务，当源站向CDN返回被劫持的内容时，此时CDN将获取不到正确的网页内容（而是经运营商篡改强制植入广告的页面），此时可能导致该内容在CDN中长时间缓存，发现这种问题，可以清理CDN缓存，一般即可恢复正常。</p><h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a><strong>CDN缓存</strong></h3><p>CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循HTTP标准协议，通过HTTP缓存机制来设置CDN边缘节点数据缓存时间。</p><p>当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求（back to the source request），从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p><p>CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p><p>CDN缓存时间会对回源率产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大了访问延时；若CDN缓存时间太长，会带来数据更新慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p><p>CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用刷新缓存功能来强制CDN节点上的缓存过期，保证客户端在访问时，拉取到最新的数据。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>熟悉CDN系统的请求与响应流程；</li><li>熟悉CDN系统的部署架构及功能架构；</li><li>掌握CDN系统中全局负载均衡与本地负载均衡的相关概念；</li><li>掌握CDN系统中全局负载均衡设备、区域负载均衡设备、本地负载均衡设备间各个的功能及相关概念；</li><li>了解使用CDN的好处；</li><li>了解流量劫持与CDN缓存。</li></ol><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="https://www.zhihu.com/question/21771529/answer/190036779" target="_blank" rel="noopener">如何自己架设部署CDN — 视界云</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://blog.dhengyi.name/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="CDN" scheme="https://blog.dhengyi.name/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理--64位CPU装载32位操作系统，它的寻址能力还是4GB吗？</title>
    <link href="https://blog.dhengyi.name/2018/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-64%E4%BD%8DCPU%E8%A3%85%E8%BD%BD32%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AF%BB%E5%9D%80%E8%83%BD%E5%8A%9B%E8%BF%98%E6%98%AF4GB%E5%90%97%EF%BC%9F/"/>
    <id>https://blog.dhengyi.name/2018/05/25/计算机组成原理-64位CPU装载32位操作系统，它的寻址能力还是4GB吗？/</id>
    <published>2018-05-25T15:20:56.000Z</published>
    <updated>2019-07-14T10:24:49.550Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>借由这个问题，今天我们就把 32 位 CPU、64 位 CPU、32 位操作系统、64 位操作系统之间的区别与联系彻底搞清楚。对于这个问题，博主也是一知半解了好长时间啊~</p><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h2><h3 id="32位的CPU与64位CPU"><a href="#32位的CPU与64位CPU" class="headerlink" title="32位的CPU与64位CPU"></a><strong>32位的CPU与64位CPU</strong></h3><p>以下内容摘自维基百科：</p><blockquote><p>64 位 CPU 是指 CPU 内部的通用寄存器的宽度为 64 比特，支持整数的 64 比特宽度的算术与逻辑运算。那么 32 位 CPU 同理。</p><p>一个 CPU，联系外部的数据总线与地址总线，可能有不同的宽度；术语“64位”也常用于描述这些总线的大小。不过这一术语也可能指电脑指令集的指令长度，或其它的数据项。去掉进一步的条件，“64位”电脑架构一般具有 64 位宽的整数型寄存器，它可支持 64 位“区块”的整数型数据。</p><p>64 位架构无疑可应用在需要处理大量数据的应用程序，如数字视频、科学运算、和早期的大型数据库。</p></blockquote><p>那么 <strong>32 位 CPU 与 64 位 CPU 到底有什么区别</strong>？</p><ol><li><strong>数据处理能力增强</strong>：64 位 CPU 通用寄存器的位宽增加一倍，这也就意味着 64 位 CPU 可以一次性处理 64bit 的整形数据；</li><li><strong>内存寻址能力增强</strong>：如果是 32 位 CPU 的话，它的地址总线最多不会超过 32，那么它所能达到的寻址范围也就不会超过 2 的 32 次方字节（存储单元以字节为单位），也就是 4GB，而如果是 64 位处理器的话，它所能达到的寻址范围理论上就会是 2 的 64 次方字节（上亿 GB）。</li></ol><p><strong>补充</strong>：一般处理器多少位是指通用寄存器的长度，当然数据线需要与之相同；地址线则不需要与之相等，好比 intel 64 位处理器则是 40 位地址总线，最大支持 1TB 的内存寻址。</p><h3 id="32位操作系统与64位操作系统"><a href="#32位操作系统与64位操作系统" class="headerlink" title="32位操作系统与64位操作系统"></a><strong>32位操作系统与64位操作系统</strong></h3><p>平时我们所说的 32 位操作系统也被称为 X86 系统，x64 代表 64 位操作系统，关于它的简略解释：<a href="https://www.zhihu.com/question/49601232/answer/309709569" target="_blank" rel="noopener">为什么32位的计算机系统不叫x32而叫x86呢？</a></p><p>关于 32 位操作系统与 64 位操作系统的区别如下：</p><ol><li><p>32 位操作系统既可以运行在 32 位的 CPU 上，也可以运行在 64 位的 CPU 上，只不过，运行在 64 位 CPU 上的话，就有点“大马拉小车”的感觉了——无法发挥出 CPU 的全部能力。</p></li><li><p>64 位操作系统只能运行在 64 位的 CPU 上，因此如果一个操作系统是 64 位，那么它的 CPU 架构也必定是 64 位。</p></li><li><p>64 位操作系统相比于 32 位操作系统的优势正如上述 64 位 CPU 与 32 位 CPU 的优势一样。</p></li></ol><hr><h2 id="总线结构与主板构成"><a href="#总线结构与主板构成" class="headerlink" title="总线结构与主板构成"></a><strong>总线结构与主板构成</strong></h2><p><strong>注：以下两部分内容摘抄自：<a href="https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html" target="_blank" rel="noopener">32位系统最大只能支持4GB内存之由来</a>~</strong></p><p>在解决本文标题所述的问题之前，我们再来了解一些关于总线结构与主板构成的相关知识。</p><p>说起总线大家肯定不陌生，而且大家平时肯定跟它打过交道，我们在用U盘拷贝数据的时候先要把U盘通过USB接口与电脑相连才能拷贝。USB接口实际上就是一种总线，一般称这种总线为USB总线（也叫做通用串行总线）。在很久之前是没有USB总线的，那个时候每个外设各自采用自己的接口标准，举个最简单的例子：鼠标生产厂商采用鼠标特有的接口，键盘生产厂商用键盘特有的接口，这样一来的话，PC机上就必须提供很多接口，这样一来增加了硬件设计难度和成本，直到后来USB接口的出现，它统一了很多外设接口的标准，不仅使得用户可以很方便地连接一些外设，更增强了PC的可扩展性。所以现在大家看到的鼠标、键盘、U盘、打印机等等这些外设都可以直接通过USB接口直接插到电脑上的。</p><p>在计算机系统中总线是非常重要的一个概念，正是因为有了总线，所有的组成部件才能一起正常协同分工合作。在很久以前的PC机中，采用的是三总线结构，即：数据总线、地址总线、控制总线。它们分别用来传输不同类型的数据，数据总线用来传输数据，地址总线用来传输地址，控制总线用来传输一些控制信号。</p><p>随着时代的发展，这种简单的总线结构逐渐被淘汰。下面这幅图是现代计算机采用的结构：</p><p><img src="计算机总线结构.jpg" alt="此处输入图片的描述"></p><p>事实上这也是现代主板所采用的结构，当然可能部分地方有略微不同（大体结构是差不多的），仔细观察过主板构成的朋友可能对上面一幅图很熟悉。在主板上主要有两大主要部分：北桥（North Bridge也称Host Bridge）和南桥（South Bridge）。北桥主要负责CPU和内存、显卡这些部件的数据传送，而南桥主要负责I/O设备、外部存储设备以及BIOS之间的通信。现在有些主板已经没有北桥了，因为芯片厂商已经把北桥所负责的功能直接集成到CPU中了（不过暂且我们以上副图的模型来讨论）。</p><p>在上副图中，我没有画出数据总线和地址总线等，因为在某些总线标准中它们被集成到一起了，比如在PCI总线中，地址总线和数据总线总是分时复用的（也就是说假如PCI总线有32位数据总线，这32位总线在某个时刻可以充当数据总线的作用，在下一时刻可以充当地址总线的作用）。有的总线同时提供了数据总线和地址总线。</p><p>下面来说一下几个主要总线和南北桥的作用：</p><ol><li><p>FSB总线：即前端总线（Front Side Bus），CPU和北桥之间的桥梁，CPU和北桥传递的所有数据必须经过FSB总线，可以这么说，FSB总线的频率直接影响到CPU访问内存的速度。</p></li><li><p>北桥：北桥是CPU和内存、显卡等部件进行数据交换的唯一桥梁，也就是说CPU想和其他任何部分通信必须经过北桥。北桥芯片中通常集成的还有内存控制器等，用来控制与内存的通信。现在的主板上已经看不到北桥了，它的功能已经被集成到CPU当中了。</p></li><li><p>PCI总线：PCI总线是一种高性能局部总线，其不受CPU限制，构成了CPU和外设之间的高速通道。比如现在的显卡一般都是用的PCI插槽，PCI总线传输速度快，能够很好地让显卡和CPU进行数据交换。</p></li><li><p>南桥：主要负责I/O设备之间的通信，CPU要想访问外设必须经过南桥芯片。</p></li></ol><p>在了解了这些基础东西之后，下面来讲解一下为何 32 位系统最大只支持 4GB 内存。（是的，就算是 64 位的 CPU，装载 32 位的操作系统，它的寻址能力还是 4GB。）</p><hr><h2 id="对于标题的解释"><a href="#对于标题的解释" class="headerlink" title="对于标题的解释"></a><strong>对于标题的解释</strong></h2><p>在使用计算机时，其最大支持的内存是由<strong>操作系统</strong>和<strong>硬件</strong>两方面决定的。</p><p>先说一下硬件方面的因素，在上面已经提到了地址总线，在计算机中 CPU的地址总线数目 决定了CPU 的 寻址 范围，这种由地址总线对应的地址称作为物理地址。假如CPU有32根地址总线（一般情况下32位的CPU的地址总线是32位，也有部分32位的CPU地址总线是36位的，比如用做服务器的CPU），那么提供的可寻址物理地址范围 为 232=4GB（在这里要注意一点，我们平常所说的32位CPU和64位CPU指的是CPU一次能够处理的数据宽度，即位宽，不是地址总线的数目）。自从64位CPU出现之后，一次便能够处理64位的数据了，其地址总线一般采用的是36位或者40位（即CPU能够寻址的物理地址空间为64GB或者1T）。在CPU访问其它任何部件的时候，都需要一个地址，就像一个快递员送快递，没有地址他是不知道往哪里送达的，举个例子，CPU想从显存单元读取数据，必须知道要读取的显存单元的实际物理地址才能实现读取操作，同样地，从内存条上的内存单元读取数据也需要知道内存单元的物理地址。换句话说，CPU访问任何存储单元必须知道其物理地址。</p><p>用户在使用计算机时能够访问的最大内存不单是由CPU地址总线的位数决定的，还需要考虑操作系统的实现。实际上用户在使用计算机时，进程所访问到的地址是逻辑地址，并不是真实的物理地址，这个逻辑地址是操作系统提供的，CPU在执行指令时需要先将指令的逻辑地址变换为物理地址才能对相应的存储单元进行数据的读取或者写入（注意逻辑地址和物理地址是一一对应的）。</p><p>对于32位的windows操作系统，其逻辑地址编码采用的地址位数是32位的，那么操作系统所提供的逻辑地址寻址范围是4GB，而在intel x86架构下，采用的是内存映射技术(Memory-Mapped I/O, MMIO)，也就说将4GB逻辑地址中一部分要划分出来与BIOS ROM、CPU寄存器、I/O设备这些部件的物理地址进行映射，那么逻辑地址中能够与内存条的物理地址进行映射的空间肯定没有4GB了，看下面这幅图就明白了：</p><p><img src="CPU寻址.jpg" alt="此处输入图片的描述"></p><p>所以当我们装了32位的windows操作系统，即使我们买了4GB的内存条，实际上能被操作系统访问到的肯定小于4GB，一般情况是3.2GB左右。假如说地址总线位数没有32位，比如说是20位，那么CPU能够寻址到1MB的物理地址空间，此时操作系统即使能支持4GB的逻辑地址空间并且假设内存条是4GB的，能够被用户访问到的空间不会大于1MB（当然此处不考虑虚拟内存技术），所以用户能够访问到的最大内存空间是由硬件和操作系统两者共同决定的，两者都有制约关系。</p><p>于64位的操作系统，其逻辑地址编码采用的地址位数是40位，能够最大支持1T的逻辑地址空间。考虑一种情况，假如CPU是64位的，地址总线位数是40位，操作系统也是64位的，逻辑地址编码采用的地址位数也是40位，内存条大小是64GB，那么是不是内存条的64GB全部都能被利用了呢？答案是不一定，因为这里面还要考虑一个因素就是内存控制器，内存控制器位于北桥之内（现在基本都是放在CPU里面了），内存控制器的实际连接内存的地址线决定了可以支持的内存容量，也就是说内存控制器与内存槽实际连接的地址线如果没有40位的话，是无法完全利用64GB的内存条的存储空间的。当然对于内存控制器这个问题几乎可以不用考虑，因为现在大多数的内存控制器至少都采用的是40位地址总线。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>对于以上所述，我进行一下简单的总结：</p><blockquote><p>一个计算机，它的内存访问能力是由硬件和软件共同决定的。硬件层面就指 CPU 的寻址能力，也就是地址总线的个数。软件层面，指的就是操作系统。实际上我们（进程）在进行内存访问的时候，访问的都是逻辑地址，而逻辑地址是由操作系统提供的。对于 32 位的操作系统，其逻辑地址编码采用的地址位数是 32 位，那么操作系统所提供的逻辑地址寻址范围就是 4GB。从这个方面来说，纵使你的 CPU 实际寻址能力为 2 的 64 次方，由于操作系统只提供 4GB 的逻辑地址，那 CPU 透过操作系统所能访问到的内存大小也就只有4GB了。</p></blockquote><p>对与上述总结，我还有一个简单的补充：</p><p>在和我的大神小伙伴讨论的时候，他对于“为什么 64 位 CPU 装载 32 位操作系统，它的寻址能力还是 4GB”这个问题的解答，只说了一句话：“32 位操作系统没有对应 64 位的寻址指令”。在细细品味之后，觉得颇有道理，我对于这句话的浅显理解是：32 位操作系统没有对应 64 位的寻址指令，所以它不能提供 4GB 以上的逻辑地址，所以 64 位 CPU 透过 32 位操作系统，它的寻址能力依旧是 4GB。</p><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>维基百科：<a href="https://zh.wikipedia.org/wiki/64%E4%BD%8D%E5%85%83" target="_blank" rel="noopener">64位</a></p><p><a href="https://www.cnblogs.com/dolphin0520/archive/2013/05/31/3110555.html" target="_blank" rel="noopener">32位系统最大只能支持4GB内存之由来</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="https://blog.dhengyi.name/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="体系结构" scheme="https://blog.dhengyi.name/tags/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java并发--synchronized实现原理及锁优化</title>
    <link href="https://blog.dhengyi.name/2018/04/27/Java%E5%B9%B6%E5%8F%91-synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.dhengyi.name/2018/04/27/Java并发-synchronized实现原理及锁优化/</id>
    <published>2018-04-27T03:38:27.000Z</published>
    <updated>2019-07-14T10:42:13.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>注：本文中的部分内容摘抄自他人博客，如有侵权，请联系我，侵删~</strong></p><p>本篇博客主要讲述 synchronized 关键字的实现原理以及 JDK 1.6 后对 synchronized 的种种优化。synchronized 的使用不再赘述。</p><hr><h2 id="博主目前依旧存在的疑惑"><a href="#博主目前依旧存在的疑惑" class="headerlink" title="博主目前依旧存在的疑惑"></a><strong>博主目前依旧存在的疑惑</strong></h2><p>请在阅读完此篇博客之后，帮助博主回答这三个问题：</p><ol><li>多线程争夺 Monitor 的具体过程是怎样的？是根据 ObjectMonitor 中的 _count 值判断当前 Monitor 是否被锁定吗？</li><li>JVM 如果检测到在单线程环境下执行同步代码（StringBuffer），是会进行锁消除呢，还是会使用偏向锁？</li><li>对于偏向锁的撤销过程及膨胀过程，博主只是在一些博客的基础上给出了自己的理解！不权威，建议阅读源码，博主对这部分知识的讲解持怀疑态度，如果在阅读的过程中发现博主对偏向锁的撤销与膨胀理解有误，请指出，感激不尽~（网上基本上没有从源码角度分析的，对于偏向锁撤销与升级的详细过程也是众说纷纭）</li></ol><hr><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>我们先来看一份代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其进行 javap 反编译分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">javap -c SynchronizedTest.class</span><br><span class="line"></span><br><span class="line">Compiled from <span class="string">"SynchronizedTest.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">xiyoulinux</span>.<span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> org.xiyoulinux.SynchronizedTest();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: aload_1</span><br><span class="line">       <span class="number">5</span>: monitorexit</span><br><span class="line">       <span class="number">6</span>: goto          <span class="number">14</span></span><br><span class="line">       <span class="number">9</span>: astore_2</span><br><span class="line">      <span class="number">10</span>: aload_1</span><br><span class="line">      <span class="number">11</span>: monitorexit</span><br><span class="line">      <span class="number">12</span>: aload_2</span><br><span class="line">      <span class="number">13</span>: athrow</span><br><span class="line">      <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>     <span class="number">6</span>     <span class="number">9</span>   any</span><br><span class="line">           <span class="number">9</span>    <span class="number">12</span>     <span class="number">9</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比 javap 的输出结果，我们做一个简单的总结：</p><blockquote><p><strong>同步方法</strong>：synchronized 方法会被翻译成普通的方法调用。在 JVM 字节码层面并没有任何特别的指令来实现被 synchronized 修饰的方法。在 Class 文件的方法表中将该方法的 access_flags 字段中的 synchronized 标志位置 1，表示该方法是同步方法并使用调用该方法的对象（对象锁）或该方法所属的 Class（类锁） 做为锁对象。</p><p><strong>同步块</strong>：monitorenter 指令插入到同步代码块的开始位置，monitorexit 指令插入到同步代码块的结束位置，JVM 需要保证每一个 monitorenter 都有一个 monitorexit 与之相对应。任何对象都有一个 monitor 与之相关联，当且一个 monitor 被持有之后，他将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 所有权，即尝试获取对象的锁。（关于上述字节码中一个 monitorenter 指令为什么对应两个 monitorexit 指令我们稍后进行说明）</p></blockquote><hr><h2 id="synchronized底层语义原理"><a href="#synchronized底层语义原理" class="headerlink" title="synchronized底层语义原理"></a><strong>synchronized底层语义原理</strong></h2><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a><strong>Java对象头</strong></h3><p>要深入理解 synchronized 的实现原理，先来了解一下 Java 对象头。</p><p>对象在堆中由三部分组成：</p><blockquote><ol><li>对象头</li><li>实例变量</li><li>填充数据</li></ol></blockquote><ul><li><strong>实例变量</strong>：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</li><li><strong>填充数据</strong>：由于虚拟机要求对象起始地址必须是 8 字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</li><li><strong>对象头</strong>：HotSpot 虚拟机的对象头主要包括两部分数据：<strong>Mark Word（标记字段）、Class Point（类型指针）</strong>。其中 Class Point 是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word 用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。它还用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li></ul><p>Java 对象头一般占有两个字宽（在 32 位虚拟机中，1 个字宽等于 4 字节，也就是 32bit），但是如果对象是数组类型，则需要三个字宽，因为 JVM 虚拟机可以通过 Java 对象的元数据信息确定 Java 对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p><p>对象头的存储结构如下：</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64 bit</td><td>Mark Word</td><td>存储对象的 hashCode 或锁信息等。</td></tr><tr><td>32/64 bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64 bit</td><td>Array length</td><td>数组的长度（如果当前对象是数组）</td></tr></tbody></table><p>32 位 JVM 的 Mark Word 的默认存储结构如下：</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit 锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象HashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table><p>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到 JVM 的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如 32 位 JVM 下，除了上述列出的 Mark Word 默认存储结构外，还有如下可能变化的结构：</p><p><img src="Java对象头.jpg" alt="此处输入图片的描述"></p><h3 id="Monitor（管程）"><a href="#Monitor（管程）" class="headerlink" title="Monitor（管程）"></a><strong>Monitor（管程）</strong></h3><ul><li>什么是 Monitor（管程）？</li></ul><blockquote><p>我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。所有的 Java 对象都是天生的 Monitor，在 Java 的设计中 ，每一个 Java 对象都带了一把看不见的锁，它叫做内置锁或者 Monitor 锁。</p></blockquote><p>观察 Mark Word 存储结构的那张图（上图）：</p><blockquote><p>这里我们主要分析一下重量级锁也就是通常说 synchronized 的对象锁，锁标识位为 10，其中指针指向的是 monitor 对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在 Java 虚拟机(HotSpot)中，monitor 是由 ObjectMonitor 实现的，其主要数据结构如下：（位于 HotSpot 虚拟机源码 ObjectMonitor.cpp 文件，C++实现）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = <span class="number">0</span>;          <span class="comment">// 记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL;       <span class="comment">// 处于 wait 状态的线程，会被加入到 _WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span>;</span><br><span class="line">    _Responsible  = NULL;</span><br><span class="line">    _succ         = NULL;</span><br><span class="line">    _cxq          = NULL;</span><br><span class="line">    FreeNext      = NULL;</span><br><span class="line">    _EntryList    = NULL;       <span class="comment">// 处于等待锁 block 状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span>;</span><br><span class="line">    _SpinClock    = <span class="number">0</span>;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor 中有两个队列，_WaitSet 和 _EntryList，用来保存 ObjectWaiter 对象列表( 每个等待锁的线程都会被封装成 ObjectWaiter 对象)，_owner 指向持有 ObjectMonitor 对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的 monitor 后会把 monitor 中的 _owner 变量设置为当前线程，同时 monitor 中的计数器 _count 加 1。若线程调用 wait() 方法，将释放当前持有的 monitor，_owner 变量恢复为 null，_count 自减 1，同时该线程进入 _WaitSet 集合中等待被唤醒。若当前线程执行完毕也将释放 monitor（锁）并复位变量的值，以便其它线程进入获取 monitor(锁)。</p><p>由此看来，monitor 对象存在于每个 Java 对象的对象头中(存储的是指针)，synchronized 便是通过这种方式获取锁的，也是为什么 Java 中任意对象可以作为锁的原因，同时也是 notify/notifyAll/wait 等方法存在于顶级对象 Object 中的原因（锁可以是任意对象，所以可以被任意对象调用的方法是定义在 object 类中）。</p><h3 id="synchronized方法底层原理"><a href="#synchronized方法底层原理" class="headerlink" title="synchronized方法底层原理"></a><strong>synchronized方法底层原理</strong></h3><p>我们在引言部分对 synchronized 方法已经做了一个简单的总结，现在对它进行一点补充：</p><blockquote><p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层操作系统的 Mutex Lock 来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方从 JVM 层面对 synchronized 进行了较大优化，所以现在的 synchronized 锁效率也优化得很不错了。Java 6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，关于锁优化的内容，我们稍后再谈。</p></blockquote><h3 id="synchronized代码块底层原理"><a href="#synchronized代码块底层原理" class="headerlink" title="synchronized代码块底层原理"></a><strong>synchronized代码块底层原理</strong></h3><p>在引言部分，我们对 synchronized 代码块也做了一个简单的总结。同样，对其做一点补充：</p><blockquote><p>当执行 monitorenter 指令时，当前线程将试图获取对象锁所对应的 monitor 的持有权，当对象锁的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有对象锁的 monitor 的持有权，那它可以重入这个 monitor，重入时计数器的值会加 1。倘若其他线程已经拥有对象锁的 monitor 的所有权，那当前线程将被阻塞，直到正在执行的线程执行完毕，即 monitorexit 指令被执行，执行线程将释放 monitor 并设置计数器值为 0，其他线程将有机会持有 monitor。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个 monitorexit 指令。</p></blockquote><hr><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a><strong>锁优化</strong></h2><h3 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a><strong>自旋锁与自适应自旋</strong></h3><p>如前面所述，synchronized 在 JDK 1.6 之前之所以被称为“重量级锁”，是因为对于互斥同步的性能来说，影响最大的就是阻塞的实现。挂起线程与恢复线程的操作都需要转入<strong>内核态</strong>中完成。从用户态转入内核态是比较耗费系统性能的。</p><p>研究表明，大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环，使当前线程不放弃处理器的执行时间(这也是称为自旋的原因)，在经过若干次循环后，如果得到锁，就顺利进入临界区。</p><p>但是自旋不能代替阻塞，首先，自旋锁需要多处理器或一个处理器拥有多个核心的 CPU 环境，这样才能保证两个及以上的线程并行执行（一个是获取锁的执行线程，一个是进行自旋的线程）。除了对处理器数量的要求外，自旋虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间比较短，自旋的效果就比较好，否则只是白白占用了 CPU 资源，带来性能上的浪费。</p><p>那么自旋就需要有一定的限度，如果自旋超过了一定的次数后，还没有成功获取锁，就只能进行挂起了，这个次数默认是 10。</p><p>在 JDK 1.4.2 中引入了自旋锁，在 JDK 1.6 中引入了自适应自旋锁。自适应意味自旋的时间不再固定：</p><blockquote><p>如果同一个锁对象上，自旋等待刚刚成功获取锁，并且持有锁的线程正在运行，那么虚拟机就会认为此次自旋也很有可能成功，进而它将允许自旋等待持续相对更长的时间，比如 100 个循环。如果对于某个锁，自旋很少成功获取过，那么在以后获取这个锁时将可能自动省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越精准，虚拟机也就会越来越“聪明”。</p></blockquote><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a><strong>锁消除</strong></h3><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java 虚拟机在 JIT 编译时(关于 JIT 编译可以参考我的这篇博客：<a href="https://blog.csdn.net/championhengyi/article/details/78918920" target="_blank" rel="noopener">JVM–解析运行期优化与JIT编译器</a>)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。</p><p>锁消除的主要判定依据来源于逃逸分析技术的支持(关于逃逸分析技术可以参考周志明老师所出的《深入理解 Java 虚拟机》一书中第 11 章内容或自行百度)。</p><p>也许你会有疑惑，变量是否逃逸，程序员本身应该就可以判断，怎么会存在明知道不存在数据争用的情况下还使用同步？来看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 String 是一个不可变类，因此对字符串的连接操作总是通过新生成的 String 对象来进行的，在 JDK 1.5 之前，javac 编译器会对 String 连接进行自动优化，将连接转换为 StringBuffer 对象的连续 append 操作，在 JDK 1.5 之后，会转化为 StringBuilder 对象的连续 append 操作。也就是说，上述代码经过 javac 优化之后，有可能变为下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer 是一个线程安全的类，在它的 append 方法中有一个同步块，锁对象就是 sb，但是虚拟机观察变量 sb，发现它是一个局部变量，本身线程安全，并不需要额外的同步机制。因此，这里虽然有锁，但可以被安全的清除，在 JIT 编译之后，这段代码就会忽略掉所有的同步而直接执行。这就是锁消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a><strong>锁粗化</strong></h3><p>原则上，我们在使用同步块的时候，总是建议将同步块的作用范围限制的尽量小—使需要同步的操作数量尽可能变小，在存在锁竞争的情况下，等待锁的线程可以尽快的拿到锁。</p><p>大部分情况下，上述原则都正确，但是存在特殊情况，如果一系列操作下来，都对同一个对象反复加锁与解锁，甚至加锁与解锁操作出现在循环体中，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗。</p><p>如上述代码中的 append 方法。如果虚拟机探测到了这样的操作，就会把加锁的同步范围扩展（粗化）到整个操作序列的外部。以上述代码为例，就是扩展到第一个 append 操作之前直至最后一个 append 操作之后，这样只需要加锁一次。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h3><p>偏向锁会偏向第一个获取它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要进行同步。</p><p>HotSpot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得（比如在单线程中使用 StringBuffer 类），为了让线程获得锁的代价更低而引入了偏向锁。当锁对象第一次被线程获取的时候，虚拟机把对象头中的标志位设为“01”，即偏向模式。同时使用 CAS 操作把获取这个锁的线程 ID 记录在对象的 Mark Word 中，如果 CAS 操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不用进行任何同步操作。</p><p>当有另一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p><p><img src="偏向锁的获得与撤销.png" alt="此处输入图片的描述"></p><p>如上图，当线程 2 争夺锁对象时，偏向模式宣告结束。由线程 2 通知线程 1 进行偏向锁的撤销，此时线程 1 在全局安全点（没有字节码执行的地方）处进行暂停，进行解锁操作。</p><p>偏向锁只能被第一个获取它的线程进行 CAS 操作，一旦出现线程竞争锁对象，其它线程无论何时进行 CAS 操作都会失败。</p><p>在解锁成功之后，JVM 将判断当前线程的状态，如果还没有执行完同步代码块，则直接将偏向锁膨胀为轻量级锁，然后继续执行同步代码块，否则将偏向锁先撤销为无锁状态，当下一次执行同步代码块的时候再由 JVM 将其膨胀为轻量级锁。</p><p>使用偏向锁的优点在于在没有多线程竞争的情况下，只需进行一次 CAS 操作，就可执行同步代码块，但是我们也必须保证撤销偏向锁所耗费的性能资源要低于省去加锁取锁所节省下来的性能资源。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h3><p><strong>偏向锁一旦受到多线程竞争，就会膨胀为轻量级锁。</strong></p><p>偏向锁在执行同步块的时候不用做任何同步操作，而轻量级锁是在多线程交替执行同步代码块，不产生线程阻塞的情况下使用 CAS 操作去消除同步使用的互斥量。</p><p><strong>轻量级锁加锁</strong>：线程在执行同步块之前，如果同步对象没有被锁定，JVM 会先在当前线程的栈桢中创建用于存储锁记录（Lock Record）的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁，如果自旋还是无法获取到锁，轻量级锁便会膨胀为重量级锁。</p><p><strong>轻量级锁解锁</strong>：轻量级解锁时，会使用 CAS 操作来将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图：</p><p><img src="轻量级锁及膨胀流程.png" alt="此处输入图片的描述"></p><p>如上图，当线程 1 还在使用轻量级锁执行同步代码块的时候，线程 2 尝试争夺轻量级锁，就会失败，失败之后线程 2 并不会直接将轻量级锁膨胀为重量级锁，而是先进行自旋等待，如果成功获取到锁，则不进行锁的膨胀。在线程 2 成功将锁升级之后，线程 2 进行阻塞。线程 1 执行完同步代码块之后尝试 CAS 解锁，解锁失败，发现有线程对锁进行过竞争，则释放锁并唤醒等待线程。</p><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h2><h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a><strong>锁的升级</strong></h3><blockquote><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p></blockquote><h3 id="各个状态锁的优缺点对比"><a href="#各个状态锁的优缺点对比" class="headerlink" title="各个状态锁的优缺点对比"></a><strong>各个状态锁的优缺点对比</strong></h3><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>始终得不到锁的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>同步块执行速度较慢。</td></tr></tbody></table><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>synchronized 的底层实现主要依靠 Monitor（管程）；</li><li>从管程我们需要延伸至 Java 对象头这一部分；</li><li>了解过 Java 对象头之后，我们可以对 Monitor 的底层实现（ObjectMonitor）再进行简单的了解；</li><li>熟悉多线程争夺 Monitor 的过程；</li><li>最后分类讨论同步方法与同步块；</li><li>熟悉锁粗化、锁消除、自旋与自适应自旋等相关概念；</li><li>熟悉偏向锁、轻量级锁、重量级锁的相关概念；</li><li>熟悉偏向锁、轻量级锁解锁的过程；</li><li>熟悉偏向锁、轻量级锁、重量级锁膨胀的过程。</li></ol><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>《深入理解Java虚拟机》–周志明</p><p><a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></p><p><a href="http://ifeve.com/java-synchronized/" target="_blank" rel="noopener">聊聊并发（二）Java SE 1.6中的Synchronized</a></p><p><a href="https://juejin.im/entry/589981fc1b69e60059a2156a" target="_blank" rel="noopener">死磕 Java 并发 - 深入分析 synchronized 的实现原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java并发" scheme="https://blog.dhengyi.name/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.dhengyi.name/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="https://blog.dhengyi.name/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Java源码--JDK 1.8 HashMap重点源码部分剖析</title>
    <link href="https://blog.dhengyi.name/2018/04/20/Java%E6%BA%90%E7%A0%81-JDK-1-8-HashMap%E9%87%8D%E7%82%B9%E6%BA%90%E7%A0%81%E9%83%A8%E5%88%86%E5%89%96%E6%9E%90/"/>
    <id>https://blog.dhengyi.name/2018/04/20/Java源码-JDK-1-8-HashMap重点源码部分剖析/</id>
    <published>2018-04-20T13:55:40.000Z</published>
    <updated>2019-07-16T12:18:09.425Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>注：感谢 <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">美团点评技术团队</a> 的分享~~，博客部分内容摘抄自其中。侵删！</strong></p><p>今天我们来探究一下 HashMap 的内部实现机制。</p><blockquote><p>明确 JDK 1.8 中的 HashMap 使用数组 + 链表 + 红黑树的结构进行实现。</p></blockquote><p>HashMap 的底层思想主要是哈希表，我们来看看 Java 的设计者们是怎么使用数组 + 链表 + 红黑树设计出 HashMap 的。</p><hr><h2 id="HashMap的基本属性"><a href="#HashMap的基本属性" class="headerlink" title="HashMap的基本属性"></a><strong>HashMap的基本属性</strong></h2><p>既然是用哈希表进行实现，那么基本的数据结构就是数组了，HashMap 部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;    <span class="comment">// HashMap 底层数据结构（Node 数组）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;             <span class="comment">// HashMap 中实际存在的键值对数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;         <span class="comment">// 记录 HashMap 内部结构发生变化的次数，用于快速失败机制</span></span><br><span class="line">    <span class="keyword">int</span> threshold;                  <span class="comment">// 所能容纳的 key-value 对极限（我将之称为“负载”）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;         <span class="comment">// 负载因子：默认 0.75</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 table 数组之外，我将源码中的常用字段也贴了出来。对于上面的代码，我们需要注意以下几点：</p><blockquote><ol><li>不了解 AbstractMap&lt;K,V&gt; 抽象类、Map&lt;K,V&gt;, Cloneable, Serializable 接口的请自行百度</li><li>transient 关键字：阻止本字段进行序列化（具体使用请自行百度）</li><li>threshold = length（哈希表长度） * loadFactor</li><li>modCount 记录的是 HashMap 内部结构发生变化的次数，内部结构发生变化指的是结构发生变化，例如 put 新键值对，但是某个 key 对应的 value 值被覆盖不属于结构变化。</li></ol></blockquote><p>有了对 table 数组的认识，那么我们用一张图来描述一下 HashMap 中的哈希表结构（来自 “美团点评技术团队” 侵删）：</p><p><img src="HashMap-table数组.jpg" alt="此处输入图片的描述"></p><p>了解了 HashMap 中的成员变量，再来看一下 HashMap 中定义的常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量，必须是2的幂。  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">//最大容量（必须是 2 的幂且小于 2 的 30 次方，传入容量过大将被这个值替换）  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 装载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// JDK1.8特有  </span></span><br><span class="line"><span class="comment">// 当 hash 值相同的记录超过 TREEIFY_THRESHOLD，会动态的使用一个专门的红黑树实现来代替链表结构，使得查找时间复杂度从 O(n) 变为 O(logn)  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// JDK1.8特有  </span></span><br><span class="line"><span class="comment">// 也是阈值，同上一个相反，当桶(bucket)上的链表数小于 UNTREEIFY_THRESHOLD 时红黑树转链表  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK1.8特有  </span></span><br><span class="line"><span class="comment">// 树的最小的容量，至少是 4 x TREEIFY_THRESHOLD = 32 然后为了避免(resizing 和 treeification thresholds) 设置成64  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="HashMap中的Node元素"><a href="#HashMap中的Node元素" class="headerlink" title="HashMap中的Node元素"></a><strong>HashMap中的Node元素</strong></h2><p>现在，我们关心的是 table 数组中 Node 元素的实现，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类、操纵了 Map 接口中的 Entry&lt;K,V&gt; 接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// key 所产生的 hash 值 （不变）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// key （不变）</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// value</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 指向下一个 Node 节点、（链地址法解决冲突）</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些方法都不可被重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 key 所产生的 hash 码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新值，返回旧值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个对象是否相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 是否都操作 Map.Entry 接口</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            <span class="comment">// 属于同一个类之后再对对象的属性进行比较</span></span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们需要注意：</p><blockquote><ol><li>Node 的实现是一个静态内部类，有关内部类与静态内部类的理解，请查看我的知乎回答：<a href="https://www.zhihu.com/question/28197253/answer/365692360" target="_blank" rel="noopener">为什么Java内部类要设计成静态和非静态两种？</a></li><li>hash 值与 key 的不变性：即使在 HashMap 中对 key 及 hash 做了final 关键字的约束，但是我们还是需要注意，最好使用不变对象作为 key。</li></ol></blockquote><p>首先我们来了解一下 final 关键字在基本类型与引用类型的使用上有什么不同？</p><blockquote><ol><li>当 final 修饰基本变量类型时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。</li><li>当 final 修饰引用类型变量时，final 只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但是这个对象(对象的非 final 成员变量的值可以改变)完全可以发生改变。</li></ol></blockquote><p>再来讨论，我们在使用 HashMap 时，为什么最好选用不可变对象作为 key。</p><p>来看一下选用可变对象作为 HashMap 的 key 有可能会造成什么影响？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;MutableKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        MutableKey key = <span class="keyword">new</span> MutableKey(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">        map.put(key, <span class="string">"Robin"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(map.get(key));</span><br><span class="line"></span><br><span class="line">        key.setI(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Robin</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>为什么最好不要使用可变对象作为 HashMap 的 key，结论：</p><blockquote><p>如果 key 对象是可变的，那么 key 的哈希值就可能改变。在 HashMap 中可变对象作为 key 会造成数据丢失。</p></blockquote><p>怎么解决？</p><blockquote><ol><li>在 HashMap 中，尽量使用 String、Integer 等不可变类型用作 key。</li><li>重写自定义类的 hashcode 方法，保证在成员变量改变的同时该对象的哈希值不变即可。（具体实现参见：<a href="http://www.cnblogs.com/0201zcr/p/4810813.html" target="_blank" rel="noopener">HashMap 的 key 可以是可变的对象吗？</a>）</li></ol></blockquote><hr><h2 id="HashMap中的put方法"><a href="#HashMap中的put方法" class="headerlink" title="HashMap中的put方法"></a><strong>HashMap中的put方法</strong></h2><h3 id="Hash值的计算"><a href="#Hash值的计算" class="headerlink" title="Hash值的计算"></a><strong>Hash值的计算</strong></h3><p>我们对 HashMap 的基本组成结构已经有了完整的认识，接下来我们分析 HashMap 中最常用的方法之一：<code>put()</code>。</p><p>直接上源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析 putVal 的源码之前，我们先来看看 <code>hash(key)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key 的 hash 值就是这样得到的，<code>key.hashCode()</code>是一个本地方法，具体实现在源码中并没有给出，但这并不是重点，我们需要注意的是在计算出 hash 值后，它又与本身的高 16 位进行了异或。（hash 值本身是 32 位）</p><p>为什么这样做？这样做的好处是什么呢？</p><blockquote><p>主要是从速度、功效、质量来考虑的，这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。在混合了原始 hashCode 值的高位和低位后，加大了低位的随机性，而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来，这就使得 hash 方法返回的值，具有更高的随机性，减少了冲突。</p></blockquote><p>下面举例说明，n 为 table 的长度（假设为 16）。</p><p><img src="HashMap-hash值的异或.jpg" alt="此处输入图片的描述"></p><h3 id="put方法的解析"><a href="#put方法的解析" class="headerlink" title="put方法的解析"></a><strong>put方法的解析</strong></h3><p>在分析 put 方法的源码之前，我们先来看一张有关 put 方法执行过程的图解，来自 <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">美团点评技术团队</a>，侵删~</p><p><img src="HashMap-put方法过程.png" alt="此处输入图片的描述"></p><p>根据图片我们再对 put 方法的执行流程做一个总结，方便等下阅读源码：</p><blockquote><ol><li>判断键值对数组 table 是否为空或为 null，否则执行 resize() 进行扩容；</li><li>根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i] == null，直接新建节点添加，转向 6，如果 table[i] 不为空，转向 3；</li><li>判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向 4，这里的相同指的是 hashCode 以及 equals；</li><li>判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向 5；</li><li>遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</li><li>插入成功后，判断实际存在的键值对数量 size 是否超过了负载 threshold，如果超过，进行扩容。</li></ol></blockquote><p>putVal 方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表为null || 哈希表的长度为 0（resize 也是一个经典的方法）</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 计算出 key 在哈希表中应该存储的位置（除留余数法，使用 &amp; 运算 比 % 运算更快）</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入的 key 在 HashMap 中已经存在（之后进行 value 的直接覆盖）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 产生冲突，当前节点为红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 普通节点，使用链地址法进行处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表（插入新节点之后，判断链表长度）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 当处理冲突的链节点数大于等于 8 的时候，转换红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 插入的 key 在 HashMap 中已经存在</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// key 已经存在，直接覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ++modCount;                 <span class="comment">// 记录 HashMap 内部结构发生变化的次数，用于快速失败机制</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();               <span class="comment">// 扩容</span></span><br><span class="line">        </span><br><span class="line">    afterNodeInsertion(evict);  <span class="comment">// 作用不明确</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 方法分析到这里基本上就结束了，但是我们同样有两个值得思考的问题：</p><blockquote><ol><li>哈希表索引定位：<code>(n - 1) &amp; hash</code>；</li><li>扩容机制：<code>resize()</code>。</li></ol></blockquote><p>关于红黑树与快速失败机制，不在这篇博客中进行讲述。</p><h3 id="索引定位"><a href="#索引定位" class="headerlink" title="索引定位"></a><strong>索引定位</strong></h3><p>你不觉得以<code>(n - 1) &amp; hash</code>这种方式定位元素在哈希表中的位置很有趣吗？</p><p>本质上，它还是“除留余数法”，只不过由于位运算的缘故，会比取模运算要高效许多。</p><p>但是使用这种方法有一个前提，就是哈希表 table 的长度 n 必须满足 2 幂次方，因为 n-1 对应的二进制就是前面全是 0，后面全是 1，相与后，只留下 hash 的后几位，正好在长度为 n 的数组下标范围内。</p><p>举个例子，假设 hash 值为 3，数组长度 n 为 16，那么我们使用取模运算得到：<code>3 % 16 = 3</code>，使用 &amp; 运算：<code>0011 &amp; (16 - 1)</code> 即 <code>0011 &amp; 1111 = 0011</code> 得到的还是 3。</p><p>而在 HashMap 中，哈希表 table 的默认初始值也为 16（源码如下）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a><strong>扩容机制</strong></h3><p>我们不谈红黑树，但必须探究包含在 put 方法中的 resize（扩容）机制。了解过 resize 方法之后，你会感叹其设计之巧妙！</p><p>首先，对扩容机制做一个简单的介绍：</p><blockquote><p>扩容(resize)就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。如果 `HashMap 的实际大小 &gt; 负载，则 HashMap 中的 table 的容量扩充为当前的一倍。容量翻倍后，重新计算每个 Node 的 index，将有限的元素映射到更大的数组中，减少 hash 冲突的概率。</p></blockquote><p>我将扩容机制分为了两部分：1. 创建新的 table 数组；2. 对元素进行 rehash。</p><p>创建新的 table 数组，过程还是比较简单的：</p><blockquote><p>（1）原 table 数组的大小已经最大，无法扩容，则修改 threshold 的大小为 Integer.MAX_VALUE。产生的效果就是随你碰撞，不再扩容；<br>（2）原 table 数组正常扩容，更新 newCap（新数组的大小） 与 newThr（新数组的负载）；<br>（3）原 table 数组为 null || length 为 0，则扩容使用默认值；<br>（4）原 table 数组的大小在扩容后超出范围，将 threshold 的大小更改为 Integer.MAX_VALUE。</p></blockquote><p>我们先截取第一部分（创建新数组）的源码进行研究：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充，随你去碰撞（将 threshold 设置为 Integer.MAX_VALUE，则不会产生扩容）</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 扩容成功，更新 newCap 与 newThr 的大小（2 倍扩展）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ！！！对应的哪种情况？</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// oldCap == 0 || oldTab == null</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩容失败（扩容后 newCap &gt;= MAXIMUM_CAPACITY）</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新负载的值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 的过程</span></span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK-1-7中的rehash"><a href="#JDK-1-7中的rehash" class="headerlink" title="JDK 1.7中的rehash"></a><strong>JDK 1.7中的rehash</strong></h3><p>直接阅读 JDK 1.8 中的 rehash 过程让人有点头大，为了便于理解，我们先来看看 JDK 1.7 中的 rehash ，总体来说，两个版本差别不大：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;                   <span class="comment">// src 引用了旧的 Entry 数组</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">// 遍历旧的 Entry 数组</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];             <span class="comment">// 取得旧 Entry 数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;                 <span class="comment">// 释放旧 Entry 数组的对象引用（for 循环后，旧的 Entry 数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);  <span class="comment">// 重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i];                   <span class="comment">// 头插法</span></span><br><span class="line">                newTable[i] = e;                        <span class="comment">// 将元素放在数组上</span></span><br><span class="line">                e = next;                               <span class="comment">// 访问下一个 Entry 链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便大家的理解，下面举个例子说明下扩容过程：</p><p><strong>注：JDK 1.7 中的 put 方法使用的是头插法进行新节点的插入，在 JDK 1.8 中，则使用的是尾插法（见上述源码）。对 JDK 1.7 put 方法感兴趣的同学可自行查阅有关资料。</strong></p><blockquote><p>假设我们的 hash 算法就是简单的用 key mod 一下表的大小。其中的哈希桶数组 table 的 size = 2，key = 3、7、5，put 顺序依次为 5、7、3（JDK 1.7 头插法）。在 mod 2 以后都冲突在 <code>table[1]</code> 这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小 size 大于 table 的负载（threshold）时进行扩容。接下来的步骤是哈希桶数组 resize 成 4，然后所有的 Node 重新 rehash 的过程。</p></blockquote><p><img src="HashMap-JDK1.7-rehash.png" alt="此处输入图片的描述"></p><h3 id="JDK-1-8中的rehash"><a href="#JDK-1-8中的rehash" class="headerlink" title="JDK 1.8中的rehash"></a><strong>JDK 1.8中的rehash</strong></h3><p>JDK 1.8 中的 rehash 过程与 JDK 1.7 大同小异，相比 JDK 1.7， 它主要对重新定位元素在哈希表中的位置做了优化：</p><blockquote><p>经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p></blockquote><p><img src="HashMap-扩容对索引位置的影响.png" alt="此处输入图片的描述"></p><p>table 在扩容之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：</p><p><img src="HashMap-扩容后确定index的值.png" alt="此处输入图片的描述"></p><p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引 + oldCap”。</p><p>了解了 JDK 1.8 相比 JDK 1.7 所做的优化之后，我们再看一下 JDK 1.8 中的 rehash 过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 的过程</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放旧 Node 数组的对象引用（for循环后，旧的 Node 数组不再引用任何对象）</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// oldTab[j] 只有一个元素，直接进行 rehash</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 原索引（头指针与尾指针）</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 原索引 + oldCap（头指针与尾指针）</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 对元素进行 rehash 的过程</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 原索引（尾插法）</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 原索引 + oldCap（尾插法）</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将建立的链表放到新 table 数组合适的位置上</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="HashMap的线程安全性"><a href="#HashMap的线程安全性" class="headerlink" title="HashMap的线程安全性"></a><strong>HashMap的线程安全性</strong></h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。那么为什么说 HashMap 是线程不安全的，下面举例子说明在并发的多线程使用场景中使用 HashMap 可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>其中，map 初始化为一个长度为 2 的数组，loadFactor = 0.75，threshold = 2 * 0.75 = 1，也就是说当 put 第二个 key 的时候，map 就需要进行 resize。</p><p>通过设置断点让线程1和线程2同时 debug 到 transfer 方法的首行。注意此时两个线程已经成功添加数据。放开 thread1 的断点至 transfer 方法的<code>Entry next = e.next</code> 这一行；然后放开线程2的的断点，让线程2进行 resize。结果如下图。</p><p><img src="HashMap-线程安全1.png" alt="此处输入图片的描述"></p><p>newTable 是局部变量，所以两个线程都有自己扩容后开辟的新的 table 数组。（对应图中橙色与紫色方块）</p><p>注意，由于 Thread1 执行到了<code>Entry next = e.next</code>这一行，因此 e 指向了 key(3)，而 next 指向了 key(7)，其在线程二 rehash 后，指向了线程二重组后的链表（rehash 之后，会将 newtable 赋值给 HashMap 的成员变量 table）。</p><p>接着下一部分：</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e（对应图中 thread1 的索引 3 处指向了 thread2 中 索引 3 处的 key = 3 的节点（thread2 中的 table 此时已经是成员变量了，因此共享））， 然后是 e = next，导致了 e 指向了 key(7)，而下一次循环的 next = e.next 导致了 next 指向了 key(3)。</p><p><img src="HashMap-线程安全2.png" alt="此处输入图片的描述"></p><p>当 next 指向 key(3) 的时候，e 为 key(7)，又经过一次循环后，结果如下图：</p><p><img src="HashMap-线程安全3.png" alt="此处输入图片的描述"></p><p>虚线也表示有引用指向 key(7)，只不过是想将 thread1 所拥有的 table 与 成员变量 table 区分开。</p><p>此时再更新 e 与 next 的值，e 为 key(3)，next 为 null，因此下一次循环就是最后一次循环。经过下一次循环之后，由于 e.next = newTable[i] 导致 key(3).next 指向了 key(7)，而此时的 key(7).next 已经指向了 key(3)，环形链表就此形成。结果如下图：</p><p><img src="HashMap-线程安全4.png" alt="此处输入图片的描述"></p><p>于是，当我们用线程一调用 map.get(11) 时，悲剧就出现了——无限循环。</p><p>博主将这块内容看了好几遍，确实不好理解，如果大家对这部分内容还有任何疑惑的话，欢迎在评论区进行提问~~</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>明白静态内部类 Node 的相关实现，清楚 HashMap 的底层实现是有关 Node 的 table 数组（哈希表）。</li><li>注意使用 HashMap 时最好使用不变的对象作为 key。</li><li>注意 HashMap 计算 key 的 hash 值时，使用了低位与高位异或的方式，返回最终的 hashcode。</li><li>了解 HashMap 中的定位方式：<code>(n - 1) &amp; hash</code>。</li><li>在 HashMap 中使用链地址法解决冲突，并且当链表的节点个数大于 8 的时候，会转换为红黑树。（JDK 1.8 新特性）</li><li>JDK 1.8 中使用尾插法进行 put 与 resize，JDK 1.7 中使用头插法进行 put 与 resize。</li><li>JDK 1.8 中的 rehash 过程不用重新计算元素的哈希值，因为元素的位置只有两种情况：原位置 与 原位置 + 原本哈希表的长度。</li><li>清楚多线程环境下使用 HashMap 可能会造成的一种错误—<strong>形成环形链表</strong>。</li></ol><p>在 <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a> 这篇文章中，美团点评技术团队还对 JDK 1.8 与 JDK 1.7 做了性能上的比较，有兴趣的同学可以自行查阅！</p><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap—美团点评技术团队</a></p><p><a href="https://blog.csdn.net/pfnie/article/details/51362287" target="_blank" rel="noopener">Java HashMap工作原理及实现(二)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java源码" scheme="https://blog.dhengyi.name/categories/Java%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码剖析" scheme="https://blog.dhengyi.name/tags/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="HashMap" scheme="https://blog.dhengyi.name/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java Web--XiyouLinux Group图书借阅平台的实现</title>
    <link href="https://blog.dhengyi.name/2018/03/13/Java-Web-XiyouLinux-Group%E5%9B%BE%E4%B9%A6%E5%80%9F%E9%98%85%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.dhengyi.name/2018/03/13/Java-Web-XiyouLinux-Group图书借阅平台的实现/</id>
    <published>2018-03-12T16:22:30.000Z</published>
    <updated>2019-07-16T17:10:25.020Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>源码地址：<a href="https://github.com/championheng/book-manager" target="_blank" rel="noopener">XiyouLinux Group 图书借阅平台</a></strong></p><p>项目地址中包含了一份README，因此对于项目的介绍省去部分内容。这篇博客，主要讲述项目中各个模块的实现细节。</p><hr><h2 id="项目概述及成果"><a href="#项目概述及成果" class="headerlink" title="项目概述及成果"></a><strong>项目概述及成果</strong></h2><p>首先将本项目使用到技术罗列出来：</p><blockquote><ol><li>使用Spring + Spring MVC进行后台开发</li><li>使用Bootstrap和jQuery框架进行前端开发</li><li>使用自定义注解与自定义的JdbcRowMapper简化JdbcTemplate对数据库的操作</li><li>使用腾讯云的对象存储服务进行图书照片的远程存储</li><li>使用MD5加密算法对用户密码在后台进行加密存储</li><li>使用过滤器进行一个会话中的身份校验</li><li>手动从Spring容器中获取bean</li><li>数据库设计中的诸多细节… …</li></ol></blockquote><p>由于前端开发是由团队中的其他人在负责，在加上博主对前端这块并不了解，因此本篇博客并不讨论有关第二点技术实现上的细节。</p><p>本项目如README中所述，在后期还有许多需要进行优化的地方。如果你对本项目感兴趣，不妨在GitHub中将其Star，以获得对本项目的持续关注～</p><p>至于项目成果大家可以阅读README，我在其中有贴上程序运行后的部分截图。或直接在本地搭建环境，运行此项目。过程中如有任何疑问，你也可以联系我：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spider_hgyi@outlook.com</span><br></pre></td></tr></table></figure><p>关于项目的整体架构我也不再描述，README中对其进行了补充。</p><hr><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a><strong>项目背景</strong></h2><p>这个项目的产生是有需求背景的。我们旨在为XiyouLinux Group开发一个管理图书借阅与归还的平台，从而能对小组中存在的大量书籍进行有效的管理。</p><p>我们的“老一届boss”刚开始给我们提出了第一版的需求，在此需求上，我们最初使用Servlet + JSP的方式进行后台开发。当然第一版由于太low我们对其进行了阉割。在我们学习了Spring与Spring MVC之后，就开始打算对其进行<strong>version 2.0</strong>的开发，并找来了一个专门学习前端的小可爱，才有了当前的图书借阅平台。</p><p>此图书借阅平台实现的功能模块请大家移步至<strong><a href="https://github.com/championheng/book-manager" target="_blank" rel="noopener">README</a></strong>进行查看。</p><p>接下来，我就按照每个模块的顺序，给大家讲一下本项目中用到的重点技术及其实现细节。</p><hr><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a><strong>实现细节</strong></h2><p><strong>注：博主只会挑几个重点模块去进行讲述，因此有些模块将不会涉及到。</strong></p><h3 id="模块一：登录模块"><a href="#模块一：登录模块" class="headerlink" title="模块一：登录模块"></a><strong>模块一：登录模块</strong></h3><p>登录模块分为三个部分，登录前主页面、登录后主页面以及登录框。</p><p>在这里我给大家截一张图看一下登录前后主页面的功能差距：    </p><p>登录前：<br><img src="图书借阅系统未登录主页.png" alt="这里写图片描述"></p><p>登录后：<br><img src="图书借阅系统登录后主页.png" alt="这里写图片描述"></p><p>我对登录后的页面只截取了和登录前有不同功能的区域。效果展示完毕，那么接下来就谈一谈这个模块中使用到的技术及其实现细节（只需考虑登录后页面实现的功能即可）。</p><h4 id="分页功能的实现"><a href="#分页功能的实现" class="headerlink" title="分页功能的实现"></a><strong>分页功能的实现</strong></h4><p>作为一个展示信息的Web页面，怎么可能没有分页功能呢，只不过是由于上图中的测试数据太少，没有给大家展现出来罢了。我们使用的是传统分页功能，而传统分页中又分为“真分页”与“假分页”：</p><blockquote><ul><li>真分页：每次从数据库中只返回当前页的数据，然后将数据交由视图进行渲染</li><li>假分页：从数据库中拿取所有需要或将要展示的数据，将数据交由视图，由视图实现数据的分页功能（JS实现或JSTL实现）</li></ul></blockquote><p>我们也很容易判断出哪种情况下何种方法最优：</p><blockquote><p>如果数据量较小，使用假分页的效果会更优；如果数据量庞大，使用真分页的效果更优。</p></blockquote><p>本项目使用的是“真分页”，我们接下来看一下实现思路与实现代码：</p><p>实现思路：</p><blockquote><ol><li>首先我们需要一个存储页面信息的Java Bean，也就是传统的Java对象</li><li>使用GET方法进行页面跳转请求，也就是说，我们可以从URL中得到当前页面是第几页</li><li>在后台中进行逻辑构造，将Java Bean中的实例字段进行部分（完全）填充</li><li>使用Java Bean所提供的页面信息，构造相应的SQL语句，拿到当前页数据</li><li>使用TreeMap对数据进行时间维度上的排序，最终返回给视图进行渲染</li></ol></blockquote><p>实现代码：</p><ul><li><strong>存储页面信息的Java Bean：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 12/27/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PagePO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> everyPage;      <span class="comment">// 每页显示记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalCount;     <span class="comment">// 总记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalPage;      <span class="comment">// 总页数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentPage;    <span class="comment">// 当前页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> beginIndex;     <span class="comment">// 查询起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasPrePage; <span class="comment">// 是否有上一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasNexPage; <span class="comment">// 是否有下一页</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PagePO</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PagePO</span><span class="params">(<span class="keyword">int</span> currentPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentPage = currentPage;</span><br><span class="line">        <span class="keyword">this</span>.everyPage = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">this</span>.beginIndex = (currentPage - <span class="number">1</span>) * everyPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PagePO</span><span class="params">(<span class="keyword">int</span> currentPage, <span class="keyword">int</span> everyPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentPage = currentPage;</span><br><span class="line">        <span class="keyword">this</span>.everyPage = everyPage;</span><br><span class="line">        <span class="keyword">this</span>.beginIndex = (currentPage - <span class="number">1</span>) * everyPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEveryPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> everyPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEveryPage</span><span class="params">(<span class="keyword">int</span> everyPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.everyPage = everyPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasPrePage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasPrePage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasPrePage</span><span class="params">(<span class="keyword">boolean</span> hasPrePage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasPrePage = hasPrePage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PagePO&#123;"</span> +</span><br><span class="line">                <span class="string">"everyPage="</span> + everyPage +</span><br><span class="line">                <span class="string">", totalCount="</span> + totalCount +</span><br><span class="line">                <span class="string">", totalPage="</span> + totalPage +</span><br><span class="line">                <span class="string">", currentPage="</span> + currentPage +</span><br><span class="line">                <span class="string">", beginIndex="</span> + beginIndex +</span><br><span class="line">                <span class="string">", hasPrePage="</span> + hasPrePage +</span><br><span class="line">                <span class="string">", hasNexPage="</span> + hasNexPage +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>从URL中得到当前页面是第几页，进行逻辑处理，填充上面Java Bean中的部分实例字段：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 1/21/18.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 登录后主页面对应的控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/auth"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = &#123;<span class="string">""</span>, <span class="string">"/"</span>, <span class="string">"/page/&#123;currentPagePre&#125;"</span>&#125;, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMainPage</span><span class="params">(Model model, @PathVariable(value = <span class="string">"currentPagePre"</span>, required = <span class="keyword">false</span>)</span> String currentPagePre,</span></span><br><span class="line"><span class="function">                              @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"tag"</span>, required = <span class="keyword">false</span>)</span> String labelIdPre) </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到当前页面的页码</span></span><br><span class="line">        <span class="keyword">int</span> currentPage = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentPagePre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentPage = Integer.parseInt(currentPagePre);</span><br><span class="line">        &#125;</span><br><span class="line">        PagePO pagePO = <span class="keyword">new</span> PagePO(currentPage);</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到当前分类下的数据总数（默认无分类）</span></span><br><span class="line">        <span class="keyword">if</span> (labelId == -<span class="number">1</span>) &#123;</span><br><span class="line">            bookCount = bookInfoService.getBookCount();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bookCount = bookInfoService.getBookCountByLabelId(labelId);</span><br><span class="line">        &#125;</span><br><span class="line">        pagePO.setTotalCount(bookCount);</span><br><span class="line">        pagePO.setTotalPage((bookCount % <span class="number">5</span> == <span class="number">0</span>) ? bookCount / <span class="number">5</span> : bookCount / <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据页面信息构造SQL语句，拿取当前页的数据</span></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对获取到的信息进行排序（按时间维度）</span></span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分页在后台中的逻辑处理主要是以下部分：</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 在这里添加分页的逻辑是因为JSP页面中EL表达式对算数运算的支持不太良好</span></span><br><span class="line">        model.addAttribute(<span class="string">"ELPageValue"</span>, (currentPage - <span class="number">1</span>) / <span class="number">5</span> * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当总页数大于5时，需要如下属性</span></span><br><span class="line">        <span class="keyword">if</span> (pagePO.getTotalPage() &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">            model.addAttribute(<span class="string">"isOneOfNextFivePage"</span>, (pagePO.getTotalPage() - <span class="number">1</span>) / <span class="number">5</span> * <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">            model.addAttribute(<span class="string">"reachNextFivePage"</span>, (currentPage + <span class="number">4</span>) / <span class="number">5</span> * <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前页面大于等于6页的时候, 需要显示"[...]"按钮--返回到前一个5页</span></span><br><span class="line">        <span class="keyword">if</span> (currentPage &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">            model.addAttribute(<span class="string">"returnPreFivePage"</span>, (currentPage - <span class="number">1</span>) / <span class="number">5</span> * <span class="number">5</span> - <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>根据页面信息构造SQL语句，拿取当前页的数据：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 11/23/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookInfoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcOperations jdbcOperations;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GET_ONE_PAGE_BOOKINFO = <span class="string">"SELECT * FROM book_info WHERE amount &gt; 0 ORDER BY pk_id DESC LIMIT ?, ?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BookInfoPO&gt; <span class="title">getBookByPage</span><span class="params">(PagePO page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcOperations.query(GET_ONE_PAGE_BOOKINFO,</span><br><span class="line">                JdbcRowMapper.newInstance(BookInfoPO.class), page.getBeginIndex(), page.getEveryPage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>对获取到的信息进行排序：（按时间维度）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookUserMapUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;BookInfoPO, String&gt; <span class="title">getBookInfo</span><span class="params">(List&lt;BookInfoPO&gt; bookInfoPOS, UserService userService)</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// TreeMap可对数据进行排序，当然BookInfoPO要实现Comparable接口，并重写compareTo方法</span></span><br><span class="line">        Map&lt;BookInfoPO, String&gt; bookMap = <span class="keyword">new</span> TreeMap&lt;BookInfoPO, String&gt;();</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bookMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>JSP页面中对应的分页实现（JSTL与EL）：</strong></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页的实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"index_pingination"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--当当前页面不是第一页的时候, 要显示 "首页"和 "&lt;&lt;"按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;pageInfo.currentPage != 1 &amp;&amp; pageInfo.totalPage != 0&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/1"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.currentPage-1&#125;"</span>&gt;</span>&amp;laquo;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/1?tag=$&#123;labelId&#125;"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.currentPage-1&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>&amp;laquo;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--当当前页面大于等于6页的时候, 要显示 "[...]"按钮--返回到前一个5页--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;pageInfo.currentPage &gt;= 6&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;returnPreFivePage&#125;"</span>&gt;</span>[...]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;returnPreFivePage&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>[...]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--显示当前页面所有应显示的页码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">varStatus</span>=<span class="string">"i"</span> <span class="attr">begin</span>=<span class="string">"$&#123;ELPageValue+1&#125;"</span> <span class="attr">end</span>=<span class="string">"$&#123;ELPageValue+5&#125;"</span> <span class="attr">step</span>=<span class="string">"$&#123;1&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;i.current &lt;= pageInfo.totalPage&#125;"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">&lt;!--当前页的超链接处理为不可点击--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;i.current == pageInfo.currentPage&#125;"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"pa_in"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">disabled</span>=<span class="string">"true"</span>&gt;</span>$&#123;pageInfo.currentPage&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;i.current != pageInfo.currentPage&#125;"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;i.current&#125;"</span>&gt;</span>$&#123;i.current&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;i.current&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>$&#123;i.current&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--如果不是最后一个五页中的页码, 要在后面显示[...]按钮--跳到下一个5页--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;pageInfo.currentPage &lt; isOneOfNextFivePage &amp;&amp; pageInfo.totalPage &gt;= 6&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;reachNextFivePage&#125;"</span>&gt;</span>[...]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;reachNextFivePage&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>[...]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--如果不是尾页, 要显示 "&gt;&gt;"和 "尾页"按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;pageInfo.currentPage != pageInfo.totalPage &amp;&amp; pageInfo.totalPage != 1 &amp;&amp; pageInfo.totalPage != 0&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.currentPage+1&#125;"</span>&gt;</span>&amp;raquo;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.totalPage&#125;"</span>&gt;</span>尾页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.currentPage+1&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>&amp;raquo;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.totalPage&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>尾页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="登录校验之过滤器实现"><a href="#登录校验之过滤器实现" class="headerlink" title="登录校验之过滤器实现"></a><strong>登录校验之过滤器实现</strong></h4><p>既然系统具有登录功能，那么我们就需要注意一些事情：</p><blockquote><ul><li>怎么防止未登录的用户访问登录后的页面</li><li>用户的cookie失效之后，我们需要引导用户进行重新登录</li></ul></blockquote><p>为了解决这两个问题，就需要引入过滤器。关于过滤器的功能与在Serlvet中的使用请移步至这一篇博客：<strong><a href="http://blog.csdn.net/championhengyi/article/details/72860657" target="_blank" rel="noopener">Servlet–Servlet进阶API、过滤器、监听器</a></strong></p><p>我现在要说的是过滤器在Spring框架中的使用，先看实现代码，并不难理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by dela on 1/18/18.</span><br><span class="line"> *</span><br><span class="line"> * @Description: 对于想要在Spring中使用过滤器, 就要继承OncePerRequestFilter</span><br><span class="line"> * OncePerRequestFilter, 顾名思义, 就是每个请求只通过一次这个过滤器</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class LoginFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,</span><br><span class="line">                                    FilterChain filterChain) throws ServletException, IOException &#123;</span><br><span class="line">        final String INDEX_PAGE = &quot;/&quot;;    // 未登录的URL</span><br><span class="line">        Object sessionId = null;</span><br><span class="line"></span><br><span class="line">        HttpSession session = httpServletRequest.getSession(false);</span><br><span class="line"></span><br><span class="line">// 未登录和Cookie失效的处理机制</span><br><span class="line">        if (session != null) &#123;</span><br><span class="line">            sessionId = session.getAttribute(&quot;uid&quot;);</span><br><span class="line">            if (sessionId != null) &#123;</span><br><span class="line">                filterChain.doFilter(httpServletRequest, httpServletResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果当前操作的用户没有登录令牌, 那就弹出弹框提示重新登录, 并跳转到未登录页面</span><br><span class="line">        if (session == null || sessionId == null) &#123;</span><br><span class="line">            // 设置response的字符集, 防止乱码</span><br><span class="line">            httpServletResponse.setCharacterEncoding(&quot;GBK&quot;);</span><br><span class="line"></span><br><span class="line">            PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">            String builder = &quot;&lt;script language=\&quot;javascript\&quot;&gt;&quot; +</span><br><span class="line">                    &quot;alert(\&quot;网页过期，请重新登录！\&quot;);&quot; +</span><br><span class="line">                    &quot;top.location=&apos;&quot; +</span><br><span class="line">                    INDEX_PAGE +</span><br><span class="line">                    &quot;&apos;;&quot; +</span><br><span class="line">                    &quot;&lt;/script&gt;&quot;;</span><br><span class="line"></span><br><span class="line">            out.print(builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有两个问题需要解决～</p><p><strong>1.什么叫做每个请求只通过一次这个过滤器。Filter不都是仅仅经过一次的吗？</strong> </p><p>不是的！不然就不会有这个类了。</p><p>此方式是为了兼容不同的Web容器，特意而为之，也就是说并不是所有的Web容器都像我们期望的只过滤一次，Servlet版本不同，表现也不同。 </p><p>如，Servlet2.3与Servlet2.4也有一定差异 ：</p><p>在Servlet-2.3中，Filter会过滤一切请求，包括服务器内部使用forward转发请求和<code>&lt;%@ include file=“/index.jsp”%&gt;</code>的情况。</p><p>到了Servlet-2.4中Filter默认下只拦截外部提交的请求，forward和include这些内部转发都不会被过滤，但是有时候我们需要forward的时候也要用到Filter。</p><p>因此，为了兼容各种不同的运行环境和版本，默认Filter继承OncePerRequestFilter是一个比较稳妥的选择。</p><p><strong>2.有关<code>HttpSession session = httpServletRequest.getSession(false)</code>的一点小知识。</strong></p><p>现实中我们经常会遇到以下3中用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">true</span>);</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>他们之间的区别是什么？</p><p>getSession(boolean create)意思是返回当前reqeust中的HttpSession，如果当前request中的HttpSession为null且create为true，就创建一个新的HttpSession，否则就直接返回null。</p><p><strong>简而言之：</strong> </p><blockquote><ul><li><code>request.getSession(true)</code>等同于如果当前没有HttpSession还要新创建一个HttpSession</li><li><code>request.getSession(false)</code>则等同于如果当前没有HttpSession就直接返回null</li></ul></blockquote><p>那么我们在使用的时候：</p><blockquote><ul><li>当向HttpSession中存储登录信息时，一般建议：<code>HttpSession session = request.getSession(true)</code></li><li>当从HttpSession中获取登录信息时，一般建议：<code>HttpSession session = request.getSession(false)</code></li></ul></blockquote><p><strong>还有一种更简洁的方式：</strong></p><blockquote><p>如果你的项目中使用到了Spring，对Session的操作就方便多了。如果需要在Session中取值，可以用WebUtils工具的getSessionAttribute(HttpServletRequestrequest, String name)方法，看看源码：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSessionAttribute</span><span class="params">(HttpServletRequest request, String name)</span> </span>&#123;  </span><br><span class="line">Assert.notNull(request, <span class="string">"Request must not be null"</span>);  </span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (session != <span class="keyword">null</span> ? session.getAttribute(name) : <span class="keyword">null</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebUtils.setSessionAttribute(request, “user”, User)；</span><br><span class="line">User user = (User) WebUtils.getSessionAttribute(request, “user”);</span><br></pre></td></tr></table></figure><h4 id="密码加密之MD5算法"><a href="#密码加密之MD5算法" class="headerlink" title="密码加密之MD5算法"></a><strong>密码加密之MD5算法</strong></h4><p>也许你没有听过MD5加密算法，但是有些人看到这个标题首先会产生一个疑问：<strong>对密码为什么还要加密？</strong></p><blockquote><p>主要是从安全性的角度上考虑，我们知道如果不对密码进行加密，那么密码将会在后台以明文的形式存储到数据库中。如果你的数据库足够安全，保证不会被别人所侵略，这当然没有什么问题。但事实是，我们不得不小心SQL注入等一系列数据库安全性问题，这时候，在数据库中所存储的有关个人隐私的信息，就显得十分重要了。因此将密码在后台进行加密，对于真正的企业级开发来说，是一件不可或缺的事情。</p></blockquote><p>解决掉这个疑惑之后，让我们一起来看看MD5加密算法的核心思想及代码实现。</p><p>好吧，博主看了一些关于MD5的核心思想，并没有看懂，先在这里给大家放一篇讲述MD5加密算法实现原理的博客链接：<strong><a href="http://blog.csdn.net/forgotaboutgirl/article/details/7258109" target="_blank" rel="noopener">MD5算法原理</a></strong> — 博客中有少量错误，大家理性阅读。</p><p>关于MD5在Java中的使用，则要简单许多：</p><blockquote><ol><li>通过MessageDigest.getInstance()确定加密算法，MessageDigest不止提供MD5</li><li>调用<code>update(byte[] input)</code>对指定的byte数组更新摘要</li><li>执行<code>digest()</code>方法进行哈希计算。在调用此方法之后，摘要被重置</li><li>对第三步返回的结果进行处理：128位级联值（16组有符号字节值）—&gt;将每组10进制数字转换为16进制，并生成相应字符串</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 上午11:53 18-3-11.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: MD5加密算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">codeByMD5</span><span class="params">(String inStr)</span> </span>&#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到MD5加密算法实例</span></span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用指定的byte数组更新摘要</span></span><br><span class="line">        <span class="keyword">assert</span> md5 != <span class="keyword">null</span>;</span><br><span class="line">        md5.update(inStr.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过执行诸如填充之类的最终操作完成哈希计算。返回值是16个有符号字节数，共128位</span></span><br><span class="line">        <span class="keyword">byte</span>[] md5Bytes = md5.digest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于存储最终得到的32位小写16进制字符串</span></span><br><span class="line">        StringBuilder hexValue = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将其中的字节转换为16进制字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> md5Byte : md5Bytes) &#123;</span><br><span class="line">        <span class="comment">// 将得到的有符号字节转换为无符号字节</span></span><br><span class="line">            <span class="keyword">int</span> val = ((<span class="keyword">int</span>) md5Byte) &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">16</span>) &#123;</span><br><span class="line">                hexValue.append(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hexValue.append(Integer.toHexString(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hexValue.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码生成小写16进制字符串，代码运行结果经过本人与在线MD5加密网站生成的结果进行了对比，测试无误，可放心使用。</p><h3 id="模块二：标签页模块"><a href="#模块二：标签页模块" class="headerlink" title="模块二：标签页模块"></a><strong>模块二：标签页模块</strong></h3><p>效果展示：<br><img src="图书借阅系统标签显示页面.png" alt="这里写图片描述"></p><h4 id="目录树结构的数据库设计"><a href="#目录树结构的数据库设计" class="headerlink" title="目录树结构的数据库设计"></a><strong>目录树结构的数据库设计</strong></h4><p>在标签页这一模块中，我们主要对在MySQL数据库中如何存储一个树状结构而进行一个简单的介绍。</p><p>我在项目中设计的存储结构并不高效，是一种最简单且基本的实现。在网上有很多结构良好且性能高效的树形结构的数据库表设计，大家可以查阅一些相关资料。</p><p>对比上面的效果展示图，我的标签分类其实就是三层树深度：</p><blockquote><ol><li>根节点（唯一）</li><li>一级标签（大数据与云计算… …）（多节点）</li><li>二级标签（Hadoop、Spark等等）（多节点）</li></ol></blockquote><p>可以看到，虽然树的深度只有3，但其每个父节点都拥有多个子节点。</p><p>既然已经将标签信息组织成多路树结构，那么数据库结构设计如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pk_id              name              parent_id</span><br></pre></td></tr></table></figure><p>pk_id用来标识此标签名的唯一索引，name就是标签名，parent_id则是此标签其父节点对应的pk_id。</p><p>我将一级标签的parent_id都设置为0，表明一级标签的父节点提供空数据，标签页只需要一级标签及二级标签的信息。</p><p>如此，我们便可查找任一一级标签信息及其所拥有的二级标签信息。</p><p>至于标签页面中的显示形式，我们在后台只要将每个一级标签作为Map数据结构中的键，当前一级标签所拥有的二级标签作为对应的值，然后将Map作为model返回给视图进行解析渲染即可。</p><p>代码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: spider_hgyi</span><br><span class="line"> * @Date: Created in 下午1:36 17-11-20.</span><br><span class="line"> * @Modified By:</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/auth&quot;)</span><br><span class="line">public class TagsController &#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/tags&quot;, method = RequestMethod.GET)</span><br><span class="line">    public String showLabel(Model model) &#123;</span><br><span class="line">    // 得到所有的一级标签（parent_id == 0）</span><br><span class="line">        List&lt;BookLabelPO&gt; parentLabels = bookLabelRepository.getBookLabelByParentId(0);</span><br><span class="line">        // 得到所有的二级标签（parent_id != 0）</span><br><span class="line">        List&lt;BookLabelPO&gt; childrenLabels = bookLabelRepository.getChildrenLabelsByParentId(0);</span><br><span class="line">        // 返回给视图的model</span><br><span class="line">        Map&lt;String, Map&lt;Integer, String&gt;&gt; labelsName = new HashMap&lt;String, Map&lt;Integer, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 找到每个一级标签所拥有的二级标签</span><br><span class="line">        for (BookLabelPO parentLabel : parentLabels) &#123;</span><br><span class="line">            Map&lt;Integer, String&gt; childLabelsName = new HashMap&lt;Integer, String&gt;();</span><br><span class="line">            for (BookLabelPO childrenLabel : childrenLabels) &#123;</span><br><span class="line">                if (parentLabel.getPkId() == childrenLabel.getParentId()) &#123;</span><br><span class="line">                    childLabelsName.put(childrenLabel.getPkId(), childrenLabel.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            labelsName.put(parentLabel.getName(), childLabelsName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将存储标签信息的Map对象添加进model对象</span><br><span class="line">        model.addAttribute(&quot;labelsName&quot;, labelsName);</span><br><span class="line"></span><br><span class="line">        return &quot;alltags&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块三：上传书籍模块"><a href="#模块三：上传书籍模块" class="headerlink" title="模块三：上传书籍模块"></a><strong>模块三：上传书籍模块</strong></h3><h4 id="腾讯云存储服务—图片存储"><a href="#腾讯云存储服务—图片存储" class="headerlink" title="腾讯云存储服务—图片存储"></a><strong>腾讯云存储服务—图片存储</strong></h4><p>由于有些书籍会上传封面照片，而腾讯云又提供了对象存储服务，因此我并没有选择将图片存储至本地或云服务器上，而是使用了腾讯云所提供的云对象存储。</p><p>使用云对象存储，腾讯所提供的开发者文档：<strong><a href="https://cloud.tencent.com/document/product/436/10199" target="_blank" rel="noopener">对象存储 — SDK 文档</a></strong></p><h4 id="手动获取bean"><a href="#手动获取bean" class="headerlink" title="手动获取bean"></a><strong>手动获取bean</strong></h4><p>Spring MVC给我们提供了文件上传功能（两种使用形式）：</p><blockquote><ol><li>给控制器方法参数上添加@RequestPart注解，参数类型为字节数组</li><li>给控制器方法参数上添加@RequestPart注解，参数类型为Part</li></ol></blockquote><p>但是我在使用Spring MVC所提供的文件上传功能时，始终无法获取到对应的字节流对象。我查阅了大量的相关文档，并仔细的检查了所写的代码，最终也没有找到问题的根源。因此在项目中，对于书籍图片的处理，我使用了Servlet所提供的原生API：<code>request.getPart()</code>。</p><p>既然使用了Servlet所提供的原生API，因此图书上传模块所对应的控制器便继承于HttpServlet。在继承了HttpServlet之后，还是出现了很多问题—怎么使原生Servlet与Spring MVC的bean之间进行协作？</p><p>在使用了HttpServlet之后，便无法给此Servlet添加@controller注解，也就无法使用依赖注入。大概的原因是Servlet由Web容器管理，而bean由Spring容器管理。在这种情况下，我对bean进行了手动获取。</p><p>手动获取bean的代码我写到了Servlet的init方法中，对于此方法我不在这里进行描述。</p><p>博主之所以将这一技术细节提取出来，也是想给那些遇到同样问题的朋友们提供一些思路。</p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 下午8:14 17-12-3.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/auth/upload.do"</span>)</span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewBookController</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NewBookController.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BookInfoService bookInfoService;</span><br><span class="line">    <span class="keyword">private</span> BookLabelService bookLabelService;</span><br><span class="line">    <span class="keyword">private</span> BookRelationLabelService bookRelationLabelService;</span><br><span class="line">    <span class="keyword">private</span> COSStorage cosStorage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动获取bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 得到Servlet应用上下文</span></span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">// 得到Web应用上下文</span></span><br><span class="line">        WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">        <span class="comment">// 根据beanId获取相应bean</span></span><br><span class="line">        bookInfoService = (BookInfoService) ctx.getBean(<span class="string">"bookInfoServiceImpl"</span>);</span><br><span class="line">        bookLabelService = (BookLabelService) ctx.getBean(<span class="string">"bookLabelServiceImpl"</span>);</span><br><span class="line">        bookRelationLabelService = (BookRelationLabelService) ctx.getBean(<span class="string">"bookRelationLabelServiceImpl"</span>);</span><br><span class="line">        cosStorage = (COSStorage) ctx.getBean(<span class="string">"cosStorage"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块四：对Jdbc-RowMapper的简易封装"><a href="#模块四：对Jdbc-RowMapper的简易封装" class="headerlink" title="模块四：对Jdbc RowMapper的简易封装"></a><strong>模块四：对Jdbc RowMapper的简易封装</strong></h3><p>本项目的架构采用<code>Spring + Spring MVC + JdbcTemplate</code>，其中Spring + Spring MVC对应ssm框架中的ss，我们并没有使用Mybatis框架。Spring提供了相应的JDBC框架—JdbcTemplate。</p><p>对于JdbcTemplate的使用如下（在使用之前需要进行相关的Spring配置）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-11-7.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcSpitterRepository</span> <span class="keyword">implements</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line">    JdbcOperations jdbcOperations;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String INSERT_SPITTER = <span class="string">"INSERT INTO spitter (username, password, "</span> +</span><br><span class="line">            <span class="string">"firstname, lastname) VALUES (?, ?, ?, ?)"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUERY_SPITTER_BY_USERNAME = <span class="string">"SELECT * FROM spitter "</span> +</span><br><span class="line">            <span class="string">"WHERE username = ?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcSpitterRepository</span><span class="params">(JdbcOperations jdbcOperations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcOperations = jdbcOperations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库插入操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">        jdbcOperations.update(INSERT_SPITTER, spitter.getUsername(), spitter.getPassword(),</span><br><span class="line">                spitter.getFirstName(), spitter.getLastName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> spitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库查询操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spitter&gt; <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcOperations.query(QUERY_SPITTER_BY_USERNAME,</span><br><span class="line">                <span class="keyword">new</span> SpitterRowMapper(), username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SpitterRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Spitter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spitter <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spitter(</span><br><span class="line">                    resultSet.getInt(<span class="string">"id"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"username"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"password"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"firstname"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"lastname"</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述代码有几点说明：</p><blockquote><ol><li>JdbcOperations是一个接口，定义了JdbcTemplate所实现的操作。通过注入JdbcOperations从而使JdbcSpitterRepository与JdbcTemplate保持了松耦合</li><li>使用RowMapper对Spitter对象进行填充，最后得到从数据库中查询到的结果集合</li><li>使用JdbcTemplate极大的方便了对JDBC的操作，没有了创建JDBC连接和语句的代码，也没有了异常处理的代码，只剩下单纯的数据插入与查询代码</li></ol></blockquote><ul><li><strong>那么我们为何还要对RowMapper进行封装？</strong></li></ul><p>由上面的代码可知，每当我们从相同（不同）的数据库表中得到不同的数据时，就有可能创建不同的RowMapper。那么问题就凸显出来了，我们的系统中必定有多张数据库表，也必定要从各个表中查询不同的数据，那么就会创建大量不同的RowMapper类，这些RowMapper散落于项目中的各个角落。这样的设计，显然很失败。</p><ul><li><strong>我们自己封装的JdbcRowMapper（与Spring所提供的RowMapper所区分）有什么功能呢？</strong></li></ul><p>我们尝试对RowMapper进行封装，以提供这样的功能：对于不同的对象，RowMapper在从数据库中查询到相应的数据之后，都可对其相应的字段进行自动填充。</p><p><strong>我们先来看一下它的使用效果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbcOperations.query(GET_BOOK_BY_LABEL_AND_PAGE_TYPESCONTROLLER,</span><br><span class="line">                        JdbcRowMapper.newInstance(BookInfoPO.class), labelId,pagePO.getBeginIndex(), pagePO.getEveryPage());</span><br><span class="line">                        </span><br><span class="line">jdbcOperations.query(QUERY_CHILDREN_LABELS_BY_PARENT_ID, JdbcRowMapper.newInstance(BookLabelPO.class), parentId);</span><br></pre></td></tr></table></figure><p>可以看到，我们不必再为不同的PO对象编写不同的RowMapper。</p><p>现在开始分析它的具体实现：</p><p>根据上述代码，我们先来分析它的<code>newInstance</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">JdbcRowMapper&lt;T&gt; <span class="title">newInstance</span> <span class="params">(Class&lt;T&gt; mappedClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JdbcRowMapper&lt;T&gt;(mappedClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个泛型方法，返回值是泛型类：<code>JdbcRowMapper&lt;T&gt;</code>，方法参数是泛型Class对象。这个方法调用了JdbcRowMapper如下的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcRowMapper</span><span class="params">(Class&lt;T&gt; mappedClass)</span> </span>&#123;</span><br><span class="line">    initialize(mappedClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟踪，initialize方法：（核心方法之一）</p><ul><li><strong>initialize方法的作用：</strong></li></ul><blockquote><ul><li>在说initialize方法的作用之前，我们先要知道什么是PO。之前我所使用的Java Bean为什么都以PO为后缀？简单来说，这是Java Bean与持久化层之间的一层规约。这层规约可以简单的概述为：数据库中表字段的命名方式都以下划线分割单词，而Java Bean中则是以驼峰式命名，并且，每个PO对象基本对应一张数据库表。就拿BookInfoPO中的<code>private int pkId</code>属性来说，它对应的就是数据库表<code>book_info</code>中的<code>pk_id</code>字段。这里涉及到了数据库建表时的规范，我们之后再说。目前你就先这样记住。</li><li>有了这层规约，我们在封装RowMapper的时候，就可以通过一些逻辑代码，将Java Bean中的实例字段名转换为数据库表中相应的字段名，也就为我们的下一个方法：把从数据库表中读取到的数据填充到Java Bean中的相应字段做了铺垫。</li></ul></blockquote><ul><li><strong>initialize方法的实现思路：</strong></li></ul><blockquote><ol><li>通过<code>BeanUtils.getPropertyDescriptor()</code>得到当前JavaBean(mappedClass对应的PO)的PropertyDescriptor数组</li><li>对PropertyDescriptor数组进行遍历，拿到每一个实例变量的变量名</li><li>对变量名做相应转换，转为对应的数据库表字段名</li><li>将这些名字保存在合适的数据结构中，供接下来的mapRow方法使用（JdbcRowMapper中真正从数据库中读取所需数据的方法）</li></ol></blockquote><p>有了实现思路，那么接下来看代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Class&lt;T&gt; mappedClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以下三个变量都是实例变量，在这里进行初始化</span></span><br><span class="line">    <span class="keyword">this</span>.mappedClass = mappedClass;</span><br><span class="line">    <span class="keyword">this</span>.mappedFileds = <span class="keyword">new</span> HashMap&lt;String, PropertyDescriptor&gt;();</span><br><span class="line">    <span class="keyword">this</span>.mappedProperties = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 通过BeanUtils.getPropertyDescriptor()得到当前JavaBean(mappedClass对应的PO)的PropertyDescriptor数组，PropertyDescriptors类是Java内省类库的一个类。</span></span><br><span class="line"><span class="comment">     * Java JDK中提供了一套API用来访问某个对象属性的getter/setter方法，这就是内省。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取bean的所有属性（也就是实例变量）列表   </span></span><br><span class="line">    PropertyDescriptor[] propertyDescriptors = BeanUtils.getPropertyDescriptors(mappedClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历属性列表</span></span><br><span class="line">    <span class="keyword">for</span> (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123;</span><br><span class="line">        <span class="comment">// propertyDescriptor.getWriteMethod()获得用于写入属性值的方法</span></span><br><span class="line">        <span class="keyword">if</span> (propertyDescriptor.getWriteMethod() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 得到此属性名（变量名）</span></span><br><span class="line">            String name = propertyDescriptor.getName();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过反射取得Class里名为name的字段信息</span></span><br><span class="line">                Field field = mappedClass.getDeclaredField(name);</span><br><span class="line">                <span class="keyword">if</span> (field != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 得到该属性(field)上存在的注解值（下一个代码给出示例）</span></span><br><span class="line">                    Column column = field.getAnnotation(Column.class);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果取得的column值不为null, 那就给name赋值column.name</span></span><br><span class="line">                    <span class="keyword">if</span> (column != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        name = column.name();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将&lt;属性名字, 属性&gt;加入mappedFileds中</span></span><br><span class="line">            <span class="keyword">this</span>.mappedFileds.put(lowerCaseName(name), propertyDescriptor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不使用自定义注解，使用代码将所得name转换为对应数据库表字段</span></span><br><span class="line">            String underscoredName = underscoreName(name);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果两个不等，则将nderscoredName也添加进mappedFileds，相当于一种容错机制</span></span><br><span class="line">            <span class="keyword">if</span> (!lowerCaseName(name).equals(underscoredName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mappedFileds.put(underscoredName, propertyDescriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将属性名添加至mappedProperties</span></span><br><span class="line">            <span class="keyword">this</span>.mappedProperties.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是initialize方法。接下来看一下其中所用到的自定义注解，也就是对这一行代码的解释：<code>Column column = field.getAnnotation(Column.class)</code></p><ul><li><strong>定义自定义注解：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dela</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">@Retention</span>是JDK的元注解, 当RetentionPolicy取值为RUNTIME的时候,</span></span><br><span class="line"><span class="comment"> * 意味着编译器将Annotation记录在class文件中, 当Java文件运行的时候,</span></span><br><span class="line"><span class="comment"> * JVM也可以获取Annotation的信息, 程序可以通过反射获取该Annotation的信息.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="comment">// @Target也是JDK的一个元注解, 当ElementType取不同值的时候, 意味着这个注解的作用域也不同,</span></span><br><span class="line"><span class="comment">// 比如, 当ElementType取TYPE的时候, 说明这个注解用于类/接口/枚举定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    <span class="comment">// 数据库中表的名字</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 12/20/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="comment">// 数据库中的表上的字段的名字</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>自定义注解在BookInfoPO中的应用：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 11/22/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 书籍信息表</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"book_info"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookInfoPO</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BookInfoPO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"pk_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pkId;                   <span class="comment">// 无意义主键</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"ugk_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String ugkName;             <span class="comment">// 书名(组合索引)</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"author"</span>)</span><br><span class="line">    <span class="keyword">private</span> String author;              <span class="comment">// 作者</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"ugk_uid"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ugkUid;                 <span class="comment">// 所有者(即用户表里的id)(组合索引)</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"amount"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amount;                 <span class="comment">// 数量</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"upload_date"</span>)</span><br><span class="line">    <span class="keyword">private</span> String uploadDate;          <span class="comment">// 上传时间</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"book_picture"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bookPicture;         <span class="comment">// 书籍照片</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"describ"</span>)</span><br><span class="line">    <span class="keyword">private</span> String describ;             <span class="comment">// 书籍描述</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookInfoPO</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在initialize方法中还有一个<code>underscoreName()</code>：（此方法就不打注解了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">underscoreName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    result.append(lowerCaseName(name.substring(<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; name.length(); i++) &#123;</span><br><span class="line">        String s = name.substring(i, i + <span class="number">1</span>);</span><br><span class="line">        String slc = lowerCaseName(s);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!s.equals(slc)) &#123;</span><br><span class="line">            result.append(<span class="string">"_"</span>).append(slc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok，接下来我们继续探究核心方法二：<code>mapRow()</code></p><p>刚说过initialize方法是为了使mapRow方法可以把从数据库表中读取到的结果填充到Java Bean相应的字段上而做的一个铺垫。那么mapRow必定实现了如下功能：</p><blockquote><ol><li>从数据库表中读取结果集</li><li>将结果集中的元素填充到相应的Java Bean中（别忘了initialize方法已经帮我们将Java Bean中的实例变量名转换为了数据库表中相应的字段名）</li></ol></blockquote><p>明白了mapRow中实现的大致功能，那么我们直接来看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> rowNumber)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// Spring的断言表达式, 传入的Java Bean的Class对象不能为空</span></span><br><span class="line">    Assert.state(<span class="keyword">this</span>.mappedClass != <span class="keyword">null</span>, <span class="string">"Mapped class was not specified"</span>);</span><br><span class="line">        <span class="comment">// 实例化一个Java Bean</span></span><br><span class="line">        T mappedObject = BeanUtils.instantiate(<span class="keyword">this</span>.mappedClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BeanWrapper可以设置及访问被包装对象的属性值</span></span><br><span class="line">        BeanWrapper beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(mappedObject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从resultSet中拿到有关此数据库表的元数据（字段名称、类型以及数目等）</span></span><br><span class="line">        ResultSetMetaData resultSetMetaData = resultSet.getMetaData();</span><br><span class="line">        <span class="comment">// 得到此数据库表的字段数目</span></span><br><span class="line">        <span class="keyword">int</span> columnCount = resultSetMetaData.getColumnCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt;= columnCount; index++) &#123;</span><br><span class="line">            <span class="comment">// 得到数据库表中当前字段名</span></span><br><span class="line">            String column = JdbcUtils.lookupColumnName(resultSetMetaData, index);</span><br><span class="line">            String field = lowerCaseName(column.replaceAll(<span class="string">" "</span>, <span class="string">""</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据数据库表中的字段名拿到Java Bean中对应实例字段属性的描述</span></span><br><span class="line">            PropertyDescriptor propertyDescriptor = <span class="keyword">this</span>.mappedFileds.get(field);</span><br><span class="line">            <span class="keyword">if</span> (propertyDescriptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 得到该field所对应的数据库表中字段所对应的值（下一个代码给出示例）</span></span><br><span class="line">                    Object value = getColumnValue(resultSet, index, propertyDescriptor);</span><br><span class="line"></span><br><span class="line">                    ... ...</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 将得到值填充到Java Bean中相应的实例变量上</span></span><br><span class="line">                        beanWrapper.setPropertyValue(propertyDescriptor.getName(), value);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">                        ... ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NotWritablePropertyException ex) &#123;</span><br><span class="line">                    ... ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有发现相应实例字段的属性描述</span></span><br><span class="line">                ... ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mappedObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getColumnValue()的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到数据库表中字段(column)对应的值(value)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getColumnValue</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> index, PropertyDescriptor propertyDescriptor)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JdbcUtils.getResultSetValue(resultSet, index, propertyDescriptor.getPropertyType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a><strong>设计数据库</strong></h2><p>由于博主负责了本项目的数据库设计，因此在这里有一点心得想分享给大家。</p><p>首先是MySQL的建表规范（当然并不绝对）：</p><blockquote><ul><li>主键一律无意义，就算有意义，也必须是以后不会被更新，修改并且是自增的字段。命名规范一律是pk_id,数据类型为int unsigned,字段not null。</li><li>唯一索引命名一律以uk_为前缀，唯一索引并不以提高查询速率为主要目的，主要是进行唯一性约束。</li><li>唯一组合索引命名一律以ugk_为前缀，目的同上，注意最左前缀的问题。<br>由于主键一律设置的是无意义的自增字段，所以对于有外键约束的字段，只设置了级联删除（只更新父表的主键会存在外键约束）。</li><li>日期字段的数据类型一律为datetime。</li><li>所有表的字段设置为not null，数字默认值为0,字符串默认值为’’，datetime没有设置默认值，因此在后台必须处理时间问题。</li></ul></blockquote><p>当初在设计本项目的数据库时分别使用了主键与外键约束、唯一索引与组合索引、级联更新与级联删除等技术。对于这些技术的讲解在博主所置顶的几篇博客中就可以看到，因此不再讲解。</p><p>至于数据库结构与数据的SQL文件，在本人GitHub的README中有提供，感兴趣的可以去下载，源码地址在本篇博客开始已经给出～</p><p>Ok，XiyouLinux Group图书借阅平台的实现分析至此结束！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="后端开发" scheme="https://blog.dhengyi.name/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="项目" scheme="https://blog.dhengyi.name/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--详解DNS域名系统</title>
    <link href="https://blog.dhengyi.name/2018/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AF%A6%E8%A7%A3DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/"/>
    <id>https://blog.dhengyi.name/2018/03/05/计算机网络-详解DNS域名系统/</id>
    <published>2018-03-05T10:01:22.000Z</published>
    <updated>2019-07-16T18:13:27.735Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>注：本篇博客大部分内容截选自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">DNS 原理入门</a>一文。</strong>其中少部分内容是博主自己的理解。</p><h2 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a><strong>什么是DNS</strong></h2><p>我们知道，网络本身只能理解数字形式的地址，也就是IP地址。但是直观的IP地址毫无规律，很难让人记住，并且如果使用IP地址浏览一个公司的主页，意味着这家公司一旦将主页移动到了另一台机器上，且该机器具有不同的IP地址，那么必须将该机器的IP地址通知给每一个人。因此人们引入了类似于<code>www.baidu.com</code>这样的域名。而要将域名转换为对应的IP地址，就需要<strong>DNS服务器（Domain Name System）</strong>。</p><p>在早期的ARPANET时代，只有一个简单的hosts.txt文件，它列出了所有的计算机名字和其对应的IP地址。每天晚上，所有的主机都从一个维护此文件的站点将该文件取回，然后在本地进行更新。对于一个拥有几百台大型分时机器的网络而言，这种方法工作的相当好。</p><p>然而当几百万台PC连接到互联网以后，问题就出现了。首先这个文件会变的非常大，并且主机名冲突的现象将会频繁发生。为了解决这些问题，DNS服务器应运而生。</p><p><strong>注：DNS服务器和域名服务器同义。</strong></p><hr><h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a><strong>查询过程</strong></h2><p>虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。</p><p>工具软件dig可以显示整个查询过程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig math.stackexchange.com</span><br></pre></td></tr></table></figure><p>上面的命令会输出六段信息：</p><p><img src="DNS查询过程.png" alt="这里写图片描述"></p><p><code>;;</code>开头的表示这一行是注释。</p><p><strong>1. 第一段是查询参数和统计。可以看到dig命令的一些基本信息，如版本和参数说明。还有一些对查询结果的简单统计：</strong></p><p><img src="DNS查询过程1.png" alt="这里写图片描述"></p><p><strong>2. 第二段是查询内容：</strong></p><p><img src="DNS查询过程2.png" alt="这里写图片描述"></p><p>上面结果表示，查询域名math.stackexchange.com的A记录，A是address的缩写，也就是查询域名的IP地址。</p><p><strong>3. 第三段是DNS服务器的答复：</strong></p><p><img src="DNS查询过程3.png" alt="这里写图片描述"></p><p>我们将上述图片中的每一行记录称为<strong>域名资源记录</strong>，DNS数据库就是由这些记录所构成。最常见的资源记录就是它的IP地址，但除此之外还有许多其他种类的资源记录。当解析器把一个域名传给DNS时，它能获得的DNS返回结果就是与该域名相关联的资源记录。</p><p>因此，<strong>DNS的基本功能是将域名映射至资源记录</strong>。</p><p>我们来看一下资源记录的格式：<strong>五元组</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Domain_name    Time_to_live    Class    Type    Value</span><br></pre></td></tr></table></figure><blockquote><ul><li>Domain_name（域名）：这条资源记录属于哪一个域</li><li>Time_to_live（生存期）：TTL值，表示缓存时间，在上图中就是600秒之内不用重新查询</li><li>Class（类别）：对于Internet信息，它总是IN。对于非Internet信息，则可以使用其他的代码，但实际很少见</li><li>Type（类型）：指出了本条资源记录是什么样的类型。DNS有许多类型，我们在<a href="#DNS的记录类型">DNS的记录类型</a>进行详细讨论</li><li>Value：可以是数字、域名、ASCII字符串，其取决于资源记录的类型</li></ul></blockquote><p>那么上面结果就显示，math.stackexchange.com有四个A记录，即四个IP地址。600是TTL值，表示缓存时间，即600秒之内不用重新查询。</p><p><strong>4. 第四段显示stackexchange.com的NS记录（Name Server的缩写），即哪些服务器负责管理stackexchange.com的DNS记录：</strong></p><p><img src="DNS查询过程4.png" alt="这里写图片描述"></p><p>上面结果显示stackexchange.com共有四条NS记录，即四个域名服务器，向其中任一台查询就能知道math.stackexchange.com的IP地址是什么。</p><p>这里有一些分级查询的内容，我们稍后在讲。我们此时应该注意为什么<code>stackexchange.com</code>有四台域名服务器？</p><p>在理论上，一台域名服务器就足以。但实际上，这台服务器有可能会因负载过重而变得毫无用处。而且，一旦它停机，则域名必然会解析失败。这就是单个信息源所带来的问题。</p><p><strong>5. 第五段是上面四个域名服务器的IP地址，这是随着前一段一起返回的：</strong></p><p><img src="DNS查询过程5.png" alt="这里写图片描述"></p><p><strong>6. 第六段是DNS服务器的一些传输信息：</strong></p><p><img src="DNS查询过程6.png" alt="这里写图片描述"></p><p>上面结果显示，本机的DNS服务器是192.168.1.253，查询端口是53（DNS服务器的默认端口），以及回应长度是305字节。</p><p>如果不想看到这么多内容，可以使用+short参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dig +short math.stackexchange.com</span><br><span class="line"></span><br><span class="line">151.101.129.69</span><br><span class="line">151.101.65.69</span><br><span class="line">151.101.193.69</span><br><span class="line">151.101.1.69</span><br></pre></td></tr></table></figure><p>上面命令只返回<code>math.stackexchange.com</code>对应的4个IP地址（即A记录）。</p><hr><h2 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a><strong>DNS服务器</strong></h2><p>下面我们根据前面这个例子，一步步还原，本机到底怎么得到域名math.stackexchange.com的IP地址。</p><p>首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。</p><p>除了本地DNS服务器。有一些公网的DNS服务器，也可以使用，其中最有名的就是Google的<code>8.8.8.8</code>和Level 3的<code>4.2.2.2</code>。</p><p>本机只向自己的DNS服务器查询，dig命令有一个@参数，显示向其他DNS服务器查询的结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @4.2.2.2 math.stackexchange.com</span><br></pre></td></tr></table></figure><p>上面命令指定向DNS服务器4.2.2.2查询。</p><hr><h2 id="域名层级"><a href="#域名层级" class="headerlink" title="域名层级"></a><strong>域名层级</strong></h2><p>DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。</p><p>请仔细看前面的例子，每个域名的尾部都多了一个点。</p><p><img src="DNS查询过程2.png" alt="这里写图片描述"></p><p>比如，域名<code>math.stackexchange.com</code>显示为<code>math.stackexchange.com.</code>。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。</p><p>举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。</p><p>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如.com、.net；再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如<a href="http://www.example.com里面的.example，这一级域名是用户可以注册的（可以了解一下域名抢注问题）；再下一级是主机名（host），比如www.example.com里面的www，又称为&quot;三级域名&quot;，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。" target="_blank" rel="noopener">www.example.com里面的.example，这一级域名是用户可以注册的（可以了解一下域名抢注问题）；再下一级是主机名（host），比如www.example.com里面的www，又称为&quot;三级域名&quot;，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</a></p><p>总结一下，域名的层级结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br><span class="line"></span><br><span class="line">host.sld.tld.root</span><br></pre></td></tr></table></figure><hr><h2 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a><strong>根域名服务器</strong></h2><p>DNS服务器<strong>根据域名的层级，进行分级查询</strong>。</p><p>需要明确的是，<strong>每一级域名都有自己的NS记录</strong>，NS记录指向<strong>该级域名</strong>的域名服务器。<strong>这些服务器知道下一级域名的各种记录。</strong></p><p>所谓<strong>“分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址</strong>，过程大致如下：</p><blockquote><ol><li>从根域名服务器查到顶级域名服务器的NS记录和A记录（IP地址）</li><li>从顶级域名服务器查到次级域名服务器的NS记录和A记录（IP地址）</li><li>从次级域名服务器查出主机名的IP地址</li></ol></blockquote><p>仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道根域名服务器的IP地址。回答是<strong>根域名服务器的NS记录和IP地址一般是不会变化的，所以内置在本地DNS服务器里面</strong>。</p><p>下面是内置的根域名服务器IP地址的一个例子：</p><p><img src="根域名服务器IP地址.png" alt="这里写图片描述"></p><p>上面列表中，列出了根域名（.root）的三条NS记录<code>A.ROOT-SERVERS.NET</code>、<code>B.ROOT-SERVERS.NET</code>和<code>C.ROOT-SERVERS.NET</code>，以及它们的IP地址（即A记录）<code>198.41.0.4</code>、<code>192.228.79.201</code>、<code>192.33.4.12</code>。</p><p>另外，可以看到所有记录的TTL值是3600000秒，相当于1000小时。也就是说，每1000小时才查询一次根域名服务器的列表。</p><p>目前，世界上一共有十三组根域名服务器，从<code>A.ROOT-SERVERS.NET</code>一直到<code>M.ROOT-SERVERS.NET</code>。</p><hr><h2 id="分级查询实例"><a href="#分级查询实例" class="headerlink" title="分级查询实例"></a><strong>分级查询实例</strong></h2><p>dig命令的+trace参数可以显示DNS的整个分级查询过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +trace math.stackexchange.com</span><br></pre></td></tr></table></figure><p>上面命令的第一段列出根域名.的所有NS记录，即所有根域名服务器：</p><p><img src="根域名服务器.png" alt="这里写图片描述"></p><p>根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问<code>math.stackexchange.com</code>的顶级域名服务器com.的NS记录。最先回复的根域名服务器将被缓存（缓存到本地DNS服务器上），以后只向这台服务器发请求。</p><p>接着是第二段：</p><p><img src="一级域名服务器.png" alt="这里写图片描述"></p><p>上面结果显示.com域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。</p><p>然后，DNS服务器向这些顶级域名服务器发出查询请求，询问<code>math.stackexchange.com</code>的次级域名<code>stackexchange.com</code>的NS记录：</p><p><img src="二级域名服务器.png" alt="这里写图片描述"></p><p>上面结果显示<code>stackexchange.com</code>有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。</p><p>然后，DNS服务器向上面这四台NS服务器查询<code>math.stackexchange.com</code>的主机名：</p><p><img src="主机名所在服务器.png" alt="这里写图片描述"></p><p>上面结果显示，<code>math.stackexchange.com</code>有4条A记录，即这四个IP地址都可以访问到网站。并且还显示，最先返回结果的NS服务器是<code>ns-463.awsdns-57.com</code>，IP地址为<code>205.251.193.207</code>。</p><p>在分级查询的过程中，还有2个技术要点值得讨论。</p><h3 id="递归查询与迭代查询"><a href="#递归查询与迭代查询" class="headerlink" title="递归查询与迭代查询"></a><strong>递归查询与迭代查询</strong></h3><p>我们再来补充一些概念：</p><blockquote><ul><li>域名解析：查询一个域名和找出其对应地址的过程</li><li>本地DNS服务器：参考知乎—<a href="https://www.jianshu.com/p/e84ccddd45b5" target="_blank" rel="noopener">本地DNS服务器的作用</a></li></ul></blockquote><p>先抛开分级查询不说，DNS的使用方法大致如下：为了将一个域名映射成IP地址，应用程序调用一个名为解析器的库程序，并将域名作为参数传递给此程序。然后解析器向本地DNS服务器发送一个包含该名字的请求报文；本地DNS服务器查询该名字，并且返回一个包含该名字对应IP地址的响应报文给解析器，然后解析器再将IP地址返回给调用方。</p><p>但是如果我们要查询的域名在远端，即本地DNS服务器没有相关域名的缓存信息，那么域名服务器就会进行一次远程查询，而远程查询的过程，则对应我们上面所说的分级查询。图表形式如下：</p><p><img src="分级查询.jpg" alt="这里写图片描述"></p><ul><li><strong>递归查询</strong></li></ul><blockquote><ul><li>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。</li><li>所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</li></ul></blockquote><ul><li><strong>迭代查询</strong></li></ul><blockquote><ul><li>当根域名服务器收到本地域名服务器发出的<strong>迭代查询</strong>请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个次级域名服务器进行查询… …最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</li></ul></blockquote><p>由上图可知，DNS域名系统同时涉及了两种机制。如果采用单一的迭代查询方式，则查询过程如下：</p><p><img src="迭代查询.jpg" alt="此处输入图片的描述"></p><p>可以看到，如果使用单一的迭代查询，DNS客户端将变的异常繁忙，CPU资源被抢占，用户体验将会下降。</p><p>通过结合使用递归查询与迭代查询，将DNS查询的重担交给本地DNS服务器，客户端就可以在DNS查询的过程中干自己想干的事情。</p><p><strong>总结：</strong></p><blockquote><ul><li>递归：客户端只发一次请求，要求对方给出最终结果。</li><li>迭代：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。</li></ul></blockquote><p><strong>从递归和迭代查询可以看出：</strong></p><blockquote><ul><li>客户端—本地DNS服务端：这部分属于递归查询。</li><li>本地dns服务端—外网：这部分属于迭代查询。</li></ul></blockquote><hr><h2 id="DNS的记录类型"><a href="#DNS的记录类型" class="headerlink" title="DNS的记录类型"></a><strong>DNS的记录类型</strong></h2><p>域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，“记录”可以分成不同的类型（type），前面已经看到了有A记录和NS记录。</p><p>常见的DNS记录类型如下：</p><blockquote><ol><li>A：地址记录（Address），返回域名指向的IPv4地址。</li><li>AAAA：地址记录（Address），返回域名指向的IPv6地址。</li><li>NS：域名服务器记录（Name Server），<strong>返回保存下一级域名信息的服务器地址</strong>。该记录只能设置为域名，不能设置为IP地址。</li><li>MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</li><li>CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。</li><li>PTR：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。</li></ol></blockquote><p>一般来说，为了服务的安全可靠，至少应该有两条NS记录，而A记录和MX记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。</p><p>CNAME记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，<code>facebook.github.io</code>这个域名就是一个CNAME记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dig facebook.github.io</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">facebook.github.io. 3370    IN  CNAME   github.map.fastly.net.</span><br><span class="line">github.map.fastly.net.  600 IN  A   103.245.222.133</span><br></pre></td></tr></table></figure><p>上面结果显示，<code>facebook.github.io</code>的CNAME记录指向<code>github.map.fastly.net</code>。也就是说，用户查询<code>facebook.github.io</code>的时候，实际上返回的是<code>github.map.fastly.net</code>的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改<code>github.map.fastly.net</code>这个域名就可以了，用户的<code>facebook.github.io</code>域名不用修改。</p><p>由于CNAME记录就是一个替换，所以域名一旦设置CNAME记录以后，就不能再设置其他记录了（比如A记录和MX记录），这是为了防止产生冲突。举例来说，<code>foo.com</code>指向<code>bar.com</code>，而两个域名各有自己的MX记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置MX记录，所以一般不允许用户对顶级域名设置CNAME记录。</p><p>PTR记录用于从IP地址反查域名。dig命令的-x参数用于查询PTR记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dig -x 192.30.252.153</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">153.252.30.192.in-addr.arpa. 3600 IN    PTR pages.github.com.</span><br></pre></td></tr></table></figure><p>逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有它所声称的域名。</p><p>dig命令可以查看指定的记录类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dig a github.com</span><br><span class="line">dig ns github.com</span><br><span class="line">dig mx github.com</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li>熟悉DNS的查询过程：<strong>分级查询</strong>；</li><li>熟悉分级查询中，递归查询与迭代查询的概念及使用场景；</li><li>熟悉本地DNS服务器的作用，了解DNS缓存机制；</li><li>掌握资源记录的格式：<strong>五元组</strong>；</li><li>掌握域名层级的概念：根域名、顶级域名、次级域名、主机名；</li><li>了解DNS的记录类型。</li></ol><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>计算机网络（第五版）— Andrew S.Tanenbaum、David J.Wetherall</p><p><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">DNS原理入门 — 阮一峰</a></p><p><a href="https://www.cnblogs.com/qingdaofu/p/7399670.html" target="_blank" rel="noopener">DNS递归查询与迭代查询 — 皈依之路</a></p><p><a href="https://www.jianshu.com/p/e84ccddd45b5" target="_blank" rel="noopener">本地DNS服务器的作用 — ALEXIRC</a></p><p><a href="http://blog.51cto.com/longlei/2058298" target="_blank" rel="noopener">DNS缓存服务器配置详解 — long9617</a></p><p><a href="https://blog.csdn.net/lycb_gz/article/details/11720247" target="_blank" rel="noopener">例解DNS递归/迭代名称解析原理 — 茶乡浪子</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://blog.dhengyi.name/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="DNS" scheme="https://blog.dhengyi.name/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>Java网络爬虫--多线程爬虫（抓取淘宝商品详情页URL）</title>
    <link href="https://blog.dhengyi.name/2018/03/02/Java%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB%EF%BC%88%E6%8A%93%E5%8F%96%E6%B7%98%E5%AE%9D%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5URL%EF%BC%89/"/>
    <id>https://blog.dhengyi.name/2018/03/02/Java网络爬虫-多线程爬虫（抓取淘宝商品详情页URL）/</id>
    <published>2018-03-02T14:35:30.000Z</published>
    <updated>2019-07-17T09:09:42.815Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>源码地址：<a href="h   ttps://github.com/championheng/multithreading-crawlers">多线程爬虫–抓取淘宝商品详情页URL</a></strong></p><p>项目地址中包含了一份README，因此对于项目的介绍省去部分内容。这篇博客，主要讲述项目的构建思路以及实现细节。</p><hr><h2 id="项目概述及成果"><a href="#项目概述及成果" class="headerlink" title="项目概述及成果"></a><strong>项目概述及成果</strong></h2><p>首先将本项目使用到技术罗列出来：</p><blockquote><ol><li>MySQL数据库进行数据持久化及对宕机情况的发生做简单的处理</li><li>Redis数据库做IP代理池及部分已抓取任务的缓存</li><li>自制IP代理池</li><li>使用多线程执行任务（同步块，读写锁，等待与通知机制，线程优先级）</li><li>HttpClient与Jsoup的使用</li><li>序列化与反序列化</li><li>布隆过滤器</li></ol></blockquote><p>之后会对其中使用到的技术进行详细的解释。</p><p>本项目如README中所述，还有许多不完善的地方，但IP代理池与任务抓取线程之间的调度与协作基本已无问题。也就是说，在此项目的框架上，如果你想修改其中代码用作其他抓取任务，也是完全可以的。我抓取到的数据所保存的源文件也放在GitHub的README上供大家免费浏览与下载（近90000的商品ID）。</p><hr><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a><strong>整体思路</strong></h2><blockquote><ol><li>首先你需要一个IP代理池</li><li>使用本机IP将淘宝中基本的商品分类抓取下来</li></ol><ul><li>页面源链接：<code>https://www.taobao.com/tbhome/page/market-list</code></li><li>从页面源链接中解析到的URL形如下：<code>https://s.taobao.com/search?q=羽绒服&amp;style=grid</code></li></ul><ol start="3"><li>将诸如此类的URL<code>https://s.taobao.com/search?q=羽绒服&amp;style=grid</code>作为任务队列，使用多线程对其进行抓取与解析（使用代理IP）,解析的内容为第4点</li><li>我们需要分析每一种类的商品在淘宝中大概具有多少数量，为此我解析出带有页面参数的URL，在第3点中URL的基础上：<code>https://s.taobao.com/search?q=羽绒服&amp;style=grid&amp;s=44</code>，在浏览器中打开URL可发现此页面为此种类衣服的第二页</li><li>我们得到了每一种商品带有页面参数的URL，意味着我们可以得到此类商品中全部或部分的商品ID，有了商品ID，我们就可以进入商品详情页抓取我们想要的数据了</li><li>为了实现第5点，我们先将第4点中抓取到的URL全部存储进MySQL中</li><li>从MySQL中将待抓取URL全部取出，存储到一个队列中，使用多线程对此共享队列进行操作，使用代理IP从待解析URL中解析出本页面中包含的商品ID，并构建商品详情页URL</li><li>在第7点中解析商品ID的时候，同时使用布隆过滤器，对重复ID进行过滤，并将已经抓取过的URL任务放入Redis缓存中，等达到合适的阈值时，将存储在MySQL中对应的URL行记录中的flag置为true，表示此URL已经被抓取过，等到下一次重启系统，可以不用对此URL进行抓取</li></ol></blockquote><hr><h2 id="实现细节（省略大量实现代码，如有需要请阅读源码）"><a href="#实现细节（省略大量实现代码，如有需要请阅读源码）" class="headerlink" title="实现细节（省略大量实现代码，如有需要请阅读源码）"></a><strong>实现细节（省略大量实现代码，如有需要请阅读源码）</strong></h2><h3 id="IP代理池"><a href="#IP代理池" class="headerlink" title="IP代理池"></a><strong>IP代理池</strong></h3><p>我们先从IP代理池说起，在这个项目中所运用到的IP代理池与我在<a href="http://blog.csdn.net/championhengyi/article/details/77053448" target="_blank" rel="noopener">Java网络爬虫（十一）–重构定时爬取以及IP代理池（多线程+Redis+代码优化）</a>这一篇博客中所讲述的IP代理池的实现思想有一些细小的差别。</p><ul><li><strong>差别1：不再使用定时更新IP代理池的方法</strong></li></ul><blockquote><p>由于是将IP代理池真正的运用到一个工程中，因此定时更新IP代理池的方法已经不可取。我们的IP代理池作为一个生产者，众多线程都要使用其中的代理IP，我们就可以认为这些线程都为消费者，根据多线程中经典的<strong>生产者与消费者模型</strong>，在没有足够的产品供消费者使用的时候，生产者就应该开始进行生产。也就是说，IP代理池的更新变为，当池中已经没有足够的代理IP供众多线程使用的时候，IP代理池就应该开始进行更新。而在IP代理池进行更新的时候，众多线程作为消费者，也只能等待。</p></blockquote><p>具体的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建生产者（ip-proxy-pool）与消费者（thread-tagBasicPageURL-i）等待/通知机制所需的对象锁</span></span><br><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p><strong>生产者—IP代理池</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-8-11.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: IP代理池的整体构建逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimeJob</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="comment">// IP代理池线程是生产者，此锁用来实现等待/通知机制，实现生产者与消费者模型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line"></span><br><span class="line">    MyTimeJob(Object lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果IP代理池中没有IP信息，则IP代理池进行工作</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (myRedis.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                ... ...</span><br><span class="line"></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>消费者—thread-tagBasicPageURL-i</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 下午1:01 18-2-1.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 得到带有分页参数的主分类搜索页面的URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TagBasicPageCrawlerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;              <span class="comment">// 有关生产者、消费者的锁</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TagBasicPageCrawlerThread</span><span class="params">(Queue&lt;String&gt; tagBasicUrls, Object lock, Queue&lt;String&gt; tagBasicPageUrls,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Object taskLock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tagBasicUrls = tagBasicUrls;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        <span class="keyword">this</span>.tagBasicPageUrls = tagBasicPageUrls;</span><br><span class="line">        <span class="keyword">this</span>.taskLock = taskLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 此flag用于---&gt;如果IP可以进行抓取，则一直使用此IP，不在IP代理池中重新拿取新IP的逻辑判断</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个URL用单独的代理IP进行分析</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (myRedis.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", "</span> +</span><br><span class="line">                                    <span class="string">"发现ip-proxy-pool已空, 开始进行等待... ..."</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ipMessage = myRedis.getIPByList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ... ...    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以清楚的看到等待/通知机制的经典范式：</p><p><strong>等待方（伪代码）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line"><span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">    对象.wait();</span><br><span class="line">&#125;</span><br><span class="line">对应的逻辑处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通知方（伪代码）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">     改变条件</span><br><span class="line">     对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于等待/通知机制更详细的使用，参考这篇博客：<a href="http://blog.csdn.net/canot/article/details/50879963" target="_blank" rel="noopener">Java线程之间的通信(等待/通知机制)</a></p><ul><li><strong>差别2：不再给每个线程分配固定数目的任务。将任务放在共享队列中，供线程使用</strong></li></ul><blockquote><p>在重构IP代理池的那一版本中，我将待抓取任务平分给了多个线程，每个线程将自己拿到的那些任务执行完毕即可。在将IP代理池运用到工程中的时候，我并没有那样做，而是维护了一个任务队列，每个线程都可以在这个任务队列中取任务，直到队列为空为止。这就改善了在多个线程平分任务的这种情况下，由于一个线程需要完成多个任务，而这多个任务间不是并发执行的缺点。</p></blockquote><p>具体的代码实现如下（我们只需要注意其中的saveIP方法，方法参数urls就是共享任务队列）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-8-11.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抓取xici代理网的分配线程</span></span><br><span class="line"><span class="comment"> * 抓取不同页面的xici代理网的html源码，就使用不同的代理IP，在对IP进行过滤之后进行合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateIPProxyPool</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveIP</span><span class="params">(Queue&lt;String&gt; urls, Object taskLock)</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 随机挑选代理IP(本步骤由于其他线程有可能在位置确定之后对ipMessages数量进行</span></span><br><span class="line"><span class="comment">             * 增加，虽说不会改变已经选择的ip代理的位置，但合情合理还是在对共享变量进行读写的时候要保证</span></span><br><span class="line"><span class="comment">             * 其原子性，否则极易发生脏读)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ... ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务队列是共享变量，对其的读写必须进行正确的同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (taskLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", 发现任务队列已空"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                url = urls.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IP代理池在项目中是如何对抗反爬虫的"><a href="#IP代理池在项目中是如何对抗反爬虫的" class="headerlink" title="IP代理池在项目中是如何对抗反爬虫的"></a>IP代理池在项目中是如何对抗反爬虫的</h3><p>我在使用IP代理池对抗反爬虫的时候，对IP代理池还做了些许改变：修改了IPMessage类结构。看过我关于IP代理池项目博客的同学应该清楚IPMessage这个类是做什么的，就是用来存储有关代理IP信息的。类结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-8-11.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: IPMessage JavaBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String IPAddress;</span><br><span class="line">    <span class="keyword">private</span> String IPPort;</span><br><span class="line">    <span class="keyword">private</span> String IPType;</span><br><span class="line">    <span class="keyword">private</span> String IPSpeed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> useCount;            <span class="comment">// 使用计数器，连续三十次这个IP不能使用，就将其从IP代理池中进行清除</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPMessage</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.useCount = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPMessage</span><span class="params">(String IPAddress, String IPPort, String IPType, String IPSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.IPAddress = IPAddress;</span><br><span class="line">        <span class="keyword">this</span>.IPPort = IPPort;</span><br><span class="line">        <span class="keyword">this</span>.IPType = IPType;</span><br><span class="line">        <span class="keyword">this</span>.IPSpeed = IPSpeed;</span><br><span class="line">        <span class="keyword">this</span>.useCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUseCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> useCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUseCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.useCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.useCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我给其中添加了<code>useCount</code>这一成员变量。我在使用xici代理网上的IP时发现，大部分的代理IP一次不能使用并不代表每次都不可使用，因此我在用代理IP进行网页抓取时的策略作出了如下的改变：</p><blockquote><ol><li>当前代理IP如果解析当前任务失败，则将此代理IP中的useCount变量进行加1，并将此代理IP进行序列化之后，重新丢进IP代理池，切换至其他代理IP</li><li>如果当前代理IP解析当前任务成功，则将此代理IP中的useCount变量置0，并且继续使用此代理对其它任务进行抓取，直到任务解析失败，然后重复第1点</li><li>如果发现从IP代理池中取出的代理IP的useCount变量数值已为30，则对此代理IP进行舍弃，并切换至其他代理IP</li></ol></blockquote><p>具体的代码实现如下：</p><ul><li><strong>舍弃代理IP，flag用于判断是否需要从IP代理池中拿取新的IP</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 下午4:25 18-2-6.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 负责解析带有页面参数的商品搜索页url，得到本页面中的商品id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsDetailsUrlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;                      <span class="comment">// 用于与 ip-proxy-pool 进行协作的锁</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (myRedis.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", "</span> +</span><br><span class="line">                                    <span class="string">"发现ip-proxy-pool已空, 开始进行等待... ..."</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ipMessage = myRedis.getIPByList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ipMessage.getUseCount() &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", 发现此ip："</span> +</span><br><span class="line">                        ipMessage.getIPAddress() + <span class="string">":"</span> + ipMessage.getIPPort() + <span class="string">", 已经连续30次不能使用, 进行舍弃"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>当前代理IP解析任务成功（失败），useCount置0（++），并持续使用此代理IP抓取新任务（将代理IP丢进IP代理池并拿取新IP）</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 下午4:25 18-2-6.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 负责解析带有页面参数的商品搜索页url，得到本页面中的商品id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsDetailsUrlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (myRedis.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", "</span> +</span><br><span class="line">                                    <span class="string">"发现ip-proxy-pool已空, 开始进行等待... ..."</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ipMessage = myRedis.getIPByList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (html != <span class="keyword">null</span>) &#123;</span><br><span class="line">... ...</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前任务解析失败，将当前任务重新放入任务队列中，并将flag置为true</span></span><br><span class="line">                <span class="keyword">synchronized</span> (tagBasicPageUrls) &#123;</span><br><span class="line">                    tagBasicPageUrls.offer(tagBasicPageUrl);</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-5-23.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 对淘宝页面的请求，得到页面的源码</span></span><br><span class="line"><span class="comment"> * setConnectTimeout：设置连接超时时间，单位毫秒.</span></span><br><span class="line"><span class="comment"> * setSocketTimeout：请求获取数据的超时时间，单位毫秒.如果访问一个接口，</span></span><br><span class="line"><span class="comment"> * 多少时间内无法返回数据，就直接放弃此次调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成功抓取淘宝页面计数器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> pageCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用代理IP进行网页的获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHtmlByProxy</span><span class="params">(String requestUrl, IPMessage ipMessage, Object lock)</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ... ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到服务响应状态码</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">                ... ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ... ...</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 只要能返回状态码，没有出现异常，则此代理IP就可使用</span></span><br><span class="line">            ipMessage.initCount();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">            ipMessage.setUseCount();</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                myRedis.setIPToList(ipMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a><strong>布隆过滤器</strong></h3><p>在这篇博客中，详细的介绍了布隆过滤器的实现原理：<a href="http://blog.csdn.net/championhengyi/article/details/72885500" target="_blank" rel="noopener">海量URL去重之布隆过滤器</a>，我在将布隆过滤器应用到项目中的时候，有些方法发生了改变。</p><p>之所以将布隆过滤器在这里单独提出来，是因为想给大家提供自己之前写的有关布隆过滤器的实现原理。搞清楚原理之后，大家再看项目中布隆过滤器的相关实现，也就会轻松许多。</p><h3 id="监控线程—tagBasicPageURLs-cache"><a href="#监控线程—tagBasicPageURLs-cache" class="headerlink" title="监控线程—tagBasicPageURLs-cache"></a><strong>监控线程—tagBasicPageURLs-cache</strong></h3><p>这个线程的主要作用是将Redis数据库中缓存的，已经成功解析过的任务，将其对应MySQL中所在的行记录中的flag位设置为true。在前面也说了，我将任务队列保存在了MySQL数据库中，其中对应的每一条记录，都有一个额外的标志位，flag。设置这一标志位的主要目的是，对爬虫系统做了一个简单的宕机恢复。我们应当对已经抓取过的任务做一定的标记手段，以防止在系统突然死机或其他突发状况下，需要重启项目的情况。这个时候，我们当然不可能对所有的任务重新进行抓取。</p><p>对于这个问题的处理，我在项目中的实现思路如下：</p><blockquote><ol><li>在任务抓取线程：<code>thread-GoodsDetailsUrl-i</code>，主要用来解析商品ID的线程中，如果抓取完一个任务，就将这个任务先缓存到Redis数据库中，毕竟如果直接将这个任务在MySQL中所在的行记录中的flag置为true的话，效率就有点低下了</li><li>设置监控线程：<code>tagBasicPageURLs-cache</code>，监控缓存在Redis数据库中已抓取过任务的数量，我设置的阈值是大于等于100，当然这个数字不绝对，因为线程调度是不可控的。但为了接近我所设置的这个阈值，我将此线程的优先级设置为最高</li><li>监控线程开始工作，期间使用同步块保证任务抓取线程不得给Redis数据库中添加新的已经抓取成功的任务，以达到监控线程与任务抓取线程对Redis数据库操作之间的互斥性</li></ol></blockquote><p>具体的代码实现如下：</p><p><strong>监控线程—tagBasicPageURLs-cache</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: spider_hgyi</span><br><span class="line"> * @Date: Created in 上午11:51 18-2-6.</span><br><span class="line"> * @Modified By:</span><br><span class="line"> * @Description: 处理缓存的线程，将 tag-basic-page-urls 中存在的url标记进MySQL数据库中</span><br><span class="line"> */</span><br><span class="line">public class TagBasicPageURLsCacheThread implements Runnable &#123;</span><br><span class="line">    private final Object tagBasicPageURLsCacheLock;</span><br><span class="line"></span><br><span class="line">    public TagBasicPageURLsCacheThread(Object tagBasicPageURLsCacheLock) &#123;</span><br><span class="line">        this.tagBasicPageURLsCacheLock = tagBasicPageURLsCacheLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void start(Object tagBasicPageURLsCacheLock) &#123;</span><br><span class="line">        Thread thread = new Thread(new TagBasicPageURLsCacheThread(tagBasicPageURLsCacheLock));</span><br><span class="line">        thread.setName(&quot;tagBasicPageURLs-cache&quot;);</span><br><span class="line">        thread.setPriority(MAX_PRIORITY);           // 将这个线程的优先级设置最大，允许出现误差</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        MyRedis myRedis = new MyRedis();</span><br><span class="line">        MySQL mySQL = new MySQL();</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (tagBasicPageURLsCacheLock) &#123;</span><br><span class="line">                while (myRedis.tagBasicPageURLsCacheIsOk()) &#123;</span><br><span class="line">                    System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;, &quot; +</span><br><span class="line">                            &quot;准备开始将 tag-basic-page-urls-cache 中的url在MySQL中进行标记&quot;);</span><br><span class="line"></span><br><span class="line">                    List&lt;String&gt; tagBasicPageURLs = myRedis.getTagBasicPageURLsFromCache();</span><br><span class="line">                    System.out.println(&quot;tagBasicPageURLs-size: &quot; + tagBasicPageURLs.size());</span><br><span class="line"></span><br><span class="line">                    // 将MySQL数据库中对应的url标志位置为true</span><br><span class="line">                    mySQL.setFlagFromTagsSearchUrl(tagBasicPageURLs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务抓取线程—thread-GoodsDetailsUrl-i</strong>：（截取了部分代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line"><span class="comment">// 将tagBasicPageUrl写进Redis数据库</span></span><br><span class="line"><span class="keyword">synchronized</span> (tagBasicPageURLsCacheLock) &#123;</span><br><span class="line">System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">"，准备将tagBasicPageUrl写进Redis数据库，tagBasicPageUrl："</span> + tagBasicPageUrl);</span><br><span class="line">myRedis.setTagBasicPageURLToCache(tagBasicPageUrl);</span><br><span class="line">&#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p><strong>MyRedis中的tagBasicPageURLsCacheIsOk()方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 tagBasicPageURLs-cache 中的url数量是否达到100条</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tagBasicPageURLsCacheIsOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tagBasicPageURLsCacheReadWriteLock.readLock().lock();</span><br><span class="line">Long flag = jedis.llen(<span class="string">"tag-basic-page-urls-cache"</span>);</span><br><span class="line">tagBasicPageURLsCacheReadWriteLock.readLock().unlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> flag &gt;= <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我为什么会称自己对宕机情况的发生做了简单的处理：这个解决方案并不完美，可以说存在很大的瑕疵。</p><p>我在将已经缓存至Redis数据库中，并解析完成的任务URL通过监控线程—tagBasicPageURLs-cache进行MySQL中相关标志位置true的时候，设置的是当Redis数据库中缓存的任务数量达到100及以上的时候，这个监控线程才会启动。</p><p>那么就会出现一种情况：Redis数据库中的URL数量没有达到100及以上，这个时候系统发生宕机，那么这些已经抓取过的URL在MySQL中所对应的flag标志位就不会被置为true。也就是说，在我们下次重新启动该系统的时候，这些已经抓取过的URL还会被重新抓取，并且每次存在的误差并无法严格判定，有可能没有误差，有可能误差达到了百条左右。</p><p>针对这个bug，目前博主还没有想到比较好的解决办法，相信日后会攻破它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Java网络爬虫" scheme="https://blog.dhengyi.name/categories/Java%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://blog.dhengyi.name/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="项目" scheme="https://blog.dhengyi.name/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JVM--深入剖析继承与多态实现原理（合集篇）</title>
    <link href="https://blog.dhengyi.name/2018/01/12/JVM-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E5%90%88%E9%9B%86%E7%AF%87%EF%BC%89/"/>
    <id>https://blog.dhengyi.name/2018/01/12/JVM-深入剖析继承与多态实现原理（合集篇）/</id>
    <published>2018-01-12T06:53:43.000Z</published>
    <updated>2019-07-17T10:42:55.800Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>由于我将继承与多态的讲解分成了三篇博客，所以在这篇博客给出三篇博客总的链接，阅读顺序由第一篇至第三篇就可以。</p><p>第一篇：主要讲解分派：<a href="https://blog.dhengyi.name/2017/12/09/JVM-%E8%AF%A6%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E4%B9%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%88%86%E6%B4%BE/">JVM–详解虚拟机字节码执行引擎之静态链接、动态链接与分派</a></p><p>第二篇：主要讲解invokevirtual指令：<a href="https://blog.dhengyi.name/2018/01/08/JVM-%E4%BB%8EJVM%E5%B1%82%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/">JVM–从JVM层面深入解析对象实例化、多态性实现机制</a></p><p>第三篇：主要讲解继承与方法表：<a href="https://blog.dhengyi.name/2018/01/10/JVM-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/">JVM–再谈继承与多态</a></p><p>相信这三篇博客会给你带来惊喜~~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="JVM" scheme="https://blog.dhengyi.name/categories/JVM/"/>
    
    
      <category term="多态性" scheme="https://blog.dhengyi.name/tags/%E5%A4%9A%E6%80%81%E6%80%A7/"/>
    
      <category term="JVM" scheme="https://blog.dhengyi.name/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM--再谈继承与多态</title>
    <link href="https://blog.dhengyi.name/2018/01/10/JVM-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <id>https://blog.dhengyi.name/2018/01/10/JVM-再谈继承与多态/</id>
    <published>2018-01-10T08:14:59.000Z</published>
    <updated>2019-07-17T09:29:40.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>此文试图从JVM层面深刻剖析Java中的继承与多态，知识面覆盖class字节码文件，对象的内存布局，JVM的内存区域、分派，方法表等相关知识，内容整合于大量博客，知乎，书籍，并加上博主自己的理解，相信看完会对你大有裨益！</p><p>即使博主在JVM专栏已经有两篇博客对多态的实现机制进行了分析，但是今天在分析了一波继承的原理之后，发觉之前对于多态的讲述还不完整，在查阅的相关资料之后，决定在这一篇博客真正的将继承与多态讲透彻！</p><p><strong>注：本篇博客有部分内容摘抄自：<a href="https://www.cnblogs.com/qingergege/p/6853547.html" target="_blank" rel="noopener">从JVM角度看Java多态</a>。表示感谢~</strong></p><hr><p>先来看一份代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">age = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父亲在吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"孩子在吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"孩子在打CS"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPolymorphic</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Parent c = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">c.eat();</span><br><span class="line"><span class="comment">//c.play();</span></span><br><span class="line">System.out.println(<span class="string">"年龄："</span> + c.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">孩子在吃饭</span><br><span class="line">年龄：40</span><br></pre></td></tr></table></figure><p>并且如果我在代码中没有将<code>c.play()</code>进行注释的话，将会编译错误。</p><p>对于这些结果，我会在随后给大家进行说明。我将以问答的形式来组成这篇博客的架构。随着问题的深入这些疑惑都会被解决。</p><hr><h2 id="类之间的继承，都继承了哪些东西？"><a href="#类之间的继承，都继承了哪些东西？" class="headerlink" title="类之间的继承，都继承了哪些东西？"></a><strong>类之间的继承，都继承了哪些东西？</strong></h2><p>既然要谈多态，就不能绕开继承。那就从继承开始讲起。很经典也很值得思考的问题，子类从父类上都继承了哪些东西？在类的字节码文件中是怎么体现的呢？实例化后在内存中又是怎么体现的呢？</p><h3 id="从语言层面上分析"><a href="#从语言层面上分析" class="headerlink" title="从语言层面上分析"></a><strong>从语言层面上分析</strong></h3><p>我们先来说清楚子类到底都继承了父类的哪些东西，当然这都是语言层面上的继承，不涉及它的具体实现：</p><blockquote><p>所有的东西，所有的父类的成员，包括变量（静态变量）、常量和方法（存储在方法表中），都成为了子类的成员，除了构造方法。构造方法是父类所独有的，因为它的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。</p></blockquote><p>网上有些博客给出，子类没有继承父类的private成员，这种说法是错误的。我们只能说子类不能覆盖且访问父类的private变量，所以当我们试图在子类中覆盖或访问父类的private变量的时候，编译器会给我们报错，但这并不意味着子类并没有继承父类的private变量与常量（隐藏了而已）。</p><h3 id="从字节码文件上分析"><a href="#从字节码文件上分析" class="headerlink" title="从字节码文件上分析"></a><strong>从字节码文件上分析</strong></h3><p>也许你会凭借上面所述的<strong>子类会继承父类的一切东西（除了构造器）</strong>而感觉在子类的字节码文件中也会包含父类的所有属性和方法。很遗憾，这种想法并不正确。先不说上面的例子，我们知道在Java中所有的类都默认继承自Object，你可以尝试使用javap命令编译一个普通类的class文件，看看其产生的字节码文件中是否含有Object中默认定义的方法信息，好比toString，equals方法等，如果你并没有重写这些方法的话。</p><p>那么在字节码文件中是如何表示两个类之间的继承关系呢？如果你对class文件熟悉的话，应该知道字节码中含有字段表集合，方法表集合与父类索引和接口索引集合。</p><p>字段表集合用于描述接口或类中声明的变量。方法表用于描述接口或类中所定义的方法。而<strong>父类索引与接口索引（implement也是一种继承）则是用来确定这个类的继承关系</strong>。父类索引用两个u2类型（表示两个字节）的索引值表示，它指向一个类型为CONSTANT_Class_info的类描述符常量，这个类型常量存储于字节码的常量池中，通过CONSTANT_Class_info类型常量中的索引值可以找到定义在CONSTANT_Utf8_info类型常量中的全限定名字符串。CONSTANT_Utf8_info在常量池中表示的就是UTF-8编码的字符串，也就是父类的名称。而接口索引的索引表之前还有一个接口计数器，也是u2类型的，之所以有计数器，我们也知道，在Java中，类都是单根继承，但是可以同时操作多个接口。索引表的内容则和父类索引相似，就不再赘述了。</p><p>因此在子类的字节码文件中，它的字段表集合中不会列出从基类或父接口中继承而来的字段。与字段表相对应，如果父类方法在子类中没有被重写，方法表集合中也不会出现来自父类的方法信息。我们在语言层面上所使用的继承，对应到字节码文件中，只不过是子类的字节码文件中含有父类的索引罢了，父类中的属性，方法都是通过这个索引找到指定的父类从而解析出来的。至于怎么找，怎么解析，则是类加载器与类加载机制部分的知识了，我在JVM专栏的相关博客中也有说明。</p><h3 id="实例化后从内存上分析"><a href="#实例化后从内存上分析" class="headerlink" title="实例化后从内存上分析"></a><strong>实例化后从内存上分析</strong></h3><p>首先问大家一个问题：创建子类对象的时候，会一同创建父类的对象吗？</p><p>我没有查阅过官方文档，但是我在网络上搜索了大量的相关资料，并且与学长也进行了讨论，我目前偏向于，我觉得的确也是这样设计的：<strong>创建子类对象的时候不会一同创建父类的对象</strong>。</p><p>在知乎上，对这个问题进行了激烈的探讨：<a href="https://www.zhihu.com/question/51920553" target="_blank" rel="noopener">java中，创建子类对象时，父类对象会也被一起创建么？</a></p><p>首先我先说支撑自己观点的原因：</p><p>引用一下知乎网友的回答：</p><blockquote><p>new指令开辟空间，用于存放对象的各个属性，方法等，反编译字节码你会发现只有一个new指令，所以开辟的是一块空间，一块空间就放一个对象。然后，子类调用父类的属性，方法啥的，那并不是一个实例化的对象。并且如果一个子类继承自抽象类或着接口，那么实例化这个子类的时候还能实例化抽象类与接口不成？</p></blockquote><p>而像一些博客与书籍所说的“子类对象的一部分空间存放的是父类对象”，我觉得这涉及到对象的内存布局，等下在说这个问题。</p><p>现在解答一下上面代码中的部分运行结果吧：<code>c.eat()</code>。我之前已经写了两篇关于多态的文章，具体的链接我不再贴出，直接在我的JVM专栏中寻找就可以。看过我前两篇博客的读者对这个代码的运行结果应该不会有太大的疑惑，也就是我们前面讲述的那些<strong>动态分派</strong>与<strong>invokevirtual指令</strong>，但是在这篇博客中，对于多态的实现性机制，我还要再阐述一个关于<strong>虚方法表</strong>的概念。</p><p>在《深入理解Java虚拟机》这本书中，关于多态的实现机制也是讲述了这三方面的内容，我之所以将三个东西分开讲，是觉得没有前面两篇博客的沉淀，这三个东西还真的是不好串起来。当初博主看这部分内容的时候是一种似懂非懂的状态，完全对这个三个东西没有明确的认识，我昨天对这三个东西做了如下总结，觉得大概可以将多态的实现机制概括清楚：</p><ol><li><p>动态分派能够让我们从语言层面正确辨析重写（多态），我觉得它是Java语义上多态的实现；</p></li><li><p>invokevirtual指令则是对动态分派这个概念在JVM层面上功能的具体实现，即在JVM中是用怎样一种逻辑实现了动态分派。明白了这个指令，感觉也就体现了多态实现代码中的实现逻辑；</p></li><li><p>虚方法表则是支撑着invokevirtual指令的实现，我们知道invokevirtual指令代表了递归查找当前栈帧操作数栈顶上引用所代表的实际类型的过程，而虚方法表的实现就是让invokevirtual指令有地方可查。</p></li></ol><p>而且《深入理解Java虚拟机》一书中，也称虚方法表是“虚拟机动态分派”的实现。由此可见虚方法表对于多态的重要意义。</p><p>说了这么多，到底什么是虚方法表呢？</p><p>虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值之后，虚拟机会把该类的虚方法表也初始化完毕。虚方法表存储在方法区，虚方法表中存放的都是类中的实例方法，不会存储静态方法，因为静态方法属于非虚方法，会在类加载的解析阶段就将符号引用解析为直接引用，因此不需要虚方法表。关于非虚方法的描述请参考这篇博客：<a href="http://blog.csdn.net/championhengyi/article/details/78760590" target="_blank" rel="noopener">JVM–详解虚拟机字节码执行引擎之静态链接、动态链接与分派</a>。</p><p>虚方法表中的这些直接引用会指向JVM中相关类Class对象相应的方法信息上，当然这只是本类的方法，表中还有父类的方法，相应地指向父类类型Class对象的具体位置。</p><p>如果与上述代码对应的话，应该是这样：</p><p><img src="JVM方法区中的方法表.png" alt="这里写图片描述"></p><p>如上图所示，Parent，Child都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。然后再各自指向本类中方法所存在的数据类型。但是这里有两点需要注意：</p><ol><li><p>如果子类重写了父类的方法，如上面中的eat方法，则子类方法表中的地址将会替换为指向子类实现版本的入口地址，对应至上图就是父类中有属于自己的eat方法入口地址，子类也有属于自己的eat方法入口地址。因此invokevirtual指令才能正确的找到重写方法后的地址入口。</p></li><li><p>我们从上图中可以看出，相同的方法，在子类和父类的虚方法表中都具有一样的索引序号，这主要是为了程序实现上的方便，因为当实际类型发生变化时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p></li></ol><p>好了，如果将此篇博客中的虚方法表和前两篇博客中的动态分派与invokevirtual指令的查找过程完全弄明白的话，我觉的在理论方面你的多态已经算是完全没有问题了，如果你还想更加深入，我觉得无非就是看JVM中多态的实现源码了。</p><p>谈到这，我觉得<code>c.eat()</code>方法的运行结果不用我说你们也完全明白了吧。</p><p>那么接着上面所遗留的一个问题，<strong>对象的内存布局</strong>，解决掉这个东西，<code>c.play()</code>为什么会编译错误以及<code>System.out.println(&quot;年龄：&quot; + c.age)</code>等于40的真相也将慢慢浮上水面。</p><p><strong>以下内容引入自知乎用户</strong>：<a href="https://www.zhihu.com/people/zu-chun-lei/activities" target="_blank" rel="noopener">祖春雷</a></p><p> Java对象的内存布局是由对象所属的类确定。也可以这么说，当一个类被加载到虚拟机中时，由这个类创建的对象的布局就已经确定下来了。</p><p>Hotspot中Java对象的内存布局：</p><p>每个Java对象在内存中都由对象头和对象体组成。</p><p>对象头是存放对象的元信息，包括该对象所属类对象Class的引用以及hashcode和monitor的一些信息。关于对象头的介绍，这篇博客有些许说明<a href="http://blog.csdn.net/championhengyi/article/details/78778575" target="_blank" rel="noopener">JVM–详解创建对象与类加载的区别与联系</a>。</p><p>对象体主要存放的是<strong>Java对象自身的实例域以及从父类继承过来的实例域</strong>，并且内部布局满足以下规则（从我所标出的重点来看，创建子对象的时候，确实不是真正意义上的同时创建一个基类对象）：</p><blockquote><p>规则1：任何对象都是8个字节为粒度进行对齐的。<br>规则2：实例域按照如下优先级进行排列：长整型和双精度类型；整型和浮点型；字符和短整型；字节类型和布尔类型，最后是引用类型。这些实例域都按照各自的单位对齐。<br>规则3：不同类继承关系中的实例域不能混合排列。首先按照规则2处理父类中的实例域，接着才是子类的实例域。<br>规则4：当父类中最后一个成员和子类第一个成员的间隔如果不够4个字节的话，就必须扩展到4个字节的基本单位。<br>规则5：如果子类第一个实例域是一个双精度或者长整型，并且父类并没有用完8个字节，JVM会破坏规则2，按照整形（int），短整型（short），字节型（byte），引用类型（reference）的顺序，向未填满的空间填充。</p></blockquote><p>还是以一个例子说明一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span> six;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="title">extend</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前Sub对象的内存布局由下：</p><p><img src="实例对象的内存布局.jpg" alt="这里写图片描述"></p><p>但是这些东西还不足以解释为什么上述代码中<code>c.play()</code>会报错以及为什么<code>System.out.println(&quot;年龄：&quot; + c.age)</code>的答案是40。继续往下看。</p><p>我们需要注意这一句代码：<code>Parent c = new Child()</code>，可以发现，c的实际类型虽然是Child，但它的静态类型却是Parent，问题就出在了静态类型上！</p><p>学了这么长时间的Java，博主一直没有搞懂静态类型存在的真实意义，在网上查到的都是以面向对象的思想给你解释为什么Java中存在实际类型的同时还要存在静态类型，而没有从根本上说明静态类型到底会对变量产生什么样的影响。</p><p>博主目前查阅到的设计静态类型的真正作用有如下两点（也许还有更多）：</p><blockquote><ol><li>Java的类型检查机制是静态类型检查</li><li>规定了引用能够访问内存空间的大小</li></ol></blockquote><p>对于第一点，不是本文的重点，直接给大家贴一篇相关博客<a href="http://www.tiantianbianma.com/java-static-type-check.html/" target="_blank" rel="noopener">深入分析Java的静态类型检查</a>。</p><p>我们直接来讨论第二点。</p><p>我们都知道在C中有void类型的指针，而给指针前面限定一个类型就限制了指针访问内存的方式，比如<code>char *p</code>就表示p只能一个字节一个字节地访问内存，但是<code>int *p</code>中p就必须四个字节四个字节地访问内存。但是我们都知道指针是不安全的，其中一个不安全因素就是指针可能访问到没有分配的内存空间，也就是说<code>char *p</code>虽然限制了p指针访问内存的方式，但是没有限制能访问内存的大小，这一点要完全靠程序员自己掌握。</p><p>但是在Java中的静态类型不但指定了以何种方式访问内存，也规定了能够访问内存空间的大小。</p><p>对应于刚开始贴出得代码：</p><p>我们看Parent实例对象的大小是占两行，但Child实例对象占三行（这里就是简单量化一下）。</p><p>如下图：</p><p><img src="JVM堆区实例对象包含的内容.png" alt="这里写图片描述"></p><p>所以虽然引用c指向的是Child实例对象，但是前面有Parent修饰它，它也只能访问两行的数据，也就是说c根本访问不到Child类中的age！！！只能访问到Parent类的age，<strong>所以输出40</strong>。你也可以对照着我上面贴出的“Sub对象的内存布局”那张图来对刚开始贴出的代码进行分析。</p><p>而且我们注意两个类的方法表：</p><p><img src="两个类的方法表.png" alt="这里写图片描述"></p><p>我们看到Parent的方法表占三行，Child的方法表占4行，c虽然指向了Child类的实例对象，而对象中也有指针指向Child类的方法表，但是由于c受到了Parent的修饰，通过c也只能访问到Child方法表中前3行的内容！！！！<strong>因此<code>c.play()</code>编译会出错</strong>。就是这个原因，它在方法表中根本找不到play方法。</p><p>前面说过，在方法表的形成过程中，子类重写的方法会覆盖掉表中原来的数据，也就是Child类的方法表的第三行是指向Child.eat的引用，而不是指向Parent.eat（因为方法表产生了覆盖），所以c访问到的是Child.eat。也就是子类的方法（这也是作为多态的一种解释，比invokevirtual指令更加深入）！！！这种情况下，c是没有办法直接访问到父类的eat方法的。</p><p>好了，本篇博客的内容已结束，对开头的代码也做出了完整的解释。但是我们还是有一些地方没有涵盖，比如super关键字。对于super关键字的使用，我觉得如果你已经将我写的三篇有关于多态的博客吸收与消化，那么，对于super关键字的使用与基本理解，应该是没有问题的，至于对它的深入研究，我们以后再说~~~</p><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>《深入理解Java虚拟机》—周志明</p><p><a href="https://www.jianshu.com/p/da9876272ad7" target="_blank" rel="noopener">JAVA基础探究：子类与父类</a></p><p><a href="https://www.cnblogs.com/qingergege/p/6853547.html" target="_blank" rel="noopener">从JVM角度看Java多态</a></p><p><a href="https://www.zhihu.com/question/51920553" target="_blank" rel="noopener">java中，创建子类对象时，父类对象会也被一起创建么？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="JVM" scheme="https://blog.dhengyi.name/categories/JVM/"/>
    
    
      <category term="多态性" scheme="https://blog.dhengyi.name/tags/%E5%A4%9A%E6%80%81%E6%80%A7/"/>
    
      <category term="JVM" scheme="https://blog.dhengyi.name/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM--从JVM层面深入解析对象实例化、多态性实现机制</title>
    <link href="https://blog.dhengyi.name/2018/01/08/JVM-%E4%BB%8EJVM%E5%B1%82%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.dhengyi.name/2018/01/08/JVM-从JVM层面深入解析对象实例化、多态性实现机制/</id>
    <published>2018-01-08T10:24:57.000Z</published>
    <updated>2019-07-17T09:42:01.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>之前一直觉得对于字节码的执行过程，对象的实例化过程，多态的实现机制没有进行深刻的探讨，只是进行了简单的总结，一直也苦于没有找到恰当的例子，所幸今天看到一前辈的博客，对其进行钻研之后，终于解决了这个历史遗留问题。</p><p><strong>首先贴出前辈的原文链接，并且这篇博客会引用其中的一些内容：<a href="https://www.jianshu.com/p/cdc5adb40bb7" target="_blank" rel="noopener">Java重写方法与初始化的隐患</a></strong></p><hr><h2 id="问题的还原"><a href="#问题的还原" class="headerlink" title="问题的还原"></a><strong>问题的还原</strong></h2><p>先来看一份代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSuperX;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setX(<span class="number">99</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        mSuperX = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSubX = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setX(x);</span><br><span class="line">        mSubX = x;</span><br><span class="line">        System.out.println(<span class="string">"mSubX is assigned "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mSubX = "</span> + mSubX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在main里调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubClass sc = <span class="keyword">new</span> SubClass();</span><br><span class="line">        sc.printX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你认为答案是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mSubX is assigned 99</span><br><span class="line">mSubX = 99</span><br></pre></td></tr></table></figure><p>那么请继续往下看，因为真实的答案是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SubX is assigned 99</span><br><span class="line">SubX = 1</span><br></pre></td></tr></table></figure><hr><h2 id="实际分析"><a href="#实际分析" class="headerlink" title="实际分析"></a><strong>实际分析</strong></h2><h3 id="方法重写所产生的影响及其JVM层面的原因"><a href="#方法重写所产生的影响及其JVM层面的原因" class="headerlink" title="方法重写所产生的影响及其JVM层面的原因"></a><strong>方法重写所产生的影响及其JVM层面的原因</strong></h3><p>我觉得首先要给大家说一件非常重要的事情：</p><p>SuperClass构造器中的这个方法调用，事实会调用重写后的方法，也就是SubClass中的setX方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       setX(<span class="number">99</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事实调用的是 SubClass 中的setX方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.setX(x);</span><br><span class="line">       mSubX = x;</span><br><span class="line">       System.out.println(<span class="string">"SubX is assigned "</span> + x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>要想知道发生了什么，最简单的方法就是看看到底程序到底是怎么执行的，比如单步调试，或者直接一点，看看Java字节码。</p><p>下面是Main的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"Main.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">Main</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class bugme/SubClass</span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       4: invokespecial #3                  // Method bugme/SubClass."&lt;init&gt;":()V</span><br><span class="line">       ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码首先new一个SubClass实例, 把引用入栈, dup是把栈顶复制一份再入栈, invokespecial # 3将栈顶元素出栈并调用它的某个方法, 这个方法具体是什么要看常量池里第3个条目是什么, 但是javap生成的字节码直接给我们写在旁边了, 即SubClass.&lt;init&gt;。</p><p>接下来看SubClass.&lt;init&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> bugme.SubClass();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method bugme/SuperClass."&lt;init&gt;":()V</span><br><span class="line">       ......</span><br></pre></td></tr></table></figure><p>好了，先看到这，我们来解决几个问题：</p><blockquote><ol><li>new指令之后为什么需要dup指令（操作数栈中为什么会有两个指向SubClass的引用）</li><li>&lt;init&gt;方法是什么</li></ol></blockquote><p><strong>首先来解决第一个问题</strong>：</p><p>分析一下mian方法的执行顺序吧：</p><p>1) 其中new指令在java堆上为SubClass对象分配内存空间，并将指向其地址的引用压入操作数栈顶；<br>2) 然后dup指令为复制操作数栈顶值，并将其压入栈顶，也就是说此时操作数栈上有连续相同的两个引用；<br>3) invokespecial指令调用实例初始化方法&lt;init&gt;:()V，所以需要从操作数栈顶弹出一个this引用，也就是说这一步会弹出一个之前入栈的引用；<br>4) <code>sc.printX()</code>也需要从操作数栈顶取出一个引用类型的值，进行使用；<br>5) 最后由return指令结束方法。</p><p>main方法后面的字节码没有贴出，大家可以使用javap命令进行查看。</p><p>从上面的五个步骤中可以看出，需要从栈顶弹出两个实例对象的引用，这就是为什么会在new指令下面有一个dup指令，其实对于每一个new指令来说一般编译器都会在其下面生成一个dup指令，这是因为实例的初始化方法肯定需要用到一次，然后第二个留给程序员使用，例如给变量赋值，调用方法，抛出异常等，如果我们不用，那编译器也会生成dup指令，在初始化方法调用完成后再从栈顶pop出来。</p><p><strong>再来解决第二个问题</strong>：</p><p>我曾经在JVM的其他篇章讲述过&lt;clinit&gt;，如果你对类构造器还不是很清楚，可以翻翻我以前的JVM相关博客或Baidu一下相关资料。</p><p>如果你清楚&lt;clinit&gt;，那么&lt;init&gt;与其是相类似的，其名为实例构造器，其实对于实例构造器，我们在之前也做过相关的介绍，但我还是要再次总结。</p><p>首先要清楚，我们平常所说的对象的构造方法实际上只是&lt;init&gt;的一个真子集。这是Java帮我们合成的一个方法, <strong>里面的指令会帮我们按顺序进行普通成员变量初始化, 也包括初始化块里的代码, 注意是按顺序执行, 这些都执行完了之后才轮到构造方法里代码生成的指令执行。</strong></p><p>但是一般来说，我们都是将成员变量的初始化放在构造方法中，所以<strong>&lt;init&gt;事实上就是将实例代码块中的代码放在对超类构造方法的调用语句之后（super方法），对象自身的构造方法之前合并所产生的一块代码。</strong></p><p><strong>对&lt;init&gt;方法的介绍在这篇博客中也有：<a href="http://blog.csdn.net/championhengyi/article/details/78778575" target="_blank" rel="noopener">JVM–详解创建对象与类加载的区别与联系</a></strong></p><p>因此我们平常所记忆的关于对象实例化的顺序是这样：父类&lt;clinit&gt; —&gt; 子类&lt;clinit&gt; —&gt; 父类实例块代码 —&gt; 父类构造方法 —&gt; 子类实例块代码 —&gt; 子类构造方法</p><p>现在我们可以对其实例化的顺序进行简化：父类&lt;clinit&gt; —&gt; 子类&lt;clinit&gt; —&gt; 父类&lt;init&gt;  —&gt; 子类&lt;init&gt;</p><p>刚才说到JVM在处理了new指令、dup指令之后首先调用了SubClass.&lt;init&gt;，我们也解释了&lt;init&gt;构造器。从前面说的我们知道了在&lt;init&gt;构造器中的一个指令就是对父类&lt;init&gt;构造器的调用，结合上面所贴的<code>SubClass.&lt;init&gt;</code>字节码，aload_0就将局部变量表中下标为0的元素入栈, 其实就是Java中的this, 结合<code>invokespecial #1</code>, 是在调用父类的&lt;init&gt;构造器。（<strong>注意这里调用父类构造器的this代表是SubClass</strong>）</p><p>解释了所有的问题之后，让我们再继续看SuperClass.&lt;init&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> bugme.SuperClass();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0       </span><br><span class="line">       <span class="number">5</span>: bipush        <span class="number">99</span></span><br><span class="line">       7: invokevirtual #2                  // Method setX:(I)V</span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span>  </span><br><span class="line">      </span><br><span class="line">  ......     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是先调了父类Object的&lt;init&gt;构造器, 然后再将this, 99入栈, invokevirtual #2旁边注释了是调用setX, 参数分别是this和99也就是this.setX(99)，最后是return指令，方法结束。</p><p>博主当初看到这里的时候，又产生了一个疑惑，为什么JVM会调用重写后的方法，在父类中使用的是<code>this.setX(99)</code>进行调用，JVM是怎么找到重写后方法的入口的？</p><p>事实上博主之前认为this代表的是当前对象，方法在哪个对象中，this就代表哪个对象。</p><p>如果你和博主有一样的疑惑，那么你也应该好好了解一下this这个关键字了。问题就出在对this的理解上。博主目前并没有找到官方的说法，但是经过代码验证之后，SuperClass中的this表示的还是SubClass。并且在JavaScript中对于this调用是这样描述的：<strong>一个方法由哪个对象调用，这个方法所属的对象就是this。</strong></p><p><strong>这个方法被谁调用，这个this就是谁</strong>。可以好好体会这句话。</p><p><strong>博主一直以为，this仅代表着当前对象。但是事实看来好像并不如此</strong>。由于是在子类构造器中调用的父类构造器，因此父类中的this代表的也是SubClass。甚至，我现在基本可以肯定，在SuperClass中对Object类的调用，也是SubClass。</p><p>那么事情已经变得简单了。既然已经确定了this，那么运用我们之前所说的动态分派知识，也可以明白为什么调用父类构造器中的setX方法会对应至子类的setX方法。</p><p>但是内容还不止于此… …</p><p>在和学长讨论之后，并且重新翻阅了分派那一节的内容之后，我觉得多态从本质上来说是根据当前栈帧上操作数栈顶引用所代表的实际类型来进行方法的查找，而不能简单的理解为根据方法接受者的实际类型来进行判断（那只是从我们程序员的角度来说）。正如我们上面分析的那样。</p><p>怎么理解“<strong>当前栈帧上操作数栈顶引用所代表的实际类型</strong>”呢？等下再说明这个问题。</p><p>昨天跟学长的讨论中觉得对多态的浅显认识可以这样理解：</p><blockquote><p>当初始化子类的时候，所有子类继承的父类，父类的父类的方法都被子类所拥有，而因为子类可以重写父类的方法，所以被重写的方法就不会有体现。</p></blockquote><p>我对其进行了一点补充：“相当于JVM把父类方法隐藏了，只有通过super.xxx()显式调用才能调用父类方法”。</p><p>如果你不想刨根问底，对于多态这样理解的话，我觉得也无可厚非。但是我们需要从JVM层面来考虑一下JVM到底是怎么找到重写后方法的地址入口而将父类方法的地址入口给隐藏了。</p><p>在之前我讲多态性实现机制的时候，我遗漏了一个非常重要的东西<strong>invokevirtual指令</strong>，因为当初没有学习JVM指令集，所以直接将这一部分知识略过了，这也导致了我当初对于多态的实现机制一知半解，就直接带大家上车了。</p><p>现在我来详细说一下invokevirtual指令的多态查找过程：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C；</li><li>如果在C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用；不通过则抛出IllegalAccessError异常；</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程；</li><li>如果始终没有找到合适的方法，就抛出AbstractMethodError异常。</li></ol><p>而上述步骤就是Java语言中方法重写的本质，而这种在运行期根据实际类型（对应步骤一）确定方法执行版本的分派过程就是<strong>动态分派</strong>！！！</p><p>那么我们回到刚才所讨论的代码上，要找到当前栈帧上操作数栈顶引用所代表的实际类型，看一下上面贴出的SuperClass.&lt;init&gt;的字节码。我们发现在调用setX方法之前，对操作数栈压入了this，又弹出this调用了Object的&lt;init&gt;构造器，之后又压入了99和this，此时操作数栈顶引用this所代表的实际类型就是subClass（上面已经进行了验证）。根据动态分派的原理，最后会调用SubClass中的setX方法，也就是重写后的方法。</p><h3 id="对象实例化的顺序对运行结果所产生的影响"><a href="#对象实例化的顺序对运行结果所产生的影响" class="headerlink" title="对象实例化的顺序对运行结果所产生的影响"></a><strong>对象实例化的顺序对运行结果所产生的影响</strong></h3><p>上面所述将这篇博客的主要内容已经阐述清楚，但是还有一个问题，我们明白了在子类重写父类方法之后JVM为什么会调用重写后的方法，但是还没有说明程序运行结果的原因。</p><p>让我们继续来看Java字节码，调用重写setX方法中的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: iload_1       </span><br><span class="line">       2: invokespecial #3                  // Method bugme/SuperClass.setX:(I)V</span><br><span class="line">       ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将局部变量表前两个元素都入栈, 第一个是this, 第二个是括号里的参数, 也就是99, invokespecial #3调用的是父类的setX, 也就是我们代码中写的super.setX(int)。</p><p>SuperClass.setX就很简单了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  ......     </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: iload_1       </span><br><span class="line">       2: putfield      #3                  // Field mSuperX:I</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先把this入栈, 再把参数入栈, putfield #3使得前两个入栈的元素全部出栈, 而成员mSuperX被赋值, 这四条指令只对应代码里的一句this.mSuperX = x。</p><p>接下来控制流回到子类的setX：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: iload_1       </span><br><span class="line">       2: invokespecial #3                  // Method bugme/SuperClass.setX:(I)V</span><br><span class="line">    --&gt;<span class="number">5</span>: aload_0                           <span class="comment">// 即将执行这句</span></span><br><span class="line">       <span class="number">6</span>: iload_1       </span><br><span class="line">       7: putfield      #2                  // Field mSubX:I</span><br><span class="line">      10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      13: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">16</span>: dup           </span><br><span class="line">      17: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      20: ldc           #7                  // String SubX is assigned </span><br><span class="line">      22: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      <span class="number">25</span>: iload_1       </span><br><span class="line">      26: invokevirtual #9                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">      29: invokevirtual #10                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      32: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">35</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在应该从上面所指向的5处开始执行了，5,6,7将参数的值赋给mSubX, 此时mSubX是99了, 下面那一堆则是在执行System.out.println(“mSubX is assigned “ + x);并返回, 还可以看到Java自动帮我们使用StringBuilder优化字符串拼接, 就不分析了。</p><p>都分析到这里了，你也许都会说，子类中的mSubX就是99啊，没毛病。为什么最后答案是1呢？</p><p>你也许忘了，好好想一想刚才程序所走的流程—是不是才将父类中&lt;init&gt;构造器流程走完啊。子类初始化，调用父类的&lt;init&gt;，父类的&lt;init&gt;中调用了子类的setX方法，此时mSubX等于99，剩下的子类&lt;init&gt;还没有执行呢！而我们刚才也说了，&lt;init&gt;中包括了实例变量的初始化，因此在执行子类的&lt;init&gt;过程中把1赋给mSubX, 99被1覆盖了。这就是产生最后运行结果的真相！</p><p>我们还可以再对照SubClass的字节码进行查看，刚才并没有将SubClass的字节码分析完毕：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> bugme.SubClass();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">    --&gt;1: invokespecial #1                  // Method bugme/SuperClass."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0       </span><br><span class="line">       <span class="number">5</span>: iconst_1      </span><br><span class="line">       6: putfield      #2                  // Field mSubX:I</span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  ......      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刚才分析到1处就去分析SuperClass中的&lt;init&gt;构造器了，此时mSubX已经是99了, 再执行下面的4,5,6, 将this入栈，将变量1入栈，将1赋值给this.mSubX，这一部分才是SubClass的初始化, 代码将1赋给mSubX, 99被1覆盖了。</p><p>最后return指令将方法返回，才相当于我们执行完了箭头指的这一句代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     --&gt;SubClass sc = <span class="keyword">new</span> SubClass();</span><br><span class="line">        sc.printX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来执行的代码将打印mSubX的值, 自然就是1了。</p><p>我们基本上将这份代码所产生的字节码文件分析了一遍，相信大家应该有一份额外的感受—JVM真的是基于栈执行的啊！原来这就是基于栈的指令集。</p><p>好了，这篇博客到此结束，自认为干货满满，非常有成就感，如果大家在阅读的过程有什么疑惑，欢迎大家留言讨论交流~~</p><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>《深入理解Java虚拟机》– 周志明</p><p><a href="http://www.apkbj.com/language/show-21398.html" target="_blank" rel="noopener">java虚拟机指令dup的理解</a></p><p><a href="https://www.jianshu.com/p/cdc5adb40bb7" target="_blank" rel="noopener">Java重写方法与初始化的隐患</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="JVM" scheme="https://blog.dhengyi.name/categories/JVM/"/>
    
    
      <category term="多态性" scheme="https://blog.dhengyi.name/tags/%E5%A4%9A%E6%80%81%E6%80%A7/"/>
    
      <category term="JVM" scheme="https://blog.dhengyi.name/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM--浅谈垃圾收集机制</title>
    <link href="https://blog.dhengyi.name/2017/12/20/JVM-%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.dhengyi.name/2017/12/20/JVM-浅谈垃圾收集机制/</id>
    <published>2017-12-20T12:26:28.000Z</published>
    <updated>2019-07-17T10:22:18.901Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>谈起GC，应该是让Java程序员最激动的一项技术，我相信每个Java程序员都有探究GC本质的冲动！</p><p>本篇博客围绕三个问题展开：</p><blockquote><ol><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ol></blockquote><hr><h2 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a><strong>哪些内存需要回收</strong></h2><p>首先回答第一个问题：不再使用的对象需要进行回收，<strong>不使用的类也有可能回收</strong>。</p><p>那么我们如何判断一个对象不再使用呢？主要有以下两种方法。</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a><strong>引用计数算法</strong></h3><p>定义：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减一；任何时刻计数器为0的对象就是不会被使用的对象。</p><p>我们可以看出，引用技术方法实现简单。并且有一些GC中确实使用的是引用计数算法，但是在Java虚拟机中并没有使用这个方法进行内存管理，原因就是一个问题很难被解决—<strong>对象之间循环引用</strong>。</p><p>来看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">    Node next ;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Node a = <span class="keyword">new</span> Node (); </span><br><span class="line">Node b = <span class="keyword">new</span> Node (); </span><br><span class="line"></span><br><span class="line">a.next = b ; </span><br><span class="line">b.next = a ; </span><br><span class="line"></span><br><span class="line">a = <span class="keyword">null</span>;</span><br><span class="line">b = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>如上述代码，当我们执行最后两行代码的时候，堆中的对象因为还存在着循环引用，因此引用计数并不是0，导致GC并不会回收这两个对象的内存。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h3><p>Java、C#等语言都是使用这种算法来判定对象是否存活。</p><p>基本思想：</p><blockquote><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为<strong>引用链</strong>，当一个对象到“GC Roots”没有任何引用链相连的时候，就证明此对象是不可用的。</p></blockquote><p>如图：</p><p><img src="可达性分析算法.png" alt="这里写图片描述"></p><p>在Java语言中，可作为GC Root对象包括以下几种：</p><blockquote><ul><li>虚拟机栈（栈帧中的本地变量表）中的引用对象。</li><li>方法区中的静态属性或常量（final）引用的对象。</li><li>本地方法栈中JNI(即一般说的Native方法)引用的对象。 </li></ul></blockquote><h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a><strong>方法区的回收</strong></h3><p>Java虚拟机规范中描述可以不要求虚拟机在方法区实现垃圾收集，因此很多人认为方法区中是没有垃圾收集的。</p><p>不要求虚拟机对方法区进行垃圾收集的原因主要是性价比比较低，在堆中，尤其是新生代中，进行一次垃圾收集一般会回收70%～95%的空间，但方法区的垃圾收集率远低于此。</p><p>即使这样，对方法区进行垃圾收集也并非没有必要，在大量使用反射、动态代理等这类频繁定义ClassLoader的场景都需要虚拟机卸载类的功能，以保证方法区不会溢出。</p><p>方法区的垃圾收集主要回收<strong>废弃常量与无用的类</strong>。</p><p>废弃常量的判定与回收比较简单：以“abc”这个常量为例，如果当前系统中没有任何对象引用这个常量，也没有任何其他地方（博主猜测是.class文件中有些地方对此常量的引用）引用这个字面量。此时如果发生内存回收，这个常量就会被清理出常量池。（<strong>常量池中其他类、接口、方法、字段的符号引用与此类似</strong>）</p><p>一个无用的类则需要满足以下三个条件：</p><blockquote><ol><li>该类不存在任何实例。</li><li>加载该类的ClassLoader已经被回收（条件比较苛刻）。</li><li>该类对应的Class对象没有在任何地方被引用，也就是无法使用反射机制。</li></ol></blockquote><p>虚拟机<strong>可以</strong>对满足上述三个条件的无用类进行回收。</p><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a><strong>枚举根节点</strong></h3><p>我们在这个部分应该思考一个关于可达性分析算法的问题，我们应该如何找出那些GC Roots。</p><p>目前很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，必然会消耗很多时间。</p><p>要解决这个问题，我们首先明确准确式内存管理的概念：虚拟机可以知道内存中某个位置的数据具体是什么类型。基于这点实现，在HotSpot中，使用一组称为OopMap的数据结构来保存内存中对象引用所存储的位置。</p><p>一般是在类加载完成的时候，HotSpot就将对象内什么偏移量上是什么类型的数据计算出来，在<strong>JIT编译</strong>（运行期优化）过程中，也会在<strong>特定的位置</strong>记录下栈和寄存器中哪些位置是引用。</p><p>这样GC在扫描的时候就可以直接得到这些信息。</p><hr><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a><strong>再谈引用</strong></h2><p>引用分为<strong>强引用</strong>（Strong Reference）、<strong>软引用</strong>（Soft Reference）、<strong>弱引用</strong>（Weak Reference）、<strong>虚引用</strong>（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p><ol><li><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li><li><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</li><li><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</li><li><strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</li></ol><hr><h2 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a><strong>什么时候回收</strong></h2><h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a><strong>finalize方法</strong></h3><p>通过上面几种算法，虚拟机可以知道此时内存中有哪些需要被回收的对象，但是虚拟机什么时候会对这些对象进行回收呢？我们需要来谈一谈finalize方法。</p><p>在JVM中，当一个对象通过可达性分析算法被判定为垃圾的时候，JVM并不能直接对其进行回收，一是垃圾回收机制并不是实时进行，二是真正的回收一个对象之前还会判断是否要运行它的finalize方法。</p><p>当一个对象被判定为是垃圾之后，它将会被第一次标记并进行一次筛选，筛选的条件就是此对象是否有必要执行finalize方法。</p><p>如何判断一个对象是否有必要执行finalize方法呢？</p><p>两种情况下虚拟机会视为“没有必要执行”：</p><blockquote><ul><li>对象没有覆盖finalize方法；</li><li>finalize方法已经被虚拟机调用过（finalize方法只会被调用一次）。</li></ul></blockquote><p>如果这个对象被判定为有必要执行finalize方法，那么这个对象会被放置在一个叫做F-Queue的队列之中，并在稍后由一个被虚拟机创建的，低优先级的Finalizer线程去执行该对象的finalize()方法，并且对象在finalize()方法执行中如果出现执行缓慢或者发生死循环，将会导致F-Queue队列中其他对象永久处于等待。甚至导致整个内存回收系统崩溃。之后GC将会对F-Queue之中的对象进行第二次标记。如果<strong>在第二次标记前这些对象在自己的finalize()方法中可以拯救自己(重新与引用链上的任何一个对象建立关联即可)</strong>也是可以成功存活下来并被移除“即将回收”的集合的。 如果此时还没有逃脱，那就真的要被回收了。</p><p>注意：finalize()方法的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。博主建议大家完全可以忘掉Java语言中有这个方法的存在。</p><hr><h2 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a><strong>如何回收</strong></h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a><strong>标记清除算法</strong></h3><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是使用可达性算法进行标记的。</p><p>不足：</p><p>效率问题，标记和清除两个过程的效率都不高。<br>空间问题，标记清除之后会产生大量不连续的内存碎片，导致以后分配较大对象时内存不足以至于不得不提前触发另一次垃圾收集动作。</p><p>标记，清除过程图解：</p><p><img src="标记清除算法.jpg" alt="这里写图片描述"></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制算法</strong></h3><p>将现有的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。</p><p>现在的商业虚拟机都采用这种收集算法回收<strong>新生代</strong>，同时我们显然不能忍受内存折半的损耗，好在IBM公司研究表明，新生代中98%的对象都是“朝生夕死”，所以并不需要按照1:1的比例来划分内存空间。</p><p>通常是将内存分为一块较大的Eden空间两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机默认Eden和Survivor的比例为8:1。</p><p>当每次进行回收时，将Eden和Survivor中还存活的对象一次性的复制到另一块Survivor空间上，然后清理掉Eden和刚才使用的Survivor空间。</p><p>当然会存在另一块Survivor空间不够用的情况，这时需要其他内存进行<strong>分配担保</strong>。关于分配担保的内容，我们稍后再说。</p><h3 id="内存分配策略与分代收集算法"><a href="#内存分配策略与分代收集算法" class="headerlink" title="内存分配策略与分代收集算法"></a><strong>内存分配策略与分代收集算法</strong></h3><p>也许你会疑惑什么是新生代以及什么是分配担保。</p><p>Java堆根据对象存活周期的不同将内存划分为新生代与老年代。新生代又被划分为三个区域：Eden、From Survivor、To Survivor。 </p><p>堆的内存模型大致为： </p><p><img src="堆的内存模型.jpg" alt="这里写图片描述"></p><p>当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代（长期存活的对象进入老年代）。但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代（PretenureSizeThreshold参数的设定）。</p><p><strong>Minor GC（新生代GC）</strong>：在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需付出少量存活对象的复制成本就可以完成收集。Minor GC非常频繁，并且回收速度也很快。</p><p><strong>Full GC/Major GC（老年代GC）</strong>：老年代中对象存活率高、<strong>没有额外空间对它进行分配担保</strong>，就要使用“标记-清理”或“标记-整理”算法进行回收。回收速度比Minor GC慢上很多，发生也不频繁。</p><p><strong>额外说一点：（动态对象年龄判定）</strong></p><blockquote><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果新生代中的Eden与from Survivor空间相同年龄对象的大小之和大于to Survivor空间中的一半，则大于或等于这个年龄的对象则无须等到MaxTenuringThreshold中要求的年龄，即可晋升老年代。</p><p>（JDK1.6环境下正常运行）。</p></blockquote><h3 id="分配担保机制"><a href="#分配担保机制" class="headerlink" title="分配担保机制"></a><strong>分配担保机制</strong></h3><p>我们之前说过在新生代GC的时候，会将Eden和Survivor中还存活的对象一次性的复制到另一块Survivor空间上，然后清理掉Eden和刚才使用的Survivor空间。</p><p>但是会存在另一块Survivor空间不够用的情况，这时就需要分配担保了。</p><p>其实在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否<strong>大于新生代所有对象的总大小</strong>，如果大于，则此次Minor GC是安全的。如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许开启分配担保机制。如果HandlePromotionFailure=true，说明开启了分配担保机制，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</p><p>上面提到了Minor GC依然会有风险，是因为<strong>新生代采用复制收集算法</strong>，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</p><p>但取平均值仍然是一种概率性的事件，如果某次Minor GC后存活对象陡增，远高于平均值的话，必然导致担保失败。如果出现了分配担保失败，就只能在失败后重新发起一次Full GC。虽然存在发生这种情况的概率，但大部分时候都是能够成功分配担保的，这样就避免了过于频繁执行Full GC。</p><hr><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>《深入理解Java虚拟机》—周志明</p><p><a href="http://www.bijishequ.com/detail/543280?p=58" target="_blank" rel="noopener">深入理解Java虚拟机读书笔记 - 垃圾收集算法</a></p><p><a href="http://blog.csdn.net/gyqjn/article/details/49848473" target="_blank" rel="noopener">Java GC、新生代、老年代</a></p><p><a href="http://www.jianshu.com/p/62c37dc7d638" target="_blank" rel="noopener">空间分配担保</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="JVM" scheme="https://blog.dhengyi.name/categories/JVM/"/>
    
    
      <category term="垃圾收集机制" scheme="https://blog.dhengyi.name/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
</feed>
