<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="忍耐力较诸脑力，尤胜一筹。">
<meta name="keywords" content="donghengyi, Hexo, NexT">
<meta property="og:type" content="website">
<meta property="og:title" content="H.Y&#39;s BLOG">
<meta property="og:url" content="https://blog.dhengyi.name/page/4/index.html">
<meta property="og:site_name" content="H.Y&#39;s BLOG">
<meta property="og:description" content="忍耐力较诸脑力，尤胜一筹。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="H.Y&#39;s BLOG">
<meta name="twitter:description" content="忍耐力较诸脑力，尤胜一筹。">



  <link rel="alternate" href="/atom.xml" title="H.Y's BLOG" type="application/atom+xml" />




  <link rel="canonical" href="https://blog.dhengyi.name/page/4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>H.Y's BLOG</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '[object Object]');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">H.Y's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="undefined" class="github-corner" target="_blank" title="" aria-label=""><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/08/08/JVM-解析Java内存区域及数据的内存分配与线程安全之间的一些联系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/08/JVM-解析Java内存区域及数据的内存分配与线程安全之间的一些联系/" itemprop="url">
                  JVM--解析Java内存区域及数据的内存分配与线程安全之间的一些联系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-08 14:26:58" itemprop="dateCreated datePublished" datetime="2017-08-08T14:26:58+08:00">2017-08-08</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">4.9k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">4 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一直在看《Java多线程编程核心技术》的第二章，主要讲的是线程共享变量与线程私有变量以及如何写出线程安全的代码。看这部分一开始没太注意，只是记住了一条规则，“<strong>类中的成员变量，也叫实例变量，也叫全局变量，它是非线程安全，是所有线程共享的变量，定义在方法中的私有变量是线程安全的，是每个线程私有的</strong>”。很好理解不是吗，然后一帆风顺的看到了关于volatile这部分的知识，看过之后我陷入了凌乱。。。关于这部分我之后进行总结，而现在我觉得你如果真的想写出线程安全的代码，那么Java的内存分配以及布局就是我们需要掌握的基础。为此，我粗略的看了一下《深入理解Java虚拟机》这本书的第二章，并且查阅了一些资料，现在汇总整理如下。</p>
<p><strong>注：学习这部分内容之前如果你对进程的内存映像或数据在内存中的分配有大概的了解，建议你先忘记它们，因为这是讲Java虚拟机运行时的数据区，和之前的知识并不相同，所以学习的时候不要拿自己以前所了解的知识进行比较与衡量。</strong></p>
<hr>
<h2 id="Java虚拟机运行时的数据区"><a href="#Java虚拟机运行时的数据区" class="headerlink" title="Java虚拟机运行时的数据区"></a><strong>Java虚拟机运行时的数据区</strong></h2><p>先来看一张图片：</p>
<p><img src="Java虚拟机运行时的数据区.jpg" alt="Java虚拟机运行时的数据区"></p>
<p>在这里我们只需要关注线程共享区中的堆，以及线程独占区中的<strong>虚拟机栈</strong>，就是我们平时说的栈，只是这种说法在JVM中并不严谨，正确的应该说是虚拟机栈中局部变量表部分。（被static关键字声明的东西就是存储在方法区中）</p>
<p>其次，我在查阅资料的时候，看到网上很多资料都说栈中的数据共享而堆中的数据不共享，起初我还以为是博主写错了，了解之后发现我们考虑问题的立场不同，我们今天要讨论的是堆或栈内的数据对多线程是否共享，而他们所说的栈内数据共享则是在创建新变量时为节省内存空间而采取的一种措施，被称为Slot复用，两个完全是不同的东西。具体的区别在后面给大家说明。</p>
<hr>
<h2 id="虚拟机栈与堆"><a href="#虚拟机栈与堆" class="headerlink" title="虚拟机栈与堆"></a><strong>虚拟机栈与堆</strong></h2><p>看了上面的图片，对JVM的数据区也有了个大概的认识，我们来详细说一下虚拟机栈和堆中到底都存储的是哪些数据。</p>
<p>下面这段话摘自网上他人博客：</p>
<blockquote>
<p>基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。</p>
<p>最后需要补充的是所有对象的引用也都存在于栈中，而实际的对象本身是存储在堆中的，我们这时候倒可以将引用理解为一个指针，它指向了我们在堆中创建的对象。</p>
</blockquote>
<p>再来说明前面说的栈内数据共享是什么东西，还是摘自他人博客：</p>
<blockquote>
<p>另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义<code>int a = 3; int b = 3;</code> 编译器先处理<code>int a = 3；</code>首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。</p>
</blockquote>
<p>至于堆中存储的数据，只要记住一句话，<strong>所有new出来的变量都存储在堆中</strong>。但是在这里我们还要考虑String类型的特殊性和自动拆箱与装箱的相关概念，好吧，概念实在太多了。我们之后再说这些问题。我们先来看两个问题：（下面讲述的问题只针对同一个对象，在多个不同的对象中，堆中的数据也是不共享的）</p>
<ol>
<li><p>基本数据类型的成员变量放在jvm的哪块内存区域里？看了上面的概念之后，我们知道基本数据类型应该是存放在虚拟机栈中的。如果你也认为是虚拟机栈中，那么根据上面的图片，它应该属于线程独占区啊，怎么会属于共享变量呢？</p>
</li>
<li><p>与上面的问题对应，方法中新建的非基本数据类型放在jvm的哪块内存区域里？如果我们在方法中new了一个对象，按道理来说，new 出来的对象都是存放在堆上的，而根据上图我们又发现… …Java堆是属于线程共享区的。这是怎么一回事呢？</p>
</li>
</ol>
<p>首先回答第一个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本数据类型放在栈中，这一概念的确没有错，但是这个说法又不是很准确，如上面的代码，基本数据类型的全局变量i，它是存放在java堆中。因为它不是静态的变量，不会独立于类的实例而存在，而该类实例化之后，放在堆中，当然也包含了它的属性i。因此成员变量就算是基本数据类型也共享。</p>
<p>是不是觉得有点绕？然而事实的确是这样。</p>
<p>再来看第二个问题，对象的确是存放在堆中，但我们也说了线程不安全只针对单例模式的成员变量，而此时如果对象被定义在了方法之中，那么当每个线程调用一次方法都会新创建一个对象，这些对象都属于每个线程所私有，所以虽然对象本身存在于堆中，但也并不共享。至于基本类型由于每个线程执行时将会把局部变量放在各自栈帧的工作内存中，线程间不共享，故不存在线程安全问题。</p>
<p>最后结合Java虚拟机运行时的数据区总结一下，就是对于<strong>同一对象（单例模式），成员变量共享，局部变量不共享。</strong></p>
<hr>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h2><p>运行时常量池存在于方法区中，常量池里面主要存储字符串常量和基本类型常量（public static final）。</p>
<p><strong>对于字符串</strong>：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。</p>
<p>如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"china"</span>;</span><br><span class="line">String s2 = <span class="string">"china"</span>;</span><br><span class="line">String s3 = <span class="string">"china"</span>;</span><br><span class="line">String ss1 = <span class="keyword">new</span> String(<span class="string">"china"</span>);</span><br><span class="line">String ss2 = <span class="keyword">new</span> String(<span class="string">"china"</span>);</span><br><span class="line">String ss3 = <span class="keyword">new</span> String(<span class="string">"china"</span>);</span><br></pre></td></tr></table></figure>
<p>这里解释一下，对于通过 new 产生一个字符串（假设为 ”china” ）时，会先去常量池中查找是否已经有了 ”china” 对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此 ”china” 对象的拷贝对象。</p>
<p>也就是有道面试题： String s = new String(“xyz”); 产生几个对象？</p>
<p>一个或两个。如果常量池中原来没有 ”xyz”, 就是两个。如果原来的常量池中存在“xyz”时，就是一个。</p>
<p><strong>对于基础类型的变量和常量</strong>：变量存储在栈中，常量存储在常量池中。</p>
<p>如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">9</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT1 = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT2 = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT3 = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="自动拆箱与自动装箱"><a href="#自动拆箱与自动装箱" class="headerlink" title="自动拆箱与自动装箱"></a><strong>自动拆箱与自动装箱</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line"></span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line"></span><br><span class="line">        out.println(c == d);</span><br><span class="line">        out.println(e == f);</span><br><span class="line">        out.println(c == (a+b));</span><br><span class="line">        out.println(c.equals(a+b));</span><br><span class="line">        out.println(g == (a+b));</span><br><span class="line">        out.println(g.equals(a+b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下程序的运行结果是否符合你的预期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>首先我们先来了解一下包装类数据：</p>
<blockquote>
<p>包装类数据，如Integer, String, Double，Long等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中。</p>
</blockquote>
<p>然后我们在对自动装箱与拆箱做个了结：</p>
<blockquote>
<ol>
<li><p>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱，equals()方法不处理数据转型的关系。</p>
</li>
<li><p>在自动装箱时，把int变成Integer的时候，是有规则的，当你的int的值在-128-IntegerCache.high(127) 时，返回的不是一个新new出来的Integer对象，而是一个已经缓存在堆中的Integer对象，（我们可以这样理解，系统已经把-128到127之 间的Integer缓存到一个Integer数组中去了，如果你要把一个int变成一个Integer对象，首先去缓存中找，找到的话直接返回引用给你就 行了，不必再新new一个），如果不在-128-IntegerCache.high(127) 时会返回一个新new出来的Integer对象。</p>
</li>
</ol>
</blockquote>
<p>对于第二点，不仅Integer有这种特性，其它包装类数据也具有，我们可以看一下Long的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LongCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Long cache[] = <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">		cache[i] = <span class="keyword">new</span> Long(i - <span class="number">128</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在了解了上面的概念之后，我相信你已经基本能够正确解释代码运行的结果了。</p>
<p>最后我来解释一下最后两个的运行结果为什么是true与false，先来看一下后两句话在进行编译之后在.class文件中的样子吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(g.longValue() == (<span class="keyword">long</span>)(a.intValue() + b.intValue()));</span><br><span class="line">System.out.println(g.equals(Integer.valueOf(a.intValue() + b.intValue())));</span><br></pre></td></tr></table></figure>
<p>我们可以看到编译器对<code>out.println(g == (a+b));</code>进行编译的时候，进行了拆箱与向上转型的操作，所以此时比较的仅仅是两个变量的字面值，与基本数据类型的比较是一样的，所以是true，而最后仍然比较的是对象中的数据并且对a没有进行向上转型，Long中存在的数据肯定就和Integer中存在的数据不等了，所以为false。</p>
<p>再说一点，我们能将字面值直接赋给Integer类是因为Java语法糖的存在，实际上<code>Integer a = 1</code>在经过编译之后是这样的：<code>Integer a = new Integer(1)</code>，语法糖帮助我们简化了语法。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/08/04/Java并发-详解this与Thread-currentThread-的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/Java并发-详解this与Thread-currentThread-的区别/" itemprop="url">
                  Java并发--详解this与Thread.currentThread()的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-04 10:15:20" itemprop="dateCreated datePublished" datetime="2017-08-04T10:15:20+08:00">2017-08-04</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java并发/" itemprop="url" rel="index"><span itemprop="name">Java并发</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">3.1k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">3 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：本系列博客参考《Java多线程编程核心技术》，主要是对书上的知识点进行总结，并记录学习过程。</strong></p>
<p>一直对并发这块比较感兴趣，也到了系统学习Java多线程的时间。目前所学习的书籍是《Java多线程编程核心技术》，买回来之后听说这本书不怎么样，豆瓣评分也就7点几，目前读完了第一章，感觉确实不是很好，但是也不算太坑，总的来说还是可以入手的。好了，废话不多说，开始正题。</p>
<hr>
<p>首先我们来看一份代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountOperate</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountOperate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        out.println(<span class="string">"CountOperate---begin"</span>);</span><br><span class="line">        out.println(<span class="string">"Thread.currentThread.getName()="</span> + Thread.currentThread().getName());</span><br><span class="line">        out.println(<span class="string">"this.name()="</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">        out.println(<span class="string">"Thread.currentThread()==this :"</span>+ (Thread.currentThread() == <span class="keyword">this</span>));</span><br><span class="line">        out.println(<span class="string">"CountOperate---end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        out.println(<span class="string">"run begin"</span>);</span><br><span class="line">        out.println(<span class="string">"Thread.currentThread().getName()="</span> + Thread.currentThread().getName());</span><br><span class="line">        out.println(<span class="string">"this.getName="</span> + <span class="keyword">this</span>.getName());</span><br><span class="line">        out.println(<span class="string">"Thread.currentThread()==this :"</span>+ (Thread.currentThread() == <span class="keyword">this</span>));</span><br><span class="line">        out.println(<span class="string">"run---end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountOperate countOperate = <span class="keyword">new</span> CountOperate();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(countOperate);</span><br><span class="line"></span><br><span class="line">        thread.setName(<span class="string">"A"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下运行结果是否符合你的预期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CountOperate---begin</span><br><span class="line">Thread.currentThread.getName()=main</span><br><span class="line">this.name()=Thread-0</span><br><span class="line">Thread.currentThread()==this :false</span><br><span class="line">CountOperate---end</span><br><span class="line"></span><br><span class="line">run begin</span><br><span class="line">Thread.currentThread().getName()=A</span><br><span class="line">this.getName()=Thread-0</span><br><span class="line">Thread.currentThread()==this :false</span><br><span class="line">run---end</span><br></pre></td></tr></table></figure>
<p>在还没有启动CountOperate线程的时候，调用这段代码的是main线程，所以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread.getName()=main</span><br></pre></td></tr></table></figure>
<p>这是正常的，但是 <code>this.name()=Thread-0</code> 这是个什么东西？看一下Thread源码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数的含义不明确？好，我们再来看一下init方法的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name, <span class="keyword">long</span> stackSize)</span></span>;</span><br></pre></td></tr></table></figure>
<p>来解释一下各个参数的含义：</p>
<blockquote>
<ul>
<li>ThreadGroup: 线程组</li>
<li>Runnable target: <strong>the object whose {@code run} method is invoked when this thread is started. If {@code null}, this thread’s run method is invoked.</strong> （源码解释，建议百度翻译，也是产生this和Thread.currentThread区别的原因）<strong>因为在Thread源码中，Thread实际上操作了Runable，所以此参数也接受Thread对象，也就是说此参数也可以是继承了Thread的线程类</strong></li>
<li>String name: 线程名</li>
<li>long stackSize: 新线程所需的堆栈大小，或0表示该参数将被忽略。</li>
</ul>
</blockquote>
<p>这下，我们知道Thread-0是怎么来的了，String name生成名称的规则是：“Thread-”加上创建的线程的个数（第几个）。默认从0开始，main线程是默认就有的，所以并不计数。</p>
<p>然后 <code>Thread.currentThread()==this :false</code> 这个也好理解，this代表的是CountOperate对象实例，而<code>Thread.currentThread()</code> 得到的是main，所以为false。</p>
<p>代码继续向下执行… …</p>
<p>重点来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getName()=A</span><br><span class="line">this.getName()=Thread-0</span><br><span class="line">Thread.currentThread()==this : false</span><br></pre></td></tr></table></figure>
<p><code>Thread.currentThread().getName()</code> 得到的是执行这段代码的线程名，我们已经设置为了A，没问题。但是这里的<code>this.getName()=Thread-0</code>为什么没变？this代表的实例是什么？别着急，我们再来看一看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">	init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们结合上面源码中target的注释再来看一看run方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        target.run();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>明白了吧？只要target不为空，那么它最后还是会调用target的run方法。是的，现在问题已经解决了！没反应过来？那我们回过头来看一下<code>Thread thread = new Thread(countOperate)</code>，从源码来讲，它最后还是会执行<code>countOperate.run()</code>，而this取得的就是代表当前实例的引用，所以，<code>this.getName()</code> 还是会打印Thread-0。那么最后一个false也就明白了，两个取得的都不是同一个对象，自然Thread.currentThread()和this也就不等了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/08/03/查找-二叉查找树分析与实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/查找-二叉查找树分析与实现/" itemprop="url">
                  查找--二叉查找树分析与实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-03 10:16:00" itemprop="dateCreated datePublished" datetime="2017-08-03T10:16:00+08:00">2017-08-03</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">7.3k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">7 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="为什么我们需要掌握这些“高端”的树型结构"><a href="#为什么我们需要掌握这些“高端”的树型结构" class="headerlink" title="为什么我们需要掌握这些“高端”的树型结构"></a><strong>为什么我们需要掌握这些“高端”的树型结构</strong></h2><p>事实上，大型数据库的组织结构一般采用树型结构，我们必须要解决频繁更新数据的能力，要求支持高效的动态查找能力，包括记录的插入，删除，精确匹配查询，范围查询和最大值、最小值查询。但是由于数据库中包含了大量的记录，所以线性表的查询本身会因为记录太大而无法存储到主存之中，另外对于记录的插入和删除操作更需要移动大量的元素，这本身的效率是非常低下的。</p>
<hr>
<h2 id="二叉查找树（BST）的定义"><a href="#二叉查找树（BST）的定义" class="headerlink" title="二叉查找树（BST）的定义"></a><strong>二叉查找树（BST）的定义</strong></h2><p>二叉查找树要么是一颗空树，要么满足以下的定义：</p>
<blockquote>
<ul>
<li>若它的左子树不为空，那么它左子树上所有节点的值均小于等于根节点。</li>
<li>若它的右子树不为空，那么它右子树上所有节点的值均大于根节点。</li>
<li>它的左右子树均是二叉查找树。</li>
</ul>
</blockquote>
<p>这明显是一个递归定义，因此我们对于BST的操作大多是建立在递归之上的。</p>
<p>二叉查找树有一个重要的特征：对一颗二叉查找树进行中序遍历，可以得到一个递增序列，那么我们只要将中序遍历的遍历顺序反过来，那么我们就会得到一个递减序列，这也正是二叉查找树得名的原因。</p>
<hr>
<h2 id="BST的数据结构"><a href="#BST的数据结构" class="headerlink" title="BST的数据结构"></a><strong>BST的数据结构</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> keyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    keyType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BSTNode, BSTree;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="BST的建立"><a href="#BST的建立" class="headerlink" title="BST的建立"></a><strong>BST的建立</strong></h2><p>首先我们讨论一下怎么建立一颗二叉查找树，根据二叉查找树的定义，如果现在有一串序列，那么它的建立过程如下：</p>
<blockquote>
<ol>
<li>首先建立一颗空树；</li>
<li>使节点插入正确的位置（BST的建立正是建立在BST的插入算法之上的）；</li>
<li>序列为空为止。</li>
</ol>
</blockquote>
<p>那么我们现在应该如何给一颗二叉查找树中插入新的节点呢？</p>
<blockquote>
<ol>
<li>从树的根节点开始查找；</li>
<li>插入的关键字小于等于根节点则进入左子树，否则进入右子树；</li>
<li>由于新插入的节点必定是新的叶子节点，所以当此时的节点指针为空的时候，进行插入。</li>
</ol>
</blockquote>
<p>插入算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(BSTree **bstree, keyType data)</span> </span>&#123; </span><br><span class="line">    BSTNode *bstnode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*bstree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        bstnode = (BSTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        bstnode -&gt; data = data;</span><br><span class="line">        bstnode -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">        bstnode -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">        *bstree = bstnode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data &lt;= (*bstree) -&gt; data) &#123;</span><br><span class="line">        insert(&amp;((*bstree)-&gt;lchild), data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(&amp;((*bstree)-&gt;rchild), data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行节点插入的时候，我们并不希望指向根节点的指针随着遍历的进行也跟着移动，并且因为是对于指针的参数传递，这里必然使用二级指针，这样头结点才会被真正的初始化。然后我们在进行递归遍历节点的时候，我们也不能影响二级指针的指向，我之所以在这里着重强调，说实话，我这个bug还是小伙伴帮我改出来的，对于二级指针，一直都是感觉自己懂了，一碰到繁杂的操作，就又糊涂了。。。</p>
<p>建立算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_BSTree</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], BSTree **bstree)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//二叉查找树的创建是建立在插入上面的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        insert(bstree, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后我们便可以对二叉查找树进行树状打印了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_tree</span><span class="params">(BSTree *bstree, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bstree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bstree -&gt; rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        print_tree(bstree -&gt; rchild, h+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bstree -&gt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bstree -&gt; lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        print_tree(bstree -&gt; lchild, h+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看上面的打印代码，没错，将中序遍历的顺序颠倒一下就行了。</p>
<hr>
<h2 id="BST的查找"><a href="#BST的查找" class="headerlink" title="BST的查找"></a><strong>BST的查找</strong></h2><p>BST的查找我们可以用递归和循环分别实现。</p>
<p>非递归实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">find</span><span class="params">(BSTree *bstree, keyType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(bstree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(bstree -&gt; data == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> bstree;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(bstree -&gt; data &gt;= key)&#123;</span><br><span class="line">            bstree = bstree -&gt; lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bstree = bstree -&gt; rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bstree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归不再分析。</p>
<p>递归实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">find_recursive</span><span class="params">(BSTree *bstree, keyType key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bstree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bstree -&gt; data == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> bstree;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(key &lt;= bstree -&gt; data) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(bstree -&gt; lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(bstree -&gt; rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们对二叉查找树进行查找的时候不需要回溯，所以我们每次进入新子树的时候，直接这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> find(bstree -&gt; lchild, key);</span><br></pre></td></tr></table></figure>
<p>return 语句阻止了回溯的发生。</p>
<hr>
<h2 id="BST的删除"><a href="#BST的删除" class="headerlink" title="BST的删除"></a><strong>BST的删除</strong></h2><p>BST节点的删除，情况比较复杂，我在这里分三种情况说明：</p>
<p>在进行节点删除的时候，我们需要两个指针，它们指向待删节点的父节点与待删节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父节点和孩子节点（待删节点）</span></span><br><span class="line">BSTree *root, *child;</span><br><span class="line">child = root = bstree;</span><br></pre></td></tr></table></figure>
<p>首先我们考虑特殊情况，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先考虑特殊情况（根节点为空|只有根节点）</span></span><br><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"这是棵空树"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (root -&gt; lchild == <span class="literal">NULL</span> &amp;&amp; root -&gt; rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; data == key) &#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"没要找到您要删除的节点"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="待删节点是叶子节点"><a href="#待删节点是叶子节点" class="headerlink" title="待删节点是叶子节点"></a><strong>待删节点是叶子节点</strong></h3><blockquote>
<ul>
<li>找待删节点，并不断记录它的父节点。</li>
<li>将父节点的相应孩子域进行置空并free待删节点所占的空间。</li>
</ul>
</blockquote>
<p>先进行待删节点的查找：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(child != <span class="literal">NULL</span> &amp;&amp; child -&gt; data != key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(key &lt;= child -&gt; data) &#123;</span><br><span class="line">        root = child;</span><br><span class="line">        hild = root -&gt; lchild;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = child;</span><br><span class="line">        child = root -&gt; rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(child == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"没有找到您要删除的节点"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行叶子节点的删除：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待删节点是叶子节点</span></span><br><span class="line"><span class="keyword">if</span>(child -&gt; lchild == <span class="literal">NULL</span> &amp;&amp; child -&gt; rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; lchild == child) &#123;</span><br><span class="line">         root -&gt; lchild = <span class="literal">NULL</span>;</span><br><span class="line">         <span class="built_in">free</span>(child);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         root -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">         <span class="built_in">free</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="待删节点只有左子树或只有右子树"><a href="#待删节点只有左子树或只有右子树" class="headerlink" title="待删节点只有左子树或只有右子树"></a><strong>待删节点只有左子树或只有右子树</strong></h3><blockquote>
<ul>
<li>找到待删节点并判断此节点是否只有左子树或右子树。</li>
<li>将待删节点父节点的相应孩子域设置为该待删节点对应的左子树或右子树。</li>
<li>将待删节点置空。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待删节点只有左子树或者右子树</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(child -&gt; lchild == <span class="literal">NULL</span> || child -&gt; rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span>(root -&gt; lchild == child &amp;&amp; child -&gt; lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root -&gt; lchild = child -&gt; lchild;</span><br><span class="line">		<span class="built_in">free</span>(child);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; lchild == child &amp;&amp; child -&gt; rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root -&gt; lchild = child -&gt; rchild;</span><br><span class="line">		<span class="built_in">free</span>(child);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; rchild == child &amp;&amp; child -&gt; lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root -&gt; rchild = child -&gt; lchild;</span><br><span class="line">		<span class="built_in">free</span>(child);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		root -&gt; rchild = child -&gt; rchild;</span><br><span class="line">		<span class="built_in">free</span>(child);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="待删节点既有左子树也有右子树"><a href="#待删节点既有左子树也有右子树" class="headerlink" title="待删节点既有左子树也有右子树"></a><strong>待删节点既有左子树也有右子树</strong></h3><p>当碰到这种情况的时候，我们需要额外引入两个指针，一个用来记录找到的替换节点，一个用来记录替换节点的父节点（替换节点就是用来替换被删除的节点）。</p>
<p>那么我们应该如何找到替换节点呢？来看一张图：</p>
<p><img src="待删节点既有左子树也有右子树.jpg" alt="这里写图片描述"></p>
<p>我们知道对二叉查找树进行中序遍历所得到的是递增序列。</p>
<p>假设我们现在要删除节点5，这棵BST的中序遍历结果为：1，2，3，4，5，6，7，根据中序遍历的性质可知，5之左是它的左子树，5之右是它的右子树，现在我们要删除5，那么我们就要找可以替换5的4或6，也就是和5相邻的两个数，我们再来看一下这两个节点在树中的位置，4的位置在左子树中最右下角，6的位置在右子树的最左下角，我们选择查找任一节点进行待删节点的替换就行。仔细观察会发现这一规律对任意节点适用。</p>
<p>理解了上面寻找替换节点的两种方式之后，来看一下实现代码，我寻找的是左子树中最右下角的替换节点并同时记录替换节点的父节点：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BSTree *alter;</span><br><span class="line">BSTNode *alterParent = child;</span><br><span class="line">alter = alterParent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(alter -&gt; rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	alterParent = alter;</span><br><span class="line">	alter = alterParent -&gt; rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先重申一点，我们现在拥有四个指针，root-&gt;用来指向待删节点的父节点，child-&gt;用来指向待删节点，alter-&gt;用来指向我们找到的替换节点，alterParent-&gt;用来指向我们找到的替换节点的父节点。下面我们具体讨论四种情况：</p>
<p>对这四种情况，我希望大家可以认真考虑，画出一棵二叉查找树，然后去一个个进行实现。</p>
<p><strong>1. 替换节点的父节点等于待删节点且删除节点是根节点的时候</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(alterParent == child &amp;&amp; child == bstree) &#123;</span><br><span class="line"><span class="comment">/**由于我查找替换节点的方式是左子树的最右边，所以当满足上面的if语句之后，我的替换节点必定在</span></span><br><span class="line"><span class="comment">待删除节点的左边*/</span></span><br><span class="line">	alter -&gt; lchild = child -&gt; lchild -&gt; lchild;</span><br><span class="line">	alter -&gt; rchild = child -&gt; rchild;</span><br><span class="line">	<span class="comment">//更新根节点</span></span><br><span class="line">	bstree = alter;</span><br><span class="line">	<span class="built_in">free</span>(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 替换节点的父节点等于待删节点但删除节点不是根节点的时候</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(alterParent == child &amp;&amp; child != bstree) &#123;</span><br><span class="line">	alter -&gt; lchild = child -&gt; lchild -&gt; lchild;</span><br><span class="line">	alter -&gt; rchild = child -&gt; rchild;</span><br><span class="line">	<span class="comment">//我们要判断待删节点是在待删节点父节点的哪颗子树上</span></span><br><span class="line">	<span class="keyword">if</span>(child == root -&gt; lchild) &#123;</span><br><span class="line">		root -&gt; lchild = alter;</span><br><span class="line">		<span class="built_in">free</span>(child);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		root -&gt; rchild = alter;</span><br><span class="line">		<span class="built_in">free</span>(child);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 替换节点的父节点不等于待删节点但删除节点是根节点的时候</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(alterParent != child &amp;&amp; child == bstree) &#123;</span><br><span class="line">	<span class="comment">//如果是这种情况，那么替换节点就在替换父节点的右子树上</span></span><br><span class="line">	alter -&gt; lchild = child -&gt; lchild;</span><br><span class="line">	alter -&gt; rchild = child -&gt; rchild;</span><br><span class="line">	<span class="built_in">free</span>(child);</span><br><span class="line">	<span class="comment">//更新根节点</span></span><br><span class="line">	bstree = alter;</span><br><span class="line">	alterParent -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. 替换节点的父节点不等于待删节点并且删除节点不是根节点的时候</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	alter -&gt; lchild = child -&gt; lchild;</span><br><span class="line">	alter -&gt; rchild = child -&gt; rchild;</span><br><span class="line">	<span class="keyword">if</span>(child == root -&gt; lchild)&#123;</span><br><span class="line">		root -&gt; lchild = alter;</span><br><span class="line">		<span class="built_in">free</span>(child);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		root -&gt; rchild = alter;</span><br><span class="line">		<span class="built_in">free</span>(child);</span><br><span class="line">	&#125;</span><br><span class="line">	alterParent -&gt; rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，可以看到每种情况的处理过程并不复杂，只要将每种情况都处理到，二叉查找树的删除问题也就迎刃而解了。</p>
<p>我把每种删除情况都测试了一下，都删除成功，具体的源码链接我放在下面，有兴趣的小伙伴可以研究研究。</p>
<hr>
<h2 id="BST性能分析"><a href="#BST性能分析" class="headerlink" title="BST性能分析"></a><strong>BST性能分析</strong></h2><p>二叉查找树查找的最差情况为ASL（平均查找长度）=((1+n)*n/2)/n = (n+1)/2，和顺序查找相同，如图：</p>
<p><img src="BST性能分析.jpg" alt="这里写图片描述"></p>
<p>最好的情况与折半查找相同，ASL为log2N（图片不再贴出）。</p>
<p>对于BST的插入和删除来说，只需修改某些节点的指针域，不需要大量移动其它记录，动态查找的效率很高。</p>
<hr>
<h2 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a><strong>源码链接</strong></h2><p><a href="https://github.com/championheng/Datastruct-Algorithm/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/BST.cpp" target="_blank" rel="noopener">戳我得到源码哦～～</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/07/27/排序-堆排序分析与实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/27/排序-堆排序分析与实现/" itemprop="url">
                  排序--堆排序分析与实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-27 20:25:04" itemprop="dateCreated datePublished" datetime="2017-07-27T20:25:04+08:00">2017-07-27</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">3.4k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">3 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="何为堆"><a href="#何为堆" class="headerlink" title="何为堆"></a><strong>何为堆</strong></h2><p>一个数组序列我们可以将其用完全二叉树或近似完全二叉树（不是满二叉树的完全二叉树）表示出来，当数组下标为i时，它的父节点为(i-1)/2，左孩子为(2i+1)，右孩子为(2i+2)，这种对应关系说明数组下标为0的地方也要存储数据。（关于完全二叉树和满二叉树我在这里不做介绍）</p>
<p>堆是在完全二叉树的基础上递归定义的，堆分为大顶堆和小顶堆。</p>
<blockquote>
<p>大顶堆：根节点的数值大于孩子节点，完全二叉树的左右子树同时满足这个条件。<br>小顶堆：根节点的数值小于孩子节点，完全二叉树的左右子树同时满足这个条件。</p>
</blockquote>
<p>从这种数据结构中我们可以发现：大顶堆的根节点也就是数组的第一个元素必定是最大值，而小顶堆必定是最小值，看到这，我想大家已经大概能感觉的到堆这种数据结构为什么可以用来排序了。</p>
<p>在来看个大顶堆和小顶堆的图解吧：</p>
<p><img src="大顶堆与小顶堆.jpg" alt="这里写图片描述"></p>
<hr>
<h2 id="堆排序的过程"><a href="#堆排序的过程" class="headerlink" title="堆排序的过程"></a><strong>堆排序的过程</strong></h2><p>要想写出堆排序的代码，首先我们一定要清楚堆排序的过程，根据堆这种数据结构的特性，我总结了一下堆排序的过程：</p>
<ol>
<li>首先我们需要将一个数组初始化为堆；</li>
<li>在初始化堆的过程中我们必定要移动数组中元素的位置；</li>
<li>初始化完成之后，如果我们建立的是大顶堆，那么数组中的第一个元素就是数组的最大值，小顶堆就是最小值；</li>
<li>然后我们将最大值（最小值）和堆中的最后一个叶子节点（数组中的最后一个元素）进行交换，是不是类似于选择排序。可以预测到，如果是大顶堆，那么我们将会进行升序排序，如果是小顶堆，我们将会进行降序排序；</li>
<li>在进行了上一个步骤之后我们需要重新初始化堆，然后重复以上步骤，直到循环结束。</li>
</ol>
<p>在上面的排序过程中，有很多细节没有说，只是在脑中大致建立起一个堆排序的过程，下面我们仔细研究一下其中的细节。</p>
<h3 id="堆的初始化"><a href="#堆的初始化" class="headerlink" title="堆的初始化"></a><strong>堆的初始化</strong></h3><p>堆的初始化实际上就是数组元素的移动与交换，只不过这种交换发生在孩子节点与父节点之间。假设我们要建立的是大顶堆，我们只要保证每棵左右子树都是堆并且都是大顶堆那么最后整棵完全二叉树必然是大顶堆。根据完全二叉树的结构我们可以得到，假设我们的数组有n个元素，那么对应的完全二叉树的叶子节点就有(n+1)/2个，每棵子树的根节点的下标（0单元进行存储）都是从(n/2)-1开始。叶子节点已经有序，可以单独看做已经初始化好的子堆，也就说我们只要从节点(n/2)-1处开始，分别计算出当前节点的左右孩子，先拿出值最大的孩子，然后将此孩子与父节点进行比较，如果孩子节点小于父节点，说明此子树已经是一子堆，直接考虑前一个非叶子节点，<strong>如果此孩子大于父节点，则需要将孩子节点与父节点互换后再考虑后面的结点，直至以这个节点为根的子树是一个堆！就相当于将这个比较小的节点不断下沉的画面。然后再考虑前一个非叶子节点。</strong>我再给大家一张图，很直观：</p>
<p><img src="堆的初始化.jpg" alt="这里写图片描述"></p>
<p>如图，我们不对叶子节点进行考虑，直接从36处进行调整，而我上面着重标注的那段话，就是图d和图e。</p>
<h3 id="根节点的删除"><a href="#根节点的删除" class="headerlink" title="根节点的删除"></a><strong>根节点的删除</strong></h3><p>与其叫做根节点的删除，不如说是根节点与n-i  (i=1,2,3… …)处节点的互换，这样我们就相当于每次将当前数组的最大值放到数组的最后面，也就是实现了升序。可以看到，每建立一次堆，下次重新初始化堆的时候节点数量都会少一，那么当整个数组有序的时候也就是当只有一个节点进行堆的初始化的时候。</p>
<hr>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h2><p>好了，堆排序的思想至此已经完全清楚了，按照这个思路我实现了大顶堆的排序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Heap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> local)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Heap :: swap(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> local) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">array</span>[local];</span><br><span class="line">    <span class="built_in">array</span>[local] = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">array</span>[<span class="number">0</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Heap :: createHeap(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> i, <span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="comment">//先找到当前节点的左右孩子节点</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">//保存当前节点的值</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"l: "</span> &lt;&lt; l &lt;&lt; <span class="string">" r: "</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l &lt; size) &#123;</span><br><span class="line">        <span class="comment">//先找到数值较大的孩子</span></span><br><span class="line">        <span class="keyword">if</span>(l == size<span class="number">-1</span>) &#123;</span><br><span class="line">            k = l;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            k = (<span class="built_in">array</span>[l] &gt;= <span class="built_in">array</span>[r] ? l : r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将孩子和父节点进行比较</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[k] &lt;= temp) &#123;</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="built_in">array</span>[k];</span><br><span class="line">            i = k;</span><br><span class="line">            l = <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">            r = l+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Heap :: sort(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="comment">//先找到第一个非叶子节点</span></span><br><span class="line">    <span class="keyword">int</span> not_leafP = size/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> local = size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = not_leafP; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//建立子堆</span></span><br><span class="line">        createHeap(<span class="built_in">array</span>, i, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将堆顶元素插入到数组尾的有序区间中</span></span><br><span class="line">    swap(<span class="built_in">array</span>, --local);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[N];</span><br><span class="line">    Heap heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当只有一个节点进行初始化堆的时候，数组有序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> size = N; size &gt; <span class="number">1</span>; size--) &#123;</span><br><span class="line">        heap.sort(<span class="built_in">array</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小顶堆的实现代码和大顶堆没有区别，故不在列出。</p>
<hr>
<h2 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a><strong>效率分析</strong></h2><p><strong>时间复杂度</strong>：堆排序的时间代价主要花费在建立初始堆和调整为新堆时所反复进行的“筛选上”，由代码可知，我们总共建立了n-1次堆，建立新堆时总共进行的比较次数最多为{2[log2(n-1)+log2(n-2)+log2(n-3)… … +log2]} &lt; 2n[(log2(n)]，所以堆排序的时间复杂度为O(nlog2(n))。</p>
<p><strong>空间复杂度</strong>：只需要一个辅助空间，为O(1)。</p>
<p>最后，堆排是一种不稳定的排序。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/07/22/排序-快速排序分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/排序-快速排序分析/" itemprop="url">
                  排序--快速排序分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-22 00:20:16" itemprop="dateCreated datePublished" datetime="2017-07-22T00:20:16+08:00">2017-07-22</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">1.5k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>快速排序实现代码：<a href="https://github.com/championheng/Datastruct-Algorithm/tree/master/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">快速排序</a></p>
<p>可以看到我的代码有一个错误版，我在这里给大家分析一下为什么会出现错误，并且将之记录以便今后进行查阅。</p>
<hr>
<h2 id="快速排序（错误版分析）"><a href="#快速排序（错误版分析）" class="headerlink" title="快速排序（错误版分析）"></a><strong>快速排序（错误版分析）</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Quick :: process(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="built_in">array</span>[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l != r) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[r] &gt;= temp) r--;</span><br><span class="line">        <span class="built_in">array</span>[l] = <span class="built_in">array</span>[r];</span><br><span class="line">        l++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">array</span>[l] &lt;= temp) l++;</span><br><span class="line">        <span class="built_in">array</span>[r] = <span class="built_in">array</span>[l];</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[l] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上是我自己实现的单趟快速排序。</p>
<hr>
<h2 id="快排的算法思想"><a href="#快排的算法思想" class="headerlink" title="快排的算法思想"></a><strong>快排的算法思想</strong></h2><p>从待排序列中任意选择一个记录，以该记录为关键字，凡数组中元素小于该关键字的都移动至该关键字前面，反之移动到后面。致使一趟快速排序之后，以关键字为中点将数组分割成左右两个序列。然后分别对两个子序列递归进行快速排序，直至每个子序列中只含有一个元素为止。</p>
<p>为什么上面这个代码会出现段错误，首先我们来看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">array</span>[r] &gt;= temp) r--;</span><br></pre></td></tr></table></figure>
<p>我在上面的while循环里面设定了l != r，也就是说一趟快速排序结束的标志就是当l == r的时候，然后在进行元素和关键字记录比较的时候，并没有重新写上l &lt; r,考虑这种情况：</p>
<blockquote>
<p>0 9 8 7 6 5 4 3 2 1</p>
</blockquote>
<p>当我以0为关键字的时候，r再一直减小，然后r会越界，直到拿到一个垃圾数据比关键字0还要小的时候第一个循环才会停下来，这是一个错误。</p>
<p>第二个错误就是我多余的进行了l++,r–操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">array</span>[r] &gt;= temp) r--;</span><br><span class="line"><span class="built_in">array</span>[l] = <span class="built_in">array</span>[r];</span><br><span class="line">l++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">array</span>[l] &lt;= temp) l++;</span><br><span class="line"><span class="built_in">array</span>[r] = <span class="built_in">array</span>[l];</span><br><span class="line">r--;</span><br></pre></td></tr></table></figure>
<p>依旧是上面的序列，当前三句运行完之后，l的值会变为1，此时l与r已经相等，然而我又在后三句的最后进行了r–操作，此时会让l &gt; r,最外层的while循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l != r)</span><br></pre></td></tr></table></figure>
<p>就会失效，然后也就发生了段错误，改正之后，运行正确。</p>
<hr>
<h2 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a><strong>效率分析</strong></h2><p>快速排序的时间代价取决与关键字的选择，最简单的方法就是选择第一个记录或最后一个记录，但这样的弊端已然很明显，在每次进行递归分割的时候，如果是正序，那么就会将剩余记录全部分到一个序列当中而另一个序列为空。假如有10个数，第一趟经过9次比较，左半序列为空，第二趟经过8次比较，左半序列为空… …以次类推共需要n-1趟排序，比较次数为O(n2)，等同于冒泡排序。</p>
<p>为避免这种情况，我们可以选取中间位置对应记录的关键字。</p>
<p>最好的情况下，每次分割都将序列分为两个长度相等的子序列，则总共就需要分割log2N次，因此算法的时间代价在最好情况下就是O(N*log2N)，比较幸运的是，快速排序的平均时间复杂度就是这个值，所以快速排序仍然是一种非常高效的排序方法。</p>
<p>空间复杂度：快排需要分割log2N次，每次都需要一个辅助空间，因此快速排序的空间复杂度为O(log2N)。</p>
<p>最后，快速排序并不稳定。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/07/21/排序-归并排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/21/排序-归并排序/" itemprop="url">
                  排序--归并排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-21 15:04:15" itemprop="dateCreated datePublished" datetime="2017-07-21T15:04:15+08:00">2017-07-21</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">4.5k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">4 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="了解归并"><a href="#了解归并" class="headerlink" title="了解归并"></a><strong>了解归并</strong></h2><p>归并排序算法和快速排序算法是java.util.Arrays中使用的排序算法。对于一般的基本数据类型，Arrays.sort函数使用双轴快速排序算法，而对于对象类型使用归并排序（准确的说使用的是TimSort排序算法，它是归并排序的优化版本）。这样做的原因有两点，第一个原因，归并排序是稳定的，而快速排序不是稳定的。第二个原因，对于基本数据类型，排序的稳定性意义不大，但对于复合数据类型（比如对象）排序的稳定性就能帮助我们保持排序结果的某些性质。</p>
<p>归并排序也是一种基于分治法的排序。它是将原始无序序列划分成两个子序列，然后分别对每个子序列递归的进行排序，最后再将有序子序列进行合并。</p>
<hr>
<h2 id="自顶向下归并排序"><a href="#自顶向下归并排序" class="headerlink" title="自顶向下归并排序"></a><strong>自顶向下归并排序</strong></h2><p>自顶向下主要使用递归的思想，要保证整体序列有序，我们就应该同时保证原数组的左子序与右子序同时有序，然后将两个子序进行合并，然而要保证左子序和右子序有序，我们就要保证左子序的左右子序有序，然后进行合并；右子序的左右子序有序，然后进行合并… ….处理这种重复的工作，我们需要的就是递归。</p>
<p><strong>图解自顶向下归并排序：</strong></p>
<p><img src="自顶向下归并排序.jpg" alt="这里写图片描述"></p>
<hr>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a><strong>算法思想</strong></h2><blockquote>
<ul>
<li>既然我们要拆分数组，我们需要一个中枢值，它就是原数组的中点或近似中点的地方；</li>
<li>我们需要一个辅助空间，它用来保存当前需要合并的左右子序；</li>
<li>从图解中我们可以很清楚的看到，我们刚开始不断地将原数组拆分，直到保证每个子数组都有序，很显然，这个子数组就是单个元素；</li>
<li>合并子数组，将辅助数组中合并后产生的新数组覆盖至原数组，我们需要对原数组进行刷新。</li>
</ul>
</blockquote>
<p>下面是自顶向下的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 11</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergeTD</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *array_temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MergeTD(<span class="keyword">int</span> array_temp[]) &#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; array_temp = array_temp;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//我对sort函数进行了重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> mid, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MergeTD :: sort(<span class="keyword">int</span> <span class="built_in">array</span>[]) &#123;</span><br><span class="line">	<span class="comment">//进行归并排序，需要排序的数组和左右两个指标</span></span><br><span class="line">    sort(<span class="built_in">array</span>, <span class="number">0</span>, SIZE<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MergeTD :: sort(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">	<span class="comment">//当已经拆分为单个元素或l已经大于r的时候退出当前函数</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">	<span class="comment">//计算中点值</span></span><br><span class="line">    <span class="keyword">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对左边进行拆分</span></span><br><span class="line">    sort(<span class="built_in">array</span>, l, mid);</span><br><span class="line">    <span class="comment">//对右边进行拆分</span></span><br><span class="line">    sort(<span class="built_in">array</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//进行归并操作</span></span><br><span class="line">    merge(<span class="built_in">array</span>, mid, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MergeTD :: merge(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> mid, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = l, n = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将归并的数组存放到临时数组中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt;= r; k++) &#123;</span><br><span class="line">        array_temp[k] = <span class="built_in">array</span>[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//归并操作在原数组上只对拆分的这一部分有效</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m &gt; mid)</span><br><span class="line">            <span class="built_in">array</span>[i] = array_temp[n++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; r)</span><br><span class="line">            <span class="built_in">array</span>[i] = array_temp[m++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array_temp[n] &lt; array_temp[m])</span><br><span class="line">            <span class="built_in">array</span>[i] = array_temp[n++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">array</span>[i] = array_temp[m++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[SIZE];</span><br><span class="line">    <span class="comment">//辅助数组，用来存储每个有序的小数组</span></span><br><span class="line">    <span class="keyword">int</span> array_temp[SIZE];</span><br><span class="line">    <span class="function">MergeTD <span class="title">TDMerge</span><span class="params">(array_temp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//归并排序</span></span><br><span class="line">    TDMerge.sort(<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a><strong>效率分析</strong></h2><p>归并排序的时间主要花在了划分序列，子序列的排序过程以及合并过程，由于划分序列的时间为常数，对一个长度为n的记录序列进行归并排序，调用一趟归并排序的操作是调用n/2h次合并算法，时间复杂度为O(n)。整个归并排序需要进行logN趟归并操作，时间复杂度O(n) = NlogN。</p>
<p>空间复杂度：需要一个空间大小为N的<strong>辅助数组来存放待排序记录</strong>，空间杂度为O(n)。</p>
<p>最后，归并排序是稳定的。</p>
<hr>
<h2 id="自底向上归并排序"><a href="#自底向上归并排序" class="headerlink" title="自底向上归并排序"></a><strong>自底向上归并排序</strong></h2><p>直接看图解吧：</p>
<p><img src="自底向上归并排序.png" alt="这里写图片描述"></p>
<p>可以看到在自顶向下归并排序中，我们先是对数组进行了不断的拆分，然后又合并，而在自底向上的归并中，我们不再对数组进行拆分，因为单个元素始终有序，所以我们只要刚开始控制子数组的长度为1，然后进行一一合并，合并后的子数组长度为2，那么我们就进行两两合并… …可以看到，自底向上的代码是比自顶向下的代码要好写的。</p>
<p>在这里我们需要注意的一点是数组按照归并长度划分，最后一个子数组可能不满足长度要求，这个情况需要特殊处理。自底向上一般使用循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aux[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//刚开始子数组长度为1，然后进行一一归并，两两归并，四四归并... ...当子数组长度大于等于原数组长度时，整个数组有序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//将原数组复制到一个临时数组之中</span></span><br><span class="line">        <span class="built_in">memcpy</span>(aux, <span class="built_in">array</span>, <span class="number">4</span>*size);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//进行归并操作，首先要判断好每次归并的start，mid，end</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; size; start += i*<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + i*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> m = start, n = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当我们对数组进行划分的时候，最后一个子数组的end有时候会大于数组长度，此时我们应该选取整体数组的长度</span></span><br><span class="line">            <span class="keyword">if</span>(end &gt;= size) &#123;</span><br><span class="line">                end = size<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开始进行单趟归并</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = start; k &lt;= end; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(m &gt; mid) &#123;</span><br><span class="line">                    <span class="built_in">array</span>[k] = aux[n++];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &gt; end) &#123;</span><br><span class="line">                    <span class="built_in">array</span>[k] = aux[m++];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(aux[m] &gt; aux[n]) &#123;</span><br><span class="line">                    <span class="built_in">array</span>[k] = aux[n++];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">array</span>[k] = aux[m++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line">    <span class="built_in">array</span> = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; <span class="built_in">array</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(<span class="built_in">array</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/06/06/Java网络爬虫-海量URL去重之布隆过滤器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/06/Java网络爬虫-海量URL去重之布隆过滤器/" itemprop="url">
                  Java网络爬虫--海量URL去重之布隆过滤器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-06 19:40:14" itemprop="dateCreated datePublished" datetime="2017-06-06T19:40:14+08:00">2017-06-06</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java网络爬虫/" itemprop="url" rel="index"><span itemprop="name">Java网络爬虫</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">3.5k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">3 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介布隆过滤器"><a href="#简介布隆过滤器" class="headerlink" title="简介布隆过滤器"></a><strong>简介布隆过滤器</strong></h2><p>当我们要对海量URL进行抓取的时候，我们常常关心一件事，就是URL的去重问题，对已经抓取过的URL我们不需要在进行重新抓取。在进行URL去重的时候，我们的基本思路是将拿到的URL与已经抓取过的URL队列进行比对，看当前URL是否在此队列中，如果在已抓取过的队列中，则将此URL进行舍弃，如果没有在，则对此URL进行抓取。看到这，如果有哈希表基础的同学，很自然的就会想到那么如果用哈希表对URL进行存储管理的话，那么我们对于URL去重直接使用HashSet进行URL存储不就行了。事实上，在URL非海量的情况下，这的确是一种很不错的方法，但哈希表的缺点很明显：费存储空间。</p>
<p>对于像Gmail那样公众电子邮件提供商来说，总是需要过滤掉来自发送垃圾邮件的人和来及邮件的E-mail地址。然而全世界少说也有几十亿个发垃圾邮件的地址，将他们都存储起来需要大量的网络服务器。如果用哈希表，每存储一亿个E-mail地址，就需要1.6GB的内存（用哈希表实现的具体实现方式是将每一个E-mail地址对应成一个八字节的信息指纹，然后将这个信息存储在哈希表中，但是由于哈希表的存储效率一般只有50%，一旦存储空间大于表长的50%，查找速度就会明显的下降（容易发生冲突），即存储一个E-mail我们需要给它分配十六字节的大小，一亿个地址的大小大约就要1.6GB内存）。因此存储几十亿的地址就要需要大约上百GB的内存，除非是超级计算机，一般服务器是无法存储的。</p>
<p>关于哈希表的相关知识，请戳这篇博客—<strong><a href="http://blog.csdn.net/championhengyi/article/details/72834757" target="_blank" rel="noopener">查找–理解哈希算法并实现哈希表</a></strong></p>
<hr>
<h2 id="具体实现思想"><a href="#具体实现思想" class="headerlink" title="具体实现思想"></a><strong>具体实现思想</strong></h2><p>在这种情况下，巴顿·布隆在1970年提出了布隆过滤器，它只需要哈希表的1/8到1/4的大小就可以解决同样的问题。我们来看一下其工作原理：</p>
<p>首先我们需要一串很长的二进制向量，与其说是二进制向量，我觉得不如说是一串很长的“位空间”，其具体原理大家可以了解一下Java中BitSet类的算法思想。它用位空间来存储我们平常的整数，可以将数据的存储空间急剧压缩。然后需要一系列随机映射函数（哈希函数）来将我们的URL映射成一系列的数，我们将其称为一系列的“<strong>信息指纹</strong>”。</p>
<p>然后我们需要将刚才产生的一系列信息指纹对应至布隆过滤器中，也就是我们刚才设置的那一串很长的位空间（二进制向量）中。位空间中各个位的初始值为0。我们需要将每个信息指纹都与其布隆过滤器中的对应位进行比较，看看其标志位是否已经被设置过，如果判断之后发现一系列的信息指纹都已被设置，那么就将此URL进行过滤<strong>（说明此URL可能存在于布隆过滤器中）</strong>。事实上，我们将每个URL用随机映射函数来产生一系列的数之所以能被称之为信息之纹，就是因为这一系列的数基本上是独一无二的，每个URL都有其独特的指纹。虽然布隆过滤器还有极小的可能将一个没有抓取过的URL误判为已经抓取过，但它绝对不会对已经抓取过的URL进行重新抓取。然后刚才的误判率一般来说我们基本上可以忽略不计，等下我给大家列出一张表格大家直观感受一下。</p>
<p>对于为什么会出现误判的情况，请参考此篇博客—<strong><a href="https://www.cnblogs.com/cpselvis/p/6265825.html" target="_blank" rel="noopener">布隆过滤器(Bloom Filter)的原理和实现</a></strong></p>
<hr>
<h2 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a><strong>算法总结</strong></h2><p>现在我们来总结一下该怎么设计一个布隆过滤器：</p>
<ol>
<li>创建一个布隆过滤器，开辟一个足够的位空间（二进制向量）；</li>
<li>设计一些种子数，用来产生一系列不同的映射函数（哈希函数）；</li>
<li>使用一系列的哈希函数对此URL中的每一个元素（字符）进行计算，产生一系列的随机数，也就是一系列的<strong>信息指纹</strong>；</li>
<li>将一系列的信息指纹在布隆过滤器中的相应位，置为1。</li>
</ol>
<hr>
<h2 id="代码实现（Java）"><a href="#代码实现（Java）" class="headerlink" title="代码实现（Java）"></a><strong>代码实现（Java）</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBloomFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置布隆过滤器的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    <span class="comment">// 产生随机数的种子，可产生6个不同的随机数产生器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] seeds = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">61</span>&#125;;</span><br><span class="line">    <span class="comment">// Java中的按位存储的思想，其算法的具体实现（布隆过滤器）</span></span><br><span class="line">    <span class="keyword">private</span> BitSet bits = <span class="keyword">new</span> BitSet(DEFAULT_SIZE);</span><br><span class="line">    <span class="comment">// 根据随机数的种子，创建6个哈希函数</span></span><br><span class="line">    <span class="keyword">private</span> SimpleHash[] func = <span class="keyword">new</span> SimpleHash[seeds.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置布隆过滤器所对应k（6）个哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBloomFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seeds.length; i++) &#123;</span><br><span class="line">            func[i] = <span class="keyword">new</span> SimpleHash(DEFAULT_SIZE, seeds[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String value = <span class="string">"stone2083@yahoo.cn"</span>;</span><br><span class="line">        SimpleBloomFilter filter = <span class="keyword">new</span> SimpleBloomFilter();</span><br><span class="line"></span><br><span class="line">        out.println(filter.contains(value));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHash</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> seed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认构造器，哈希表长默认为DEFAULT_SIZE大小，此哈希函数的种子为seed</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleHash</span><span class="params">(<span class="keyword">int</span> cap, <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cap = cap;</span><br><span class="line">            <span class="keyword">this</span>.seed = seed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> len = value.length();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 将此URL用哈希函数产生一个值（使用到了集合中的每一个元素）</span></span><br><span class="line">                result = seed * result + value.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 产生单个信息指纹</span></span><br><span class="line">            <span class="keyword">return</span> (cap - <span class="number">1</span>) &amp; result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否已经包含该URL</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 根据此URL得到在布隆过滤器中的对应位，并判断其标志位（6个不同的哈希函数产生6种不同的映射）</span></span><br><span class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</span><br><span class="line">            ret = ret &amp;&amp; bits.get(f.hash(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的注解已经足够详细，如果大家还有什么疑惑，可以在评论区进行讨论交流～～</p>
<hr>
<h2 id="布隆过滤器误判率表"><a href="#布隆过滤器误判率表" class="headerlink" title="布隆过滤器误判率表"></a><strong>布隆过滤器误判率表</strong></h2><p><img src="布隆过滤器误判率表.png" alt="这里写图片描述"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/06/01/查找-理解哈希算法并实现哈希表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/01/查找-理解哈希算法并实现哈希表/" itemprop="url">
                  查找--理解哈希算法并实现哈希表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-01 22:12:17" itemprop="dateCreated datePublished" datetime="2017-06-01T22:12:17+08:00">2017-06-01</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">3.3k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">3 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们喜欢使用数组进行数据的查找，就是因为数组是一种“随机存取”的数据结构，我们根据数组的起始地址和数组元素的下标值就可以直接计算出每一个数组元素的存储位置，所以它的查找时间是O(1)，而与数组的个数无关。</p>
<p>我们在这个思想的基础上，可以联想到，如果有一种数据结构，让我们在进行关键字查找的时候，也可以像数组一样，进行随机存储，使其时间复杂度从O(n)降到O(1)，那就可以大大提高查找的效率。我们的前辈们基于这种想法发明了<strong>散列方法，也就是哈希或关键字地址计算方法</strong>。</p>
<hr>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a><strong>基本思想</strong></h2><p>我们试图寻找一种关系，可以根据我们要存储的关键字（key）然后使用这种关系直接计算出它应该存储的位置（p），一旦建立起这种关系，那么我们在之后一旦需要查找此关键字的话，只需计算此对应关系所产生的值就可以直接得到关键字所在的地址，那么查找的时间复杂度也就降到了O(1)，我们将刚才所说的转换为一种数学关系：<code>p（位置）= H（key）</code>。</p>
<p>其中H就是对应关系，我们称之为哈希函数，p被成为散列地址。因此，哈希算法的核心就是找到哈希函数（H），通过这个函数来组织存储并进行查找。</p>
<hr>
<h2 id="Hash函数的构造方法"><a href="#Hash函数的构造方法" class="headerlink" title="Hash函数的构造方法"></a><strong>Hash函数的构造方法</strong></h2><p>我们先来看一个问题：</p>
<p>假如我们现在有一些单词（关键字）：and，cell，do，flag … … 等等，如果我们的哈希函数取值为关键字的第一个字母在字母表中的字典顺序，那么关键字会依次分布在散列地址中。然而当我们还使用这套规则进行and，ant，apple，cell，do … …等等字母的存储，那么就会产生“地址冲突”的问题，因为前三个单词在字母表中的顺序是一样的。</p>
<p>由于Hash函数是一个压缩映像，因此在实际应用中，很少存在不产生冲突的hash函数，因此，<strong>如何构造恰当的Hash函数，使得节点“均匀分布”</strong>，尽量少的产生冲突就是我们必须要解决的问题之一了。</p>
<p>hash函数的构造原则为简单和均匀：</p>
<blockquote>
<ul>
<li>hash函数本身运算简单，便于计算；</li>
<li>hash函数值必须在散列地址范围内，且分布均匀，地址冲突尽可能少。</li>
</ul>
</blockquote>
<p>有几种常用的hash函数的构造方法：</p>
<p><strong>1. 除留余数法</strong></p>
<p>该方法是最为简单常用的一种方法，假设表长为m（散列地址的长度），<strong>p为小于等于表长m的最大素数</strong>，则hash函数为H（key）= key % p。H就是在散列地址中位置。</p>
<p>p的取值应该是一个质因子，这样才能减少“地址冲突”的可能性。</p>
<p><strong>2. 数字分析法</strong></p>
<p>假设关键字集合中的每个关键字都是由s位数字组成（k1, k2, … , kn），如果可以预先估计出全体关键字的每一位上各种数字出现的频度时，分析关键字集中的全体，并从中提取出分布均匀的若干位或它们的组合作为hash地址。</p>
<p>例如：H（49646542）= 465， H（49673242）= 732 … …</p>
<p>经过分析，各个关键字中第4~6位中的取值比较均匀，则hash函数为H（key）= d4d5d6。</p>
<p><strong>3. 平方取中法</strong></p>
<p>由于整数相除的运行速度通常比相乘要慢，所以我们需要有意识的避免使用除余法可以提高散列算法的运行时间。平方取中法：首先通过求关键字的平方值扩大相近数的差别，然后根据表长度取中间的几位数作为hash函数值。又因为一个乘积的中间几位数和乘数的每一位都相关，因此由此产生的散列地址较为均匀。</p>
<p><strong>4. 分段叠加法</strong></p>
<p>有时关键字所含的位数很多，采用平方取中法计算太复杂，则可将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分进行叠加，叠加和（舍去进位）作为散列地址。</p>
<p>具体的叠加方式有<strong>移位叠加和折叠叠加</strong>。</p>
<p><strong>5. 基数转换法</strong></p>
<p>首先将关键字看做是另一种进制的数，然后在转换成原来进制的数，再选择其中几位作为散列地址。</p>
<p>例如：把十进制（362081）看做13进制的数，最后结果再转换为十进制（1289744），假设散列长度是10000，则可取低四位9744作为散列地址。</p>
<p>一般来说我们还是应该根据实际情况采用恰当的哈希算法，并测试它的性能，一般考虑下列因素：</p>
<blockquote>
<ul>
<li>计算hash函数所需的时间；</li>
<li>关键字的长度；</li>
<li>散列表的大小；</li>
<li>关键字分布的情况；</li>
<li>记录查找的频率。</li>
</ul>
</blockquote>
<hr>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a><strong>处理冲突的方法</strong></h2><p>在上面我们说过，实际情况中我们是不可能不产生地址冲突的，所以，一旦我们有地址冲突，我们应该怎么办？我们自然而然的想到，那就为产生冲突的地址寻找下一个散列地址。</p>
<h3 id="开放定址（再散列）法"><a href="#开放定址（再散列）法" class="headerlink" title="开放定址（再散列）法"></a><strong>开放定址（再散列）法</strong></h3><p>基本思想：</p>
<p>当关键字key的初始散列地址h0=H（key）出现冲突时，以h0为基础查找下一个地址h1，如果h1仍然冲突，再以h0为基础，产生另一个散列地址h2… … 直到找出一个不冲突的地址hi，将相应元素存入其中，这种方法有一个通用的<strong>再散列函数</strong>形式：<code>hi=（（H（key）+ di）% m</code>。</p>
<p>其中h0=H（key），m为表长，di为增量序列。增量序列的取值方式不同，对应不同的再散列方式：</p>
<p><strong>1. 线性探测再散列</strong></p>
<blockquote>
<p><strong>di = c × i</strong></p>
</blockquote>
<p>最简单的情况：c = 1。</p>
<p>特点：冲突放生时，顺序查看表中下一个单元，直到找到一个空单元或查遍全表。值得注意的是：由于使用的是%（取余）运算符，所以它和循环队列有点相似，表尾的后边是表头，表头的前边是表尾。</p>
<p><strong>2. 二次探测再散列</strong></p>
<blockquote>
<p><strong>di = 1^2，-1^2，2^2，-2^2,  … … ，k^2，-k^2   （k&lt;=(m/2)）</strong></p>
</blockquote>
<p>特点：冲突发生时分别在表的右，左进行跳跃式探测，较为灵活，不易产生聚集，缺点是不能探查到整个散列地址空间。</p>
<p><strong>3.随机探测再散列</strong></p>
<blockquote>
<p><strong>di = 伪随机数</strong></p>
</blockquote>
<p>特点：建立一个随机数发生器，并给定一个随机数作为起始点。</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a><strong>链地址法</strong></h3><p>基本思想：把所有具有地址冲突的关键字链在同一个单链表中。若哈希表的长度是m，则可以将哈希表定义为一个有m个头指针组成的指针数组。散列地址为i的记录，均插到以指针数组第i个单元为头指针的单链表中。</p>
<hr>
<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a><strong>性能指标</strong></h2><p>衡量查找效率的主要性能指标就是平均查找长度（ASL）。<code>ASL（succ）=（比较次数之和）/（关键字个数）</code>。</p>
<p>比较次数代表的是关键字放入散列地址中为避免地址冲突需要跟当前散列地址中是否已经有值而进行判断的次数。</p>
<p>ASL越小，性能越好。</p>
<hr>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a><strong>哈希表</strong></h2><p>有了前面的基础，我们来试着自己构建一个哈希表，并实现哈希表的插入，查找和删除。</p>
<h3 id="哈希表的创建"><a href="#哈希表的创建" class="headerlink" title="哈希表的创建"></a><strong>哈希表的创建</strong></h3><ol>
<li>首先将表中各节点的关键字置空；</li>
<li>使用插入算法将给定的关键字序列一次插入哈希表中。</li>
</ol>
<h3 id="哈希表的插入"><a href="#哈希表的插入" class="headerlink" title="哈希表的插入"></a><strong>哈希表的插入</strong></h3><ol>
<li>通过查找算法找到待插记录在表中的位置；</li>
<li>若在表中找到待插记录，则不必插入；若没有找到，查找算法给出一个单元空闲的散列地址，并插入到该地址单元中。</li>
</ol>
<h3 id="哈希表的查找"><a href="#哈希表的查找" class="headerlink" title="哈希表的查找"></a><strong>哈希表的查找</strong></h3><ol>
<li>根据待查找记录的关键字和建表时的哈希函数计算散列地址；</li>
<li>若该地址单元为空，则查找失败；若不为空，则将该单元中的关键字与待查记录的关键字进行比较：<br>　　如果相等，则查找成功；<br>　　如果不等，则按建表时设定的处理冲突的方法找下一个地址。</li>
<li>重复上述步骤2，直至某个单元为空，则查找失败或者与待查记录的关键字进行比较，相等则查找成功。</li>
</ol>
<h3 id="哈希表的删除"><a href="#哈希表的删除" class="headerlink" title="哈希表的删除"></a><strong>哈希表的删除</strong></h3><p>基于开放地址法的哈希表不能实现真正的删除，只能给被删除节点设置删除标志，以免在删除后找不到比它晚插入的节点且发生过冲突的节点，也就是说，如果执行真正的删除操作，会中断查找路径，如果必须对哈希表做真正的删除操作，最好采用链地址法处理冲突的哈希表。</p>
<hr>
<h2 id="哈希表的装填因子"><a href="#哈希表的装填因子" class="headerlink" title="哈希表的装填因子"></a><strong>哈希表的装填因子</strong></h2><blockquote>
<p><strong>α = 哈希表中已存入的元素个数 / 哈希表的长度</strong></p>
</blockquote>
<p>α越小，冲突的可能性就越小，但空间利用率就越低；<br>α越大，冲突的可能性就越大，但空间利用率就越高。</p>
<hr>
<h2 id="哈希表的存储效率为何一般只有50"><a href="#哈希表的存储效率为何一般只有50" class="headerlink" title="哈希表的存储效率为何一般只有50%"></a><strong>哈希表的存储效率为何一般只有50%</strong></h2><p>根据上面的装填因子我们可以得知，α越大，产生冲突的的几率也就越大，查找的次数就会变多，然后我们可以看一下查找的时间复杂度计算公式：<code>1/( 1 - n/m )</code>。</p>
<p>n/m就是上面所说的装填因子，我们可以发现，当装填因子大于1/2的时候，查找的时间复杂度就会大于二，所以我们一般会说哈希表的存储效率只有50%。</p>
<hr>
<h2 id="哈希表的实现代码（C语言）"><a href="#哈希表的实现代码（C语言）" class="headerlink" title="哈希表的实现代码（C语言）"></a><strong>哈希表的实现代码（C语言）</strong></h2><p>github链接：<a href="https://github.com/championheng/datastruct-algorithm/blob/master/%E6%9F%A5%E6%89%BE/%E5%93%88%E5%B8%8C%E8%A1%A8.cc" target="_blank" rel="noopener">哈希表</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/05/28/Java网络爬虫-正则表达式之详解贪婪、逐步、独吐量词/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/28/Java网络爬虫-正则表达式之详解贪婪、逐步、独吐量词/" itemprop="url">
                  Java网络爬虫--正则表达式之详解贪婪、逐步、独吐量词
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-28 23:01:57" itemprop="dateCreated datePublished" datetime="2017-05-28T23:01:57+08:00">2017-05-28</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java网络爬虫/" itemprop="url" rel="index"><span itemprop="name">Java网络爬虫</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">1.3k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>除过正则表达式的基本概念与特性还有使用方法之外，我们在解析html的时候，如果要进行字符串的匹配，必须还要熟悉正则表达式之中<strong>量词</strong>的使用法则，今天我们就来谈谈<strong>贪婪、逐步、独吐</strong>这三种量词的使用。</p>
<hr>
<h2 id="贪婪量词"><a href="#贪婪量词" class="headerlink" title="贪婪量词"></a><strong>贪婪量词</strong></h2><p>我们先来看一下经常使用的贪婪量词都有哪些：</p>
<blockquote>
<ul>
<li>X?: X项目（项目也可以理解为X代表的变量，项目比较准确）出现一次或没有。</li>
<li>X*: X项目出现0次或多次。</li>
<li>X+: X项目至少出现1次。</li>
<li>X{n}: X项目出现n次。</li>
<li>X{n, }: X项目至少出现n次。</li>
<li>X{n, m}: X项目出现n次但不超过m次。</li>
</ul>
</blockquote>
<p>下来我们解释贪婪量词为何贪婪。当我们使用贪婪量词进行字符串匹配的时候，如果比较器（Matcher）看到贪婪量词，会将剩下的字符串全部吃掉，然后从字符串的末尾一个个再吐出来，在这个过程中，它还会将吐出来的字符与<strong>规则表达式</strong>进行比较，如果吐出来的字符串符合规则表达式，而吃下的字符串也符合贪婪量词那么就比较成功，我们可以预想到，贪婪量词之所以贪婪，就是因为它会尽可能的找出长度最长的符合文字。</p>
<p>举个例子：</p>
<p>文字：<strong>xfooxxxxxxfoo</strong>，使用规则表达式 “<strong>.*foo</strong>“比较，当碰见贪婪量词 “ <strong>.×</strong>“ (*da不出来～～)，比较器会吃掉剩下的字符串，在这个例子中也就是整个字符串，然后比较器再从后向前一个个将字符吐出来，当吐出foo的时候，foo符合贪婪量词之后的规则表达式，而剩下没吐的字符串也符合贪婪量词的部分，所以就匹配到了整个字符串，所以它尽可能的找出长度最长的符合文字。（<strong>“.”</strong>代表任一字符）</p>
<hr>
<h2 id="逐步量词"><a href="#逐步量词" class="headerlink" title="逐步量词"></a><strong>逐步量词</strong></h2><p>逐步量词也称非贪婪量词或懒惰量词，顾名思义，它和贪婪量词是相对的，它的形式是在贪婪量词之后加上“<strong>?</strong>”，形如：“<strong>.*?</strong>”，在使用逐步量词时，比较器会一边吃掉剩余文字，一边看吃下的文字是否符规则表达式，结果就是逐步量词会找出长度最短的符合文字。</p>
<p>还是上面的例子：</p>
<p>文字：<strong>xfooxxxxxxfoo</strong>，使用规则表达式 “<strong>.×?foo</strong>”比较，当碰见逐步量词 “ <strong>.×?</strong>” (*da不出来～～)，比较器会边吃文字边比较而不会一下将剩余的文字全部吃掉，所以第一个匹配到的字符串就是“<strong>xfoo</strong>”，第二个匹配到的字符串就是“<strong>xxxxxxfoo</strong>”，所以它尽可能的找出长度最短的符合文字。</p>
<hr>
<h2 id="独吐量词"><a href="#独吐量词" class="headerlink" title="独吐量词"></a><strong>独吐量词</strong></h2><p>在贪婪量词之后加上“<strong>+</strong>”，形如：“<strong>.*+</strong>”就是一种独吐量词，在使用独吐量词的时候，如果比较器看到独吐量词，它会将剩下的字符串全部吃掉，然后和贪婪量词相反，它不会吐出文字和剩下的规则表达式比较，而是会将吃下的文字和独吐量词进行比较，如果吃下的字符串符合独吐量词，那么它将不会将吃下的字符串吐出。</p>
<p>依然是上面的例子：</p>
<p>文字：<strong>xfooxxxxxxfoo</strong>，使用规则表达式 “<strong>.*+foo</strong>”比较，当碰见独吐量词 “ <strong>.×+</strong>” (*da不出来～～)，比较器会吃掉剩下的字符串，在这个例子中也是整个字符串，然后它发现吃下的整个字符串已经满足独吐量词“<strong>.×+</strong>”，所以它就不会将字符串再吐出，然后会因为没有剩余的字符串符合剩下的规则表达式“<strong>foo</strong>”而产生没有找到相匹配的字符串的情况，最后的结果就是没有任何文字符合。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/04/14/MySQL数据库-MySQL数据库语句、坑点总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/14/MySQL数据库-MySQL数据库语句、坑点总结/" itemprop="url">
                  MySQL数据库--MySQL数据库语句、坑点总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-14 18:04:23" itemprop="dateCreated datePublished" datetime="2017-04-14T18:04:23+08:00">2017-04-14</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/MySQL数据库/" itemprop="url" rel="index"><span itemprop="name">MySQL数据库</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">7.8k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">7 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MySQL实用语句操作"><a href="#MySQL实用语句操作" class="headerlink" title="MySQL实用语句操作"></a><strong>MySQL实用语句操作</strong></h2><p>1.清空数据库表的同时将id的增长顺序重新设为从0开始：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 数据库表名</span><br></pre></td></tr></table></figure>
<p>2.在知道数据库原密码的时候进行修改密码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root -p password "new password"</span><br></pre></td></tr></table></figure>
<p>3.将选定数据库导出至sql脚本：（只导出表结构）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p -d "数据库名" &gt; "sql脚本"</span><br></pre></td></tr></table></figure>
<p>4.将选定数据库导出至sql脚本（表结构和数据全部导出）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p "数据库名" &gt; "sql脚本"</span><br></pre></td></tr></table></figure>
<p>5.将mysql脚本导入至数据库：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p "数据库名" &lt; "sql脚本"</span><br></pre></td></tr></table></figure>
<p>6.查看字段编码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> &lt;表名&gt;</span><br></pre></td></tr></table></figure>
<p>7.查看表编码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="解决中文乱码"><a href="#解决中文乱码" class="headerlink" title="解决中文乱码"></a><strong>解决中文乱码</strong></h2><p>原文链接：<a href="http://blog.csdn.net/springsunss/article/details/70337915" target="_blank" rel="noopener">整理 ： 查看和修改 mysql库、表、字段编码</a></p>
<p>文中好像有些许错误… …</p>
<hr>
<h2 id="忘记数据库密码，我们应该怎么办？"><a href="#忘记数据库密码，我们应该怎么办？" class="headerlink" title="忘记数据库密码，我们应该怎么办？"></a><strong>忘记数据库密码，我们应该怎么办？</strong></h2><p>此方法在Centos7下进行了有效测试：</p>
<p>1.编辑/etc/my.cnf实现免密登录，确保你的数据库不会被其他人进行恶意修改。<br>找到 <strong>[mysqld]</strong> 段，并给段中任意地方加上一句：<strong>skip-grant-tables</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip-<span class="keyword">grant</span>-<span class="keyword">tables</span></span><br></pre></td></tr></table></figure>
<p>2.重启mysql服务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysql.service</span><br></pre></td></tr></table></figure>
<p>3.在数据库中修改密码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> mysql;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> <span class="keyword">Password</span> = <span class="keyword">password</span>(<span class="string">'new password'</span>) <span class="keyword">WHERE</span> <span class="keyword">User</span> = <span class="string">'root'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>
<p>4.最后将免密功能再去掉，就可以了。</p>
<hr>
<h2 id="Unknown-column-‘xxx’-in-‘where-clause’"><a href="#Unknown-column-‘xxx’-in-‘where-clause’" class="headerlink" title="Unknown column ‘xxx’ in ‘where clause’"></a><strong>Unknown column ‘xxx’ in ‘where clause’</strong></h2><p>列名不存在的结论，但是，很多时候起始并不是由于列名出错造成的。而是由于拼凑sql语句时对字符类型数据没有用引号引起来造成的。</p>
<p>这个错误我改了三个小时，做了无数测试，一度以为是玄学，来一看一下正确的写法吧，还有这个错误在要拼接的SQL语句是int型的时候，一般是不会出现的… ….</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">statement = connection.prepareStatement(</span><br><span class="line">				"<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> book_class <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'" + labelName + "'</span><span class="string">");</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="避免使用IN或者OR"><a href="#避免使用IN或者OR" class="headerlink" title="避免使用IN或者OR"></a><strong>避免使用IN或者OR</strong></h2><p>(OR会导致扫表)，使用UNION ALL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> article_category=<span class="number">2</span>) <span class="keyword">UNION</span> ALL (<span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> article_category=<span class="number">3</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> article_id <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p><strong>UNION 和UNION ALL 的区别：</strong>在数据库中，UNION和UNION ALL关键字都是将两个结果集合并为一个，但这两者从使用和效率上来说都有所不同。UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。</p>
<p>从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL。</p>
<hr>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a><strong>创建索引</strong></h2><p>执行一个很普通的查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`article`</span> <span class="keyword">WHERE</span> article_category=<span class="number">11</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> article_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>执行时间大约要5秒左右。</p>
<p>建一个索引（组合索引）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_u <span class="keyword">ON</span> article(article_category, article_id);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`article`</span> <span class="keyword">WHERE</span> article_category=<span class="number">11</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> article_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>减少到0.0027秒。</p>
<hr>
<h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a><strong>排序数据</strong></h2><p>排序：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 升序（默认）</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段 <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line">// 降序</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段 <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">// 多个列排序</span><br><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，字段<span class="number">2</span>，字段<span class="number">3</span> <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段<span class="number">1</span> <span class="keyword">DESC</span>，字段<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>注意：用非检索的列排数据是完全合法的。首先按字段1进行排序。</p>
<hr>
<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a><strong>过滤数据</strong></h2><p>不匹配检查：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 不返回字段1的值为1003的行（一般使用!=）</span><br><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，字段<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 字段<span class="number">1</span> &lt;&gt; <span class="number">1003</span>;</span><br></pre></td></tr></table></figure>
<p>范围值检查：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 字段 <span class="keyword">BETWEEN</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>注意：SQL在处理OR操作符前，优先处理AND操作符。解决方式像其他语言一样使用括号。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// IN的功能和OR的完全一样，推荐使用IN，执行更快，更直观，可包含其他<span class="keyword">SELECT</span>语句</span><br><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 字段 <span class="keyword">IN</span> (<span class="number">1002</span>，<span class="number">1003</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段;</span><br></pre></td></tr></table></figure>
<p>通配符：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// %表示任何字符出现任意次数（包括0）（所有以jet开头的单词）</span><br><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，字段<span class="number">2</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 字段 <span class="keyword">LIKE</span> <span class="string">'jet%'</span>;</span><br></pre></td></tr></table></figure>
<p>注意：使用通配符需要在意尾空格。还有一个通配符_只匹配单个字符而不是多个字符。（不要过度使用通配符，时间代价比其它操作符更高，但它的确很有用）</p>
<p>注意：</p>
<blockquote>
<ol>
<li>其中like要求整个数据都要匹配，而REGEXP只需要部分匹配即可。</li>
<li>匹配特殊字符使用\\为前导</li>
<li>如果需要匹配反斜杠（\）字符本身，需要使用\\\</li>
</ol>
</blockquote>
<hr>
<h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a><strong>计算字段</strong></h2><p>拼接（Concat函数）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(字段<span class="number">1</span>，字段<span class="number">2</span>，... ...) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
<p>删除右侧多余空格（RTrim函数）（LTrim，Trim）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(字段<span class="number">1</span>)，<span class="keyword">RTrim</span>(字段<span class="number">2</span>)) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
<p>使用别名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Concat</span>(<span class="keyword">RTrim</span>(字段<span class="number">1</span>), <span class="keyword">RTrim</span>(字段<span class="number">2</span>)) <span class="keyword">AS</span> 别名 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
<p>执行算术计算：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，字段<span class="number">2</span>，字段<span class="number">1</span>*字段<span class="number">2</span> <span class="keyword">AS</span> 字段名 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a><strong>数据处理函数</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段，<span class="keyword">Upper</span>(字段) <span class="keyword">AS</span> 字段 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
<p>文本处理函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Length()</td>
<td>返回串左边长度</td>
</tr>
<tr>
<td>Lower()</td>
<td>将串转换为小写</td>
</tr>
<tr>
<td>Soundex()</td>
<td>返回串的SOUNDEX值（建议百度）</td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换为大写</td>
</tr>
</tbody>
</table>
<p>日期时间处理函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 只比较日期</span><br><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> <span class="built_in">Date</span>(字段) = <span class="string">'YYYY-MM-DD'</span>;</span><br><span class="line"></span><br><span class="line">// 只比较时间</span><br><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> <span class="keyword">Time</span>(字段) = <span class="string">'hh-mm-ss'</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分（推荐使用）</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分（推荐使用）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a><strong>汇总数据</strong></h2><p>聚集函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(字段) <span class="keyword">AS</span> 字段 <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line">// DISTINCT用来聚集不同的值（MySQL 4.x不能使用）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> 字段) <span class="keyword">AS</span> 字段 <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> 字段，<span class="keyword">MIN</span>(字段) <span class="keyword">AS</span> 字段，<span class="keyword">MAX</span>(字段) <span class="keyword">AS</span> 字段，<span class="keyword">AVG</span>(字段) <span class="keyword">AS</span> 字段 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVG()</td>
<td>返回某列平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列行数（注意COUNT(*)与COUNT(column)）</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列最大值 (可应用于日期与文本数据)</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列之和</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a><strong>分组数据</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>过滤分组：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段<span class="number">1</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">//HAVING与WHERE</span><br><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>，<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 字段 &gt;= <span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> 字段<span class="number">1</span> <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>SELECT 子句顺序：</p>
<table>
<thead>
<tr>
<th>子句</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SELECT</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>否</td>
</tr>
<tr>
<td>WHERE</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>否</td>
</tr>
<tr>
<td>HAVING</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>否</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><strong>子查询</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span> <span class="keyword">FROM</span> 表名<span class="number">1</span> <span class="keyword">WHERE</span> 字段<span class="number">2</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> 字段<span class="number">3</span> </span><br><span class="line">	<span class="keyword">FROM</span> 表名<span class="number">2</span> <span class="keyword">WHERE</span> 字段<span class="number">4</span> = 字符串);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 字段<span class="number">1</span>, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> 表名<span class="number">1</span> <span class="keyword">WHERE</span> 字段<span class="number">2</span> = 字段<span class="number">3</span>) <span class="keyword">AS</span> 字段 <span class="keyword">FROM</span> 表名<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="联结"><a href="#联结" class="headerlink" title="联结"></a><strong>联结</strong></h2><p>创建联结：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price(指定列) <span class="keyword">from</span> vendors, products(关系表) <span class="keyword">where</span> vendors.vend_id = products.vend_id <span class="keyword">order</span> <span class="keyword">by</span> vend_name, pro_prod_name;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price(指定列) <span class="keyword">from</span> vendors <span class="keyword">inner</span> <span class="keyword">join</span> products <span class="keyword">on</span> vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
<p>建议使用第二个语法。</p>
<p>笛卡尔积（叉联结）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> vend_name, prod_name, prod_price(指定列) <span class="keyword">from</span> vendors, products(关系表) <span class="keyword">order</span> <span class="keyword">by</span> vend_name, pro_prod_name;</span><br></pre></td></tr></table></figure>
<p>由没有联结条件的表关系返回的结果为笛卡尔积。<strong>检索出的行的数目将是第一个表的行数乘以第二个表中的行数。</strong></p>
<p>联结多个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name, vend_name, prod_price, quantity <span class="keyword">FROM</span> orderitems, products, vendors <span class="keyword">WHERE</span> prodicts.vend_id = vendors.vend_id <span class="keyword">AND</span> orderitems.prod_id = products.prod_id <span class="keyword">AND</span> order_num = <span class="number">20005</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a><strong>高级联结</strong></h2><p>表别名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, cust_contact <span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi <span class="keyword">WHERE</span> c.cust_id = o.cust_id <span class="keyword">AND</span> oi.order_num = o.order_num <span class="keyword">AND</span> prod_id = <span class="string">'TNT2'</span>;</span><br></pre></td></tr></table></figure>
<p>自联结：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 我觉得使用<span class="keyword">SELECT</span>子查询也许更简单</span><br><span class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name <span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2 <span class="keyword">WHERE</span> p1.vend_id = p2.vend_id <span class="keyword">AND</span> <span class="keyword">WHERE</span> p2.prod_id = <span class="string">'DTNTR'</span>;</span><br></pre></td></tr></table></figure>
<p>自然联结：（常用，重点，基本上每个内部联结都是自然联结）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.*, o.order_num, o.order_date, oi.prod_id, o.quantity, oi.item_price <span class="keyword">FROM</span> customers <span class="keyword">AS</span> c, orders <span class="keyword">AS</span> o, orderitems <span class="keyword">AS</span> oi <span class="keyword">WHERE</span> c.cust_id = o.cust_id <span class="keyword">AND</span> oi.order_num = o.order_num <span class="keyword">AND</span> prod_id = <span class="string">'FB'</span>;</span><br></pre></td></tr></table></figure>
<p>外部联结：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> customers.cust_id, orders.order_num <span class="keyword">from</span> customers <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> oders <span class="keyword">on</span> customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>带聚集的联结：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customers.cust_name, customers.cust_id, <span class="keyword">COUNT</span>(orders.order_num) <span class="keyword">AS</span> num_ord <span class="keyword">FROM</span> customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.cust_id = orders.cust_id <span class="keyword">GROUP</span> <span class="keyword">BY</span> customers.cust_id;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a><strong>插入检索出的数据</strong></h2><p>INSERT SELECT 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名<span class="number">1</span>(cust_id, cust_concact, cust_email, cust_name) <span class="keyword">SELECT</span> cust_id, cust_concact, cust_email, cust_name <span class="keyword">FROM</span> 表名<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a><strong>全文本搜索</strong></h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> <span class="keyword">Match</span>(字段) Against(搜索文本);</span><br></pre></td></tr></table></figure>
<p>布尔文本搜索：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> <span class="keyword">Match</span>(字段) Against(<span class="string">'+rabbit +fat'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<p>说明：返回的行必须同时包含关键字 rabbit 和 fat。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名  <span class="keyword">WHERE</span> <span class="keyword">Match</span>(字段) Against(<span class="string">'rabbit good'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<p>说明：没有指定操作符，搜索包含rabbit或good的行（其中的一个或两个）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> <span class="keyword">Match</span>(字段) Against(<span class="string">'+fat +(&gt;rabbit)'</span> <span class="keyword">IN</span> <span class="built_in">BOOLEAN</span> <span class="keyword">MODE</span>);</span><br></pre></td></tr></table></figure>
<p>说明：文本包含fat和rabbit的行，且增加后者的优先级值。</p>
<table>
<thead>
<tr>
<th>布尔操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>包含指定值 </td>
</tr>
<tr>
<td>-</td>
<td>排除指定值 </td>
</tr>
<tr>
<td>&gt;</td>
<td>包含指定值,并且增加优先级值 </td>
</tr>
<tr>
<td>&lt;</td>
<td>包含指定值,并且减少优先级值 </td>
</tr>
</tbody>
</table>
<hr>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a><strong>存储过程</strong></h2><p>执行存储过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名(@参数<span class="number">1</span>，@参数<span class="number">2</span>，@参数<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>创建存储过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">AVG</span>(字段) <span class="keyword">AS</span> 字段 <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>删除存储过程：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> 存储过程名;</span><br></pre></td></tr></table></figure>
<p>使用参数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> ordertotal(<span class="keyword">IN</span> onumber <span class="built_in">INT</span>, <span class="keyword">OUT</span> ototal <span class="built_in">DECIMAL</span>(<span class="number">8</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">SELECT</span> <span class="keyword">SUM</span>(字段<span class="number">1</span>*字段<span class="number">2</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> order_num = onumber <span class="keyword">INTO</span> ototal;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CALL</span> ordertotal(<span class="number">20005</span>, @total);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @total;</span><br></pre></td></tr></table></figure>
<p>说明：创建存储过程PROCEDURE，传入onumber，存储变量为ototal，WHERE子句中使用onumber，将查询结果存储在ototal。</p>
<hr>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a><strong>触发器</strong></h2><p>建立触发器：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名 <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> 表名 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> <span class="string">'字符串'</span>;</span><br></pre></td></tr></table></figure>
<p>说明：FOR EACH ROW 表明代码对每个插入行执行。</p>
<p>删除触发器：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> 触发器名;</span><br></pre></td></tr></table></figure>
<p>INSERT触发器：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名 <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> 表名 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SELECT</span> NEW.字段;</span><br></pre></td></tr></table></figure>
<p>说明：每向表中插入一条数据之后，就返回最新插入数据中的字段值。</p>
<p>DELETE 触发器：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名 <span class="keyword">BEFORE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> 表名 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">BEGIN</span> </span><br><span class="line">			<span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(字段<span class="number">1</span>， 字段<span class="number">2</span>) <span class="keyword">VALUES</span> (字段值<span class="number">1</span>， 字段值<span class="number">2</span>); <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>UPDATE触发器：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名 BRFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> 表名 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">SET</span> NEW.字段 = <span class="keyword">Upper</span>(NEW.字段);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a><strong>事务处理</strong></h2><p>事务开始：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</span><br></pre></td></tr></table></figure>
<p>说明：ROLLBACK 回退START TRANSACTION 之后的所有语句。CREATE和DROP操作不能回退。</p>
<p>使用COMMIT：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>
<p>使用保留点：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> 保留点名称<span class="number">1</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> 保留点名称<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a><strong>管理用户</strong></h2><p>创建用户帐号：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'密码'</span>;</span><br></pre></td></tr></table></figure>
<p>删除用户帐号：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> 用户名;</span><br></pre></td></tr></table></figure>
<p>授予权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">TO</span> 用户名;</span><br></pre></td></tr></table></figure>
<p>说明：此GRANT 允许用户在crashcourse数据库的所有表上使用SELECT权限。</p>
<p>查看用户权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> 用户名;</span><br></pre></td></tr></table></figure>
<p>撤销用户权限：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> crashcourse.* <span class="keyword">FROM</span> 用户名;</span><br></pre></td></tr></table></figure>
<p>说明：撤销用户在crashcourse数据库所有表上的读权限。</p>
<p>更改口令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">PASSWORD</span> <span class="keyword">FOR</span> 用户 = <span class="keyword">PASSWORD</span>(<span class="string">'new password'</span>);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">dhengyi</p>
              <p class="site-description motion-element" itemprop="description">忍耐力较诸脑力，尤胜一筹。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">52</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dhengyi</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">273k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">4:08</span>
  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
