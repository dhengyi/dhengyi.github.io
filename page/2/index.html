<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="忍耐力较诸脑力，尤胜一筹。">
<meta name="keywords" content="donghengyi, Hexo, NexT">
<meta property="og:type" content="website">
<meta property="og:title" content="H.Y&#39;s BLOG">
<meta property="og:url" content="https://blog.dhengyi.name/page/2/index.html">
<meta property="og:site_name" content="H.Y&#39;s BLOG">
<meta property="og:description" content="忍耐力较诸脑力，尤胜一筹。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="H.Y&#39;s BLOG">
<meta name="twitter:description" content="忍耐力较诸脑力，尤胜一筹。">



  <link rel="alternate" href="/atom.xml" title="H.Y's BLOG" type="application/atom+xml" />




  <link rel="canonical" href="https://blog.dhengyi.name/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>H.Y's BLOG</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '[object Object]');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">H.Y's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="undefined" class="github-corner" target="_blank" title="" aria-label=""><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/04/20/Java源码-JDK-1-8-HashMap重点源码部分剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/20/Java源码-JDK-1-8-HashMap重点源码部分剖析/" itemprop="url">
                  Java源码--JDK 1.8 HashMap重点源码部分剖析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-20 21:55:40" itemprop="dateCreated datePublished" datetime="2018-04-20T21:55:40+08:00">2018-04-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java源码/" itemprop="url" rel="index"><span itemprop="name">Java源码</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">17k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">16 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：感谢 <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">美团点评技术团队</a> 的分享~~，博客部分内容摘抄自其中。侵删！</strong></p>
<p>今天我们来探究一下 HashMap 的内部实现机制。</p>
<blockquote>
<p>明确 JDK 1.8 中的 HashMap 使用数组 + 链表 + 红黑树的结构进行实现。</p>
</blockquote>
<p>HashMap 的底层思想主要是哈希表，我们来看看 Java 的设计者们是怎么使用数组 + 链表 + 红黑树设计出 HashMap 的。</p>
<hr>
<h2 id="HashMap的基本属性"><a href="#HashMap的基本属性" class="headerlink" title="HashMap的基本属性"></a><strong>HashMap的基本属性</strong></h2><p>既然是用哈希表进行实现，那么基本的数据结构就是数组了，HashMap 部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;    <span class="comment">// HashMap 底层数据结构（Node 数组）</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;             <span class="comment">// HashMap 中实际存在的键值对数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;         <span class="comment">// 记录 HashMap 内部结构发生变化的次数，用于快速失败机制</span></span><br><span class="line">    <span class="keyword">int</span> threshold;                  <span class="comment">// 所能容纳的 key-value 对极限（我将之称为“负载”）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;         <span class="comment">// 负载因子：默认 0.75</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了 table 数组之外，我将源码中的常用字段也贴了出来。对于上面的代码，我们需要注意以下几点：</p>
<blockquote>
<ol>
<li>不了解 AbstractMap&lt;K,V&gt; 抽象类、Map&lt;K,V&gt;, Cloneable, Serializable 接口的请自行百度</li>
<li>transient 关键字：阻止本字段进行序列化（具体使用请自行百度）</li>
<li>threshold = length（哈希表长度） * loadFactor</li>
<li>modCount 记录的是 HashMap 内部结构发生变化的次数，内部结构发生变化指的是结构发生变化，例如 put 新键值对，但是某个 key 对应的 value 值被覆盖不属于结构变化。</li>
</ol>
</blockquote>
<p>有了对 table 数组的认识，那么我们用一张图来描述一下 HashMap 中的哈希表结构（来自 “美团点评技术团队” 侵删）：</p>
<p><img src="HashMap-table数组.jpg" alt="此处输入图片的描述"></p>
<p>了解了 HashMap 中的成员变量，再来看一下 HashMap 中定义的常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量，必须是2的幂。  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">//最大容量（必须是 2 的幂且小于 2 的 30 次方，传入容量过大将被这个值替换）  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 装载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// JDK1.8特有  </span></span><br><span class="line"><span class="comment">// 当 hash 值相同的记录超过 TREEIFY_THRESHOLD，会动态的使用一个专门的红黑树实现来代替链表结构，使得查找时间复杂度从 O(n) 变为 O(logn)  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// JDK1.8特有  </span></span><br><span class="line"><span class="comment">// 也是阈值，同上一个相反，当桶(bucket)上的链表数小于 UNTREEIFY_THRESHOLD 时红黑树转链表  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK1.8特有  </span></span><br><span class="line"><span class="comment">// 树的最小的容量，至少是 4 x TREEIFY_THRESHOLD = 32 然后为了避免(resizing 和 treeification thresholds) 设置成64  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="HashMap中的Node元素"><a href="#HashMap中的Node元素" class="headerlink" title="HashMap中的Node元素"></a><strong>HashMap中的Node元素</strong></h2><p>现在，我们关心的是 table 数组中 Node 元素的实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类、操纵了 Map 接口中的 Entry&lt;K,V&gt; 接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// key 所产生的 hash 值 （不变）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// key （不变）</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">// value</span></span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 指向下一个 Node 节点、（链地址法解决冲突）</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这些方法都不可被重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 key 所产生的 hash 码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新值，返回旧值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个对象是否相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 是否都操作 Map.Entry 接口</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            <span class="comment">// 属于同一个类之后再对对象的属性进行比较</span></span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们需要注意：</p>
<blockquote>
<ol>
<li>Node 的实现是一个静态内部类，有关内部类与静态内部类的理解，请查看我的知乎回答：<a href="https://www.zhihu.com/question/28197253/answer/365692360" target="_blank" rel="noopener">为什么Java内部类要设计成静态和非静态两种？</a></li>
<li>hash 值与 key 的不变性：即使在 HashMap 中对 key 及 hash 做了final 关键字的约束，但是我们还是需要注意，最好使用不变对象作为 key。</li>
</ol>
</blockquote>
<p>首先我们来了解一下 final 关键字在基本类型与引用类型的使用上有什么不同？</p>
<blockquote>
<ol>
<li>当 final 修饰基本变量类型时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。</li>
<li>当 final 修饰引用类型变量时，final 只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但是这个对象(对象的非 final 成员变量的值可以改变)完全可以发生改变。</li>
</ol>
</blockquote>
<p>再来讨论，我们在使用 HashMap 时，为什么最好选用不可变对象作为 key。</p>
<p>来看一下选用可变对象作为 HashMap 的 key 有可能会造成什么影响？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;MutableKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        MutableKey key = <span class="keyword">new</span> MutableKey(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">        map.put(key, <span class="string">"Robin"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(map.get(key));</span><br><span class="line"></span><br><span class="line">        key.setI(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Robin</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>为什么最好不要使用可变对象作为 HashMap 的 key，结论：</p>
<blockquote>
<p>如果 key 对象是可变的，那么 key 的哈希值就可能改变。在 HashMap 中可变对象作为 key 会造成数据丢失。</p>
</blockquote>
<p>怎么解决？</p>
<blockquote>
<ol>
<li>在 HashMap 中，尽量使用 String、Integer 等不可变类型用作 key。</li>
<li>重写自定义类的 hashcode 方法，保证在成员变量改变的同时该对象的哈希值不变即可。（具体实现参见：<a href="http://www.cnblogs.com/0201zcr/p/4810813.html" target="_blank" rel="noopener">HashMap 的 key 可以是可变的对象吗？</a>）</li>
</ol>
</blockquote>
<hr>
<h2 id="HashMap中的put方法"><a href="#HashMap中的put方法" class="headerlink" title="HashMap中的put方法"></a><strong>HashMap中的put方法</strong></h2><h3 id="Hash值的计算"><a href="#Hash值的计算" class="headerlink" title="Hash值的计算"></a><strong>Hash值的计算</strong></h3><p>我们对 HashMap 的基本组成结构已经有了完整的认识，接下来我们分析 HashMap 中最常用的方法之一：<code>put()</code>。</p>
<p>直接上源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在分析 putVal 的源码之前，我们先来看看 <code>hash(key)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key 的 hash 值就是这样得到的，<code>key.hashCode()</code>是一个本地方法，具体实现在源码中并没有给出，但这并不是重点，我们需要注意的是在计算出 hash 值后，它又与本身的高 16 位进行了异或。（hash 值本身是 32 位）</p>
<p>为什么这样做？这样做的好处是什么呢？</p>
<blockquote>
<p>主要是从速度、功效、质量来考虑的，这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。在混合了原始 hashCode 值的高位和低位后，加大了低位的随机性，而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来，这就使得 hash 方法返回的值，具有更高的随机性，减少了冲突。</p>
</blockquote>
<p>下面举例说明，n 为 table 的长度（假设为 16）。</p>
<p><img src="HashMap-hash值的异或.jpg" alt="此处输入图片的描述"></p>
<h3 id="put方法的解析"><a href="#put方法的解析" class="headerlink" title="put方法的解析"></a><strong>put方法的解析</strong></h3><p>在分析 put 方法的源码之前，我们先来看一张有关 put 方法执行过程的图解，来自 <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">美团点评技术团队</a>，侵删~</p>
<p><img src="HashMap-put方法过程.png" alt="此处输入图片的描述"></p>
<p>根据图片我们再对 put 方法的执行流程做一个总结，方便等下阅读源码：</p>
<blockquote>
<ol>
<li>判断键值对数组 table 是否为空或为 null，否则执行 resize() 进行扩容；</li>
<li>根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i] == null，直接新建节点添加，转向 6，如果 table[i] 不为空，转向 3；</li>
<li>判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向 4，这里的相同指的是 hashCode 以及 equals；</li>
<li>判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向 5；</li>
<li>遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</li>
<li>插入成功后，判断实际存在的键值对数量 size 是否超过了负载 threshold，如果超过，进行扩容。</li>
</ol>
</blockquote>
<p>putVal 方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表为null || 哈希表的长度为 0（resize 也是一个经典的方法）</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 计算出 key 在哈希表中应该存储的位置（除留余数法，使用 &amp; 运算 比 % 运算更快）</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入的 key 在 HashMap 中已经存在（之后进行 value 的直接覆盖）</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 产生冲突，当前节点为红黑树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 普通节点，使用链地址法进行处理</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历链表（插入新节点之后，判断链表长度）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 当处理冲突的链节点数大于等于 8 的时候，转换红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 插入的 key 在 HashMap 中已经存在</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// key 已经存在，直接覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ++modCount;                 <span class="comment">// 记录 HashMap 内部结构发生变化的次数，用于快速失败机制</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();               <span class="comment">// 扩容</span></span><br><span class="line">        </span><br><span class="line">    afterNodeInsertion(evict);  <span class="comment">// 作用不明确</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put 方法分析到这里基本上就结束了，但是我们同样有两个值得思考的问题：</p>
<blockquote>
<ol>
<li>哈希表索引定位：<code>(n - 1) &amp; hash</code>；</li>
<li>扩容机制：<code>resize()</code>。</li>
</ol>
</blockquote>
<p>关于红黑树与快速失败机制，不在这篇博客中进行讲述。</p>
<h3 id="索引定位"><a href="#索引定位" class="headerlink" title="索引定位"></a><strong>索引定位</strong></h3><p>你不觉得以<code>(n - 1) &amp; hash</code>这种方式定位元素在哈希表中的位置很有趣吗？</p>
<p>本质上，它还是“除留余数法”，只不过由于位运算的缘故，会比取模运算要高效许多。</p>
<p>但是使用这种方法有一个前提，就是哈希表 table 的长度 n 必须满足 2 幂次方，因为 n-1 对应的二进制就是前面全是 0，后面全是 1，相与后，只留下 hash 的后几位，正好在长度为 n 的数组下标范围内。</p>
<p>举个例子，假设 hash 值为 3，数组长度 n 为 16，那么我们使用取模运算得到：<code>3 % 16 = 3</code>，使用 &amp; 运算：<code>0011 &amp; (16 - 1)</code> 即 <code>0011 &amp; 1111 = 0011</code> 得到的还是 3。</p>
<p>而在 HashMap 中，哈希表 table 的默认初始值也为 16（源码如下）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a><strong>扩容机制</strong></h3><p>我们不谈红黑树，但必须探究包含在 put 方法中的 resize（扩容）机制。了解过 resize 方法之后，你会感叹其设计之巧妙！</p>
<p>首先，对扩容机制做一个简单的介绍：</p>
<blockquote>
<p>扩容(resize)就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。如果 `HashMap 的实际大小 &gt; 负载，则 HashMap 中的 table 的容量扩充为当前的一倍。容量翻倍后，重新计算每个 Node 的 index，将有限的元素映射到更大的数组中，减少 hash 冲突的概率。</p>
</blockquote>
<p>我将扩容机制分为了两部分：1. 创建新的 table 数组；2. 对元素进行 rehash。</p>
<p>创建新的 table 数组，过程还是比较简单的：</p>
<blockquote>
<p>（1）原 table 数组的大小已经最大，无法扩容，则修改 threshold 的大小为 Integer.MAX_VALUE。产生的效果就是随你碰撞，不再扩容；<br>（2）原 table 数组正常扩容，更新 newCap（新数组的大小） 与 newThr（新数组的负载）；<br>（3）原 table 数组为 null || length 为 0，则扩容使用默认值；<br>（4）原 table 数组的大小在扩容后超出范围，将 threshold 的大小更改为 Integer.MAX_VALUE。</p>
</blockquote>
<p>我们先截取第一部分（创建新数组）的源码进行研究：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充，随你去碰撞（将 threshold 设置为 Integer.MAX_VALUE，则不会产生扩容）</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 扩容成功，更新 newCap 与 newThr 的大小（2 倍扩展）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ！！！对应的哪种情况？</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// oldCap == 0 || oldTab == null</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩容失败（扩容后 newCap &gt;= MAXIMUM_CAPACITY）</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新负载的值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 的过程</span></span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JDK-1-7中的rehash"><a href="#JDK-1-7中的rehash" class="headerlink" title="JDK 1.7中的rehash"></a><strong>JDK 1.7中的rehash</strong></h3><p>直接阅读 JDK 1.8 中的 rehash 过程让人有点头大，为了便于理解，我们先来看看 JDK 1.7 中的 rehash ，总体来说，两个版本差别不大：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;                   <span class="comment">// src 引用了旧的 Entry 数组</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">// 遍历旧的 Entry 数组</span></span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];             <span class="comment">// 取得旧 Entry 数组的每个元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;                 <span class="comment">// 释放旧 Entry 数组的对象引用（for 循环后，旧的 Entry 数组不再引用任何对象）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);  <span class="comment">// 重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i];                   <span class="comment">// 头插法</span></span><br><span class="line">                newTable[i] = e;                        <span class="comment">// 将元素放在数组上</span></span><br><span class="line">                e = next;                               <span class="comment">// 访问下一个 Entry 链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便大家的理解，下面举个例子说明下扩容过程：</p>
<p><strong>注：JDK 1.7 中的 put 方法使用的是头插法进行新节点的插入，在 JDK 1.8 中，则使用的是尾插法（见上述源码）。对 JDK 1.7 put 方法感兴趣的同学可自行查阅有关资料。</strong></p>
<blockquote>
<p>假设我们的 hash 算法就是简单的用 key mod 一下表的大小。其中的哈希桶数组 table 的 size = 2，key = 3、7、5，put 顺序依次为 5、7、3（JDK 1.7 头插法）。在 mod 2 以后都冲突在 <code>table[1]</code> 这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小 size 大于 table 的负载（threshold）时进行扩容。接下来的步骤是哈希桶数组 resize 成 4，然后所有的 Node 重新 rehash 的过程。</p>
</blockquote>
<p><img src="HashMap-JDK1.7-rehash.png" alt="此处输入图片的描述"></p>
<h3 id="JDK-1-8中的rehash"><a href="#JDK-1-8中的rehash" class="headerlink" title="JDK 1.8中的rehash"></a><strong>JDK 1.8中的rehash</strong></h3><p>JDK 1.8 中的 rehash 过程与 JDK 1.7 大同小异，相比 JDK 1.7， 它主要对重新定位元素在哈希表中的位置做了优化：</p>
<blockquote>
<p>经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
</blockquote>
<p><img src="HashMap-扩容对索引位置的影响.png" alt="此处输入图片的描述"></p>
<p>table 在扩容之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因此新的 index 就会发生这样的变化：</p>
<p><img src="HashMap-扩容后确定index的值.png" alt="此处输入图片的描述"></p>
<p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原索引 + oldCap”。</p>
<p>了解了 JDK 1.8 相比 JDK 1.7 所做的优化之后，我们再看一下 JDK 1.8 中的 rehash 过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 的过程</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放旧 Node 数组的对象引用（for循环后，旧的 Node 数组不再引用任何对象）</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// oldTab[j] 只有一个元素，直接进行 rehash</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 原索引（头指针与尾指针）</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 原索引 + oldCap（头指针与尾指针）</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 对元素进行 rehash 的过程</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 原索引（尾插法）</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 原索引 + oldCap（尾插法）</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将建立的链表放到新 table 数组合适的位置上</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="HashMap的线程安全性"><a href="#HashMap的线程安全性" class="headerlink" title="HashMap的线程安全性"></a><strong>HashMap的线程安全性</strong></h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。那么为什么说 HashMap 是线程不安全的，下面举例子说明在并发的多线程使用场景中使用 HashMap 可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中，map 初始化为一个长度为 2 的数组，loadFactor = 0.75，threshold = 2 * 0.75 = 1，也就是说当 put 第二个 key 的时候，map 就需要进行 resize。</p>
<p>通过设置断点让线程1和线程2同时 debug 到 transfer 方法的首行。注意此时两个线程已经成功添加数据。放开 thread1 的断点至 transfer 方法的<code>Entry next = e.next</code> 这一行；然后放开线程2的的断点，让线程2进行 resize。结果如下图。</p>
<p><img src="HashMap-线程安全1.png" alt="此处输入图片的描述"></p>
<p>newTable 是局部变量，所以两个线程都有自己扩容后开辟的新的 table 数组。（对应图中橙色与紫色方块）</p>
<p>注意，由于 Thread1 执行到了<code>Entry next = e.next</code>这一行，因此 e 指向了 key(3)，而 next 指向了 key(7)，其在线程二 rehash 后，指向了线程二重组后的链表（rehash 之后，会将 newtable 赋值给 HashMap 的成员变量 table）。</p>
<p>接着下一部分：</p>
<p>线程一被调度回来执行，先是执行 newTalbe[i] = e（对应图中 thread1 的索引 3 处指向了 thread2 中 索引 3 处的 key = 3 的节点（thread2 中的 table 此时已经是成员变量了，因此共享））， 然后是 e = next，导致了 e 指向了 key(7)，而下一次循环的 next = e.next 导致了 next 指向了 key(3)。</p>
<p><img src="HashMap-线程安全2.png" alt="此处输入图片的描述"></p>
<p>当 next 指向 key(3) 的时候，e 为 key(7)，又经过一次循环后，结果如下图：</p>
<p><img src="HashMap-线程安全3.png" alt="此处输入图片的描述"></p>
<p>虚线也表示有引用指向 key(7)，只不过是想将 thread1 所拥有的 table 与 成员变量 table 区分开。</p>
<p>此时再更新 e 与 next 的值，e 为 key(3)，next 为 null，因此下一次循环就是最后一次循环。经过下一次循环之后，由于 e.next = newTable[i] 导致 key(3).next 指向了 key(7)，而此时的 key(7).next 已经指向了 key(3)，环形链表就此形成。结果如下图：</p>
<p><img src="HashMap-线程安全4.png" alt="此处输入图片的描述"></p>
<p>于是，当我们用线程一调用 map.get(11) 时，悲剧就出现了——无限循环。</p>
<p>博主将这块内容看了好几遍，确实不好理解，如果大家对这部分内容还有任何疑惑的话，欢迎在评论区进行提问~~</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>明白静态内部类 Node 的相关实现，清楚 HashMap 的底层实现是有关 Node 的 table 数组（哈希表）。</li>
<li>注意使用 HashMap 时最好使用不变的对象作为 key。</li>
<li>注意 HashMap 计算 key 的 hash 值时，使用了低位与高位异或的方式，返回最终的 hashcode。</li>
<li>了解 HashMap 中的定位方式：<code>(n - 1) &amp; hash</code>。</li>
<li>在 HashMap 中使用链地址法解决冲突，并且当链表的节点个数大于 8 的时候，会转换为红黑树。（JDK 1.8 新特性）</li>
<li>JDK 1.8 中使用尾插法进行 put 与 resize，JDK 1.7 中使用头插法进行 put 与 resize。</li>
<li>JDK 1.8 中的 rehash 过程不用重新计算元素的哈希值，因为元素的位置只有两种情况：原位置 与 原位置 + 原本哈希表的长度。</li>
<li>清楚多线程环境下使用 HashMap 可能会造成的一种错误—<strong>形成环形链表</strong>。</li>
</ol>
<p>在 <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a> 这篇文章中，美团点评技术团队还对 JDK 1.8 与 JDK 1.7 做了性能上的比较，有兴趣的同学可以自行查阅！</p>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap—美团点评技术团队</a></p>
<p><a href="https://blog.csdn.net/pfnie/article/details/51362287" target="_blank" rel="noopener">Java HashMap工作原理及实现(二)</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/03/13/Java-Web-XiyouLinux-Group图书借阅平台的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/Java-Web-XiyouLinux-Group图书借阅平台的实现/" itemprop="url">
                  Java Web--XiyouLinux Group图书借阅平台的实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-13 00:22:30" itemprop="dateCreated datePublished" datetime="2018-03-13T00:22:30+08:00">2018-03-13</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后端开发/" itemprop="url" rel="index"><span itemprop="name">后端开发</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">31k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">28 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>源码地址：<a href="https://github.com/championheng/book-manager" target="_blank" rel="noopener">XiyouLinux Group 图书借阅平台</a></strong></p>
<p>项目地址中包含了一份README，因此对于项目的介绍省去部分内容。这篇博客，主要讲述项目中各个模块的实现细节。</p>
<hr>
<h2 id="项目概述及成果"><a href="#项目概述及成果" class="headerlink" title="项目概述及成果"></a><strong>项目概述及成果</strong></h2><p>首先将本项目使用到技术罗列出来：</p>
<blockquote>
<ol>
<li>使用Spring + Spring MVC进行后台开发</li>
<li>使用Bootstrap和jQuery框架进行前端开发</li>
<li>使用自定义注解与自定义的JdbcRowMapper简化JdbcTemplate对数据库的操作</li>
<li>使用腾讯云的对象存储服务进行图书照片的远程存储</li>
<li>使用MD5加密算法对用户密码在后台进行加密存储</li>
<li>使用过滤器进行一个会话中的身份校验</li>
<li>手动从Spring容器中获取bean</li>
<li>数据库设计中的诸多细节… …</li>
</ol>
</blockquote>
<p>由于前端开发是由团队中的其他人在负责，在加上博主对前端这块并不了解，因此本篇博客并不讨论有关第二点技术实现上的细节。</p>
<p>本项目如README中所述，在后期还有许多需要进行优化的地方。如果你对本项目感兴趣，不妨在GitHub中将其Star，以获得对本项目的持续关注～</p>
<p>至于项目成果大家可以阅读README，我在其中有贴上程序运行后的部分截图。或直接在本地搭建环境，运行此项目。过程中如有任何疑问，你也可以联系我：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spider_hgyi@outlook.com</span><br></pre></td></tr></table></figure>
<p>关于项目的整体架构我也不再描述，README中对其进行了补充。</p>
<hr>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a><strong>项目背景</strong></h2><p>这个项目的产生是有需求背景的。我们旨在为XiyouLinux Group开发一个管理图书借阅与归还的平台，从而能对小组中存在的大量书籍进行有效的管理。</p>
<p>我们的“老一届boss”刚开始给我们提出了第一版的需求，在此需求上，我们最初使用Servlet + JSP的方式进行后台开发。当然第一版由于太low我们对其进行了阉割。在我们学习了Spring与Spring MVC之后，就开始打算对其进行<strong>version 2.0</strong>的开发，并找来了一个专门学习前端的小可爱，才有了当前的图书借阅平台。</p>
<p>此图书借阅平台实现的功能模块请大家移步至<strong><a href="https://github.com/championheng/book-manager" target="_blank" rel="noopener">README</a></strong>进行查看。</p>
<p>接下来，我就按照每个模块的顺序，给大家讲一下本项目中用到的重点技术及其实现细节。</p>
<hr>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a><strong>实现细节</strong></h2><p><strong>注：博主只会挑几个重点模块去进行讲述，因此有些模块将不会涉及到。</strong></p>
<h3 id="模块一：登录模块"><a href="#模块一：登录模块" class="headerlink" title="模块一：登录模块"></a><strong>模块一：登录模块</strong></h3><p>登录模块分为三个部分，登录前主页面、登录后主页面以及登录框。</p>
<p>在这里我给大家截一张图看一下登录前后主页面的功能差距：    </p>
<p>登录前：<br><img src="图书借阅系统未登录主页.png" alt="这里写图片描述"></p>
<p>登录后：<br><img src="图书借阅系统登录后主页.png" alt="这里写图片描述"></p>
<p>我对登录后的页面只截取了和登录前有不同功能的区域。效果展示完毕，那么接下来就谈一谈这个模块中使用到的技术及其实现细节（只需考虑登录后页面实现的功能即可）。</p>
<h4 id="分页功能的实现"><a href="#分页功能的实现" class="headerlink" title="分页功能的实现"></a><strong>分页功能的实现</strong></h4><p>作为一个展示信息的Web页面，怎么可能没有分页功能呢，只不过是由于上图中的测试数据太少，没有给大家展现出来罢了。我们使用的是传统分页功能，而传统分页中又分为“真分页”与“假分页”：</p>
<blockquote>
<ul>
<li>真分页：每次从数据库中只返回当前页的数据，然后将数据交由视图进行渲染</li>
<li>假分页：从数据库中拿取所有需要或将要展示的数据，将数据交由视图，由视图实现数据的分页功能（JS实现或JSTL实现）</li>
</ul>
</blockquote>
<p>我们也很容易判断出哪种情况下何种方法最优：</p>
<blockquote>
<p>如果数据量较小，使用假分页的效果会更优；如果数据量庞大，使用真分页的效果更优。</p>
</blockquote>
<p>本项目使用的是“真分页”，我们接下来看一下实现思路与实现代码：</p>
<p>实现思路：</p>
<blockquote>
<ol>
<li>首先我们需要一个存储页面信息的Java Bean，也就是传统的Java对象</li>
<li>使用GET方法进行页面跳转请求，也就是说，我们可以从URL中得到当前页面是第几页</li>
<li>在后台中进行逻辑构造，将Java Bean中的实例字段进行部分（完全）填充</li>
<li>使用Java Bean所提供的页面信息，构造相应的SQL语句，拿到当前页数据</li>
<li>使用TreeMap对数据进行时间维度上的排序，最终返回给视图进行渲染</li>
</ol>
</blockquote>
<p>实现代码：</p>
<ul>
<li><strong>存储页面信息的Java Bean：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 12/27/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PagePO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> everyPage;      <span class="comment">// 每页显示记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalCount;     <span class="comment">// 总记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalPage;      <span class="comment">// 总页数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentPage;    <span class="comment">// 当前页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> beginIndex;     <span class="comment">// 查询起始点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasPrePage; <span class="comment">// 是否有上一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasNexPage; <span class="comment">// 是否有下一页</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PagePO</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PagePO</span><span class="params">(<span class="keyword">int</span> currentPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentPage = currentPage;</span><br><span class="line">        <span class="keyword">this</span>.everyPage = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">this</span>.beginIndex = (currentPage - <span class="number">1</span>) * everyPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PagePO</span><span class="params">(<span class="keyword">int</span> currentPage, <span class="keyword">int</span> everyPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentPage = currentPage;</span><br><span class="line">        <span class="keyword">this</span>.everyPage = everyPage;</span><br><span class="line">        <span class="keyword">this</span>.beginIndex = (currentPage - <span class="number">1</span>) * everyPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEveryPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> everyPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEveryPage</span><span class="params">(<span class="keyword">int</span> everyPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.everyPage = everyPage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHasPrePage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasPrePage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasPrePage</span><span class="params">(<span class="keyword">boolean</span> hasPrePage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hasPrePage = hasPrePage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"PagePO&#123;"</span> +</span><br><span class="line">                <span class="string">"everyPage="</span> + everyPage +</span><br><span class="line">                <span class="string">", totalCount="</span> + totalCount +</span><br><span class="line">                <span class="string">", totalPage="</span> + totalPage +</span><br><span class="line">                <span class="string">", currentPage="</span> + currentPage +</span><br><span class="line">                <span class="string">", beginIndex="</span> + beginIndex +</span><br><span class="line">                <span class="string">", hasPrePage="</span> + hasPrePage +</span><br><span class="line">                <span class="string">", hasNexPage="</span> + hasNexPage +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>从URL中得到当前页面是第几页，进行逻辑处理，填充上面Java Bean中的部分实例字段：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 1/21/18.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 登录后主页面对应的控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/auth"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = &#123;<span class="string">""</span>, <span class="string">"/"</span>, <span class="string">"/page/&#123;currentPagePre&#125;"</span>&#125;, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMainPage</span><span class="params">(Model model, @PathVariable(value = <span class="string">"currentPagePre"</span>, required = <span class="keyword">false</span>)</span> String currentPagePre,</span></span><br><span class="line"><span class="function">                              @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"tag"</span>, required = <span class="keyword">false</span>)</span> String labelIdPre) </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 得到当前页面的页码</span></span><br><span class="line">        <span class="keyword">int</span> currentPage = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentPagePre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentPage = Integer.parseInt(currentPagePre);</span><br><span class="line">        &#125;</span><br><span class="line">        PagePO pagePO = <span class="keyword">new</span> PagePO(currentPage);</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 得到当前分类下的数据总数（默认无分类）</span></span><br><span class="line">        <span class="keyword">if</span> (labelId == -<span class="number">1</span>) &#123;</span><br><span class="line">            bookCount = bookInfoService.getBookCount();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bookCount = bookInfoService.getBookCountByLabelId(labelId);</span><br><span class="line">        &#125;</span><br><span class="line">        pagePO.setTotalCount(bookCount);</span><br><span class="line">        pagePO.setTotalPage((bookCount % <span class="number">5</span> == <span class="number">0</span>) ? bookCount / <span class="number">5</span> : bookCount / <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据页面信息构造SQL语句，拿取当前页的数据</span></span><br><span class="line">		... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对获取到的信息进行排序（按时间维度）</span></span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">		... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分页在后台中的逻辑处理主要是以下部分：</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 在这里添加分页的逻辑是因为JSP页面中EL表达式对算数运算的支持不太良好</span></span><br><span class="line">        model.addAttribute(<span class="string">"ELPageValue"</span>, (currentPage - <span class="number">1</span>) / <span class="number">5</span> * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当总页数大于5时，需要如下属性</span></span><br><span class="line">        <span class="keyword">if</span> (pagePO.getTotalPage() &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">            model.addAttribute(<span class="string">"isOneOfNextFivePage"</span>, (pagePO.getTotalPage() - <span class="number">1</span>) / <span class="number">5</span> * <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">            model.addAttribute(<span class="string">"reachNextFivePage"</span>, (currentPage + <span class="number">4</span>) / <span class="number">5</span> * <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前页面大于等于6页的时候, 需要显示"[...]"按钮--返回到前一个5页</span></span><br><span class="line">        <span class="keyword">if</span> (currentPage &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">            model.addAttribute(<span class="string">"returnPreFivePage"</span>, (currentPage - <span class="number">1</span>) / <span class="number">5</span> * <span class="number">5</span> - <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>根据页面信息构造SQL语句，拿取当前页的数据：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 11/23/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookInfoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcOperations jdbcOperations;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String GET_ONE_PAGE_BOOKINFO = <span class="string">"SELECT * FROM book_info WHERE amount &gt; 0 ORDER BY pk_id DESC LIMIT ?, ?"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BookInfoPO&gt; <span class="title">getBookByPage</span><span class="params">(PagePO page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcOperations.query(GET_ONE_PAGE_BOOKINFO,</span><br><span class="line">                JdbcRowMapper.newInstance(BookInfoPO.class), page.getBeginIndex(), page.getEveryPage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>对获取到的信息进行排序：（按时间维度）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookUserMapUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;BookInfoPO, String&gt; <span class="title">getBookInfo</span><span class="params">(List&lt;BookInfoPO&gt; bookInfoPOS, UserService userService)</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="comment">// TreeMap可对数据进行排序，当然BookInfoPO要实现Comparable接口，并重写compareTo方法</span></span><br><span class="line">        Map&lt;BookInfoPO, String&gt; bookMap = <span class="keyword">new</span> TreeMap&lt;BookInfoPO, String&gt;();</span><br><span class="line"></span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bookMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>JSP页面中对应的分页实现（JSTL与EL）：</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页的实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"index_pingination"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--当当前页面不是第一页的时候, 要显示 "首页"和 "&lt;&lt;"按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;pageInfo.currentPage != 1 &amp;&amp; pageInfo.totalPage != 0&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/1"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.currentPage-1&#125;"</span>&gt;</span>&amp;laquo;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/1?tag=$&#123;labelId&#125;"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.currentPage-1&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>&amp;laquo;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--当当前页面大于等于6页的时候, 要显示 "[...]"按钮--返回到前一个5页--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;pageInfo.currentPage &gt;= 6&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;returnPreFivePage&#125;"</span>&gt;</span>[...]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;returnPreFivePage&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>[...]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--显示当前页面所有应显示的页码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">varStatus</span>=<span class="string">"i"</span> <span class="attr">begin</span>=<span class="string">"$&#123;ELPageValue+1&#125;"</span> <span class="attr">end</span>=<span class="string">"$&#123;ELPageValue+5&#125;"</span> <span class="attr">step</span>=<span class="string">"$&#123;1&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;i.current &lt;= pageInfo.totalPage&#125;"</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">&lt;!--当前页的超链接处理为不可点击--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;i.current == pageInfo.currentPage&#125;"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"pa_in"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">disabled</span>=<span class="string">"true"</span>&gt;</span>$&#123;pageInfo.currentPage&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;i.current != pageInfo.currentPage&#125;"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;i.current&#125;"</span>&gt;</span>$&#123;i.current&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;i.current&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>$&#123;i.current&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--如果不是最后一个五页中的页码, 要在后面显示[...]按钮--跳到下一个5页--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;pageInfo.currentPage &lt; isOneOfNextFivePage &amp;&amp; pageInfo.totalPage &gt;= 6&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;reachNextFivePage&#125;"</span>&gt;</span>[...]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;reachNextFivePage&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>[...]<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--如果不是尾页, 要显示 "&gt;&gt;"和 "尾页"按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;pageInfo.currentPage != pageInfo.totalPage &amp;&amp; pageInfo.totalPage != 1 &amp;&amp; pageInfo.totalPage != 0&#125;"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId == -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.currentPage+1&#125;"</span>&gt;</span>&amp;raquo;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.totalPage&#125;"</span>&gt;</span>尾页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;labelId != -1&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.currentPage+1&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>&amp;raquo;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/page/$&#123;pageInfo.totalPage&#125;?tag=$&#123;labelId&#125;"</span>&gt;</span>尾页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="登录校验之过滤器实现"><a href="#登录校验之过滤器实现" class="headerlink" title="登录校验之过滤器实现"></a><strong>登录校验之过滤器实现</strong></h4><p>既然系统具有登录功能，那么我们就需要注意一些事情：</p>
<blockquote>
<ul>
<li>怎么防止未登录的用户访问登录后的页面</li>
<li>用户的cookie失效之后，我们需要引导用户进行重新登录</li>
</ul>
</blockquote>
<p>为了解决这两个问题，就需要引入过滤器。关于过滤器的功能与在Serlvet中的使用请移步至这一篇博客：<strong><a href="http://blog.csdn.net/championhengyi/article/details/72860657" target="_blank" rel="noopener">Servlet–Servlet进阶API、过滤器、监听器</a></strong></p>
<p>我现在要说的是过滤器在Spring框架中的使用，先看实现代码，并不难理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by dela on 1/18/18.</span><br><span class="line"> *</span><br><span class="line"> * @Description: 对于想要在Spring中使用过滤器, 就要继承OncePerRequestFilter</span><br><span class="line"> * OncePerRequestFilter, 顾名思义, 就是每个请求只通过一次这个过滤器</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class LoginFilter extends OncePerRequestFilter &#123;</span><br><span class="line">    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,</span><br><span class="line">                                    FilterChain filterChain) throws ServletException, IOException &#123;</span><br><span class="line">        final String INDEX_PAGE = &quot;/&quot;;    // 未登录的URL</span><br><span class="line">        Object sessionId = null;</span><br><span class="line"></span><br><span class="line">        HttpSession session = httpServletRequest.getSession(false);</span><br><span class="line"></span><br><span class="line">		// 未登录和Cookie失效的处理机制</span><br><span class="line">        if (session != null) &#123;</span><br><span class="line">            sessionId = session.getAttribute(&quot;uid&quot;);</span><br><span class="line">            if (sessionId != null) &#123;</span><br><span class="line">                filterChain.doFilter(httpServletRequest, httpServletResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果当前操作的用户没有登录令牌, 那就弹出弹框提示重新登录, 并跳转到未登录页面</span><br><span class="line">        if (session == null || sessionId == null) &#123;</span><br><span class="line">            // 设置response的字符集, 防止乱码</span><br><span class="line">            httpServletResponse.setCharacterEncoding(&quot;GBK&quot;);</span><br><span class="line"></span><br><span class="line">            PrintWriter out = httpServletResponse.getWriter();</span><br><span class="line">            String builder = &quot;&lt;script language=\&quot;javascript\&quot;&gt;&quot; +</span><br><span class="line">                    &quot;alert(\&quot;网页过期，请重新登录！\&quot;);&quot; +</span><br><span class="line">                    &quot;top.location=&apos;&quot; +</span><br><span class="line">                    INDEX_PAGE +</span><br><span class="line">                    &quot;&apos;;&quot; +</span><br><span class="line">                    &quot;&lt;/script&gt;&quot;;</span><br><span class="line"></span><br><span class="line">            out.print(builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个问题需要解决～</p>
<p><strong>1.什么叫做每个请求只通过一次这个过滤器。Filter不都是仅仅经过一次的吗？</strong> </p>
<p>不是的！不然就不会有这个类了。</p>
<p>此方式是为了兼容不同的Web容器，特意而为之，也就是说并不是所有的Web容器都像我们期望的只过滤一次，Servlet版本不同，表现也不同。 </p>
<p>如，Servlet2.3与Servlet2.4也有一定差异 ：</p>
<p>在Servlet-2.3中，Filter会过滤一切请求，包括服务器内部使用forward转发请求和<code>&lt;%@ include file=“/index.jsp”%&gt;</code>的情况。</p>
<p>到了Servlet-2.4中Filter默认下只拦截外部提交的请求，forward和include这些内部转发都不会被过滤，但是有时候我们需要forward的时候也要用到Filter。</p>
<p>因此，为了兼容各种不同的运行环境和版本，默认Filter继承OncePerRequestFilter是一个比较稳妥的选择。</p>
<p><strong>2.有关<code>HttpSession session = httpServletRequest.getSession(false)</code>的一点小知识。</strong></p>
<p>现实中我们经常会遇到以下3中用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">true</span>);</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>他们之间的区别是什么？</p>
<p>getSession(boolean create)意思是返回当前reqeust中的HttpSession，如果当前request中的HttpSession为null且create为true，就创建一个新的HttpSession，否则就直接返回null。</p>
<p><strong>简而言之：</strong> </p>
<blockquote>
<ul>
<li><code>request.getSession(true)</code>等同于如果当前没有HttpSession还要新创建一个HttpSession</li>
<li><code>request.getSession(false)</code>则等同于如果当前没有HttpSession就直接返回null</li>
</ul>
</blockquote>
<p>那么我们在使用的时候：</p>
<blockquote>
<ul>
<li>当向HttpSession中存储登录信息时，一般建议：<code>HttpSession session = request.getSession(true)</code></li>
<li>当从HttpSession中获取登录信息时，一般建议：<code>HttpSession session = request.getSession(false)</code></li>
</ul>
</blockquote>
<p><strong>还有一种更简洁的方式：</strong></p>
<blockquote>
<p>如果你的项目中使用到了Spring，对Session的操作就方便多了。如果需要在Session中取值，可以用WebUtils工具的getSessionAttribute(HttpServletRequestrequest, String name)方法，看看源码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSessionAttribute</span><span class="params">(HttpServletRequest request, String name)</span> </span>&#123;  </span><br><span class="line">	Assert.notNull(request, <span class="string">"Request must not be null"</span>);  </span><br><span class="line">	HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (session != <span class="keyword">null</span> ? session.getAttribute(name) : <span class="keyword">null</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebUtils.setSessionAttribute(request, “user”, User)；</span><br><span class="line">User user = (User) WebUtils.getSessionAttribute(request, “user”);</span><br></pre></td></tr></table></figure>
<h4 id="密码加密之MD5算法"><a href="#密码加密之MD5算法" class="headerlink" title="密码加密之MD5算法"></a><strong>密码加密之MD5算法</strong></h4><p>也许你没有听过MD5加密算法，但是有些人看到这个标题首先会产生一个疑问：<strong>对密码为什么还要加密？</strong></p>
<blockquote>
<p>主要是从安全性的角度上考虑，我们知道如果不对密码进行加密，那么密码将会在后台以明文的形式存储到数据库中。如果你的数据库足够安全，保证不会被别人所侵略，这当然没有什么问题。但事实是，我们不得不小心SQL注入等一系列数据库安全性问题，这时候，在数据库中所存储的有关个人隐私的信息，就显得十分重要了。因此将密码在后台进行加密，对于真正的企业级开发来说，是一件不可或缺的事情。</p>
</blockquote>
<p>解决掉这个疑惑之后，让我们一起来看看MD5加密算法的核心思想及代码实现。</p>
<p>好吧，博主看了一些关于MD5的核心思想，并没有看懂，先在这里给大家放一篇讲述MD5加密算法实现原理的博客链接：<strong><a href="http://blog.csdn.net/forgotaboutgirl/article/details/7258109" target="_blank" rel="noopener">MD5算法原理</a></strong> — 博客中有少量错误，大家理性阅读。</p>
<p>关于MD5在Java中的使用，则要简单许多：</p>
<blockquote>
<ol>
<li>通过MessageDigest.getInstance()确定加密算法，MessageDigest不止提供MD5</li>
<li>调用<code>update(byte[] input)</code>对指定的byte数组更新摘要</li>
<li>执行<code>digest()</code>方法进行哈希计算。在调用此方法之后，摘要被重置</li>
<li>对第三步返回的结果进行处理：128位级联值（16组有符号字节值）—&gt;将每组10进制数字转换为16进制，并生成相应字符串</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 上午11:53 18-3-11.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: MD5加密算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">codeByMD5</span><span class="params">(String inStr)</span> </span>&#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 得到MD5加密算法实例</span></span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用指定的byte数组更新摘要</span></span><br><span class="line">        <span class="keyword">assert</span> md5 != <span class="keyword">null</span>;</span><br><span class="line">        md5.update(inStr.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过执行诸如填充之类的最终操作完成哈希计算。返回值是16个有符号字节数，共128位</span></span><br><span class="line">        <span class="keyword">byte</span>[] md5Bytes = md5.digest();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 用于存储最终得到的32位小写16进制字符串</span></span><br><span class="line">        StringBuilder hexValue = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将其中的字节转换为16进制字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> md5Byte : md5Bytes) &#123;</span><br><span class="line">	        <span class="comment">// 将得到的有符号字节转换为无符号字节</span></span><br><span class="line">            <span class="keyword">int</span> val = ((<span class="keyword">int</span>) md5Byte) &amp; <span class="number">0xff</span>;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">16</span>) &#123;</span><br><span class="line">                hexValue.append(<span class="string">"0"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            hexValue.append(Integer.toHexString(val));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hexValue.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码生成小写16进制字符串，代码运行结果经过本人与在线MD5加密网站生成的结果进行了对比，测试无误，可放心使用。</p>
<h3 id="模块二：标签页模块"><a href="#模块二：标签页模块" class="headerlink" title="模块二：标签页模块"></a><strong>模块二：标签页模块</strong></h3><p>效果展示：<br><img src="图书借阅系统标签显示页面.png" alt="这里写图片描述"></p>
<h4 id="目录树结构的数据库设计"><a href="#目录树结构的数据库设计" class="headerlink" title="目录树结构的数据库设计"></a><strong>目录树结构的数据库设计</strong></h4><p>在标签页这一模块中，我们主要对在MySQL数据库中如何存储一个树状结构而进行一个简单的介绍。</p>
<p>我在项目中设计的存储结构并不高效，是一种最简单且基本的实现。在网上有很多结构良好且性能高效的树形结构的数据库表设计，大家可以查阅一些相关资料。</p>
<p>对比上面的效果展示图，我的标签分类其实就是三层树深度：</p>
<blockquote>
<ol>
<li>根节点（唯一）</li>
<li>一级标签（大数据与云计算… …）（多节点）</li>
<li>二级标签（Hadoop、Spark等等）（多节点）</li>
</ol>
</blockquote>
<p>可以看到，虽然树的深度只有3，但其每个父节点都拥有多个子节点。</p>
<p>既然已经将标签信息组织成多路树结构，那么数据库结构设计如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pk_id              name              parent_id</span><br></pre></td></tr></table></figure>
<p>pk_id用来标识此标签名的唯一索引，name就是标签名，parent_id则是此标签其父节点对应的pk_id。</p>
<p>我将一级标签的parent_id都设置为0，表明一级标签的父节点提供空数据，标签页只需要一级标签及二级标签的信息。</p>
<p>如此，我们便可查找任一一级标签信息及其所拥有的二级标签信息。</p>
<p>至于标签页面中的显示形式，我们在后台只要将每个一级标签作为Map数据结构中的键，当前一级标签所拥有的二级标签作为对应的值，然后将Map作为model返回给视图进行解析渲染即可。</p>
<p>代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: spider_hgyi</span><br><span class="line"> * @Date: Created in 下午1:36 17-11-20.</span><br><span class="line"> * @Modified By:</span><br><span class="line"> * @Description:</span><br><span class="line"> */</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/auth&quot;)</span><br><span class="line">public class TagsController &#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value = &quot;/tags&quot;, method = RequestMethod.GET)</span><br><span class="line">    public String showLabel(Model model) &#123;</span><br><span class="line">	    // 得到所有的一级标签（parent_id == 0）</span><br><span class="line">        List&lt;BookLabelPO&gt; parentLabels = bookLabelRepository.getBookLabelByParentId(0);</span><br><span class="line">        // 得到所有的二级标签（parent_id != 0）</span><br><span class="line">        List&lt;BookLabelPO&gt; childrenLabels = bookLabelRepository.getChildrenLabelsByParentId(0);</span><br><span class="line">        // 返回给视图的model</span><br><span class="line">        Map&lt;String, Map&lt;Integer, String&gt;&gt; labelsName = new HashMap&lt;String, Map&lt;Integer, String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        // 找到每个一级标签所拥有的二级标签</span><br><span class="line">        for (BookLabelPO parentLabel : parentLabels) &#123;</span><br><span class="line">            Map&lt;Integer, String&gt; childLabelsName = new HashMap&lt;Integer, String&gt;();</span><br><span class="line">            for (BookLabelPO childrenLabel : childrenLabels) &#123;</span><br><span class="line">                if (parentLabel.getPkId() == childrenLabel.getParentId()) &#123;</span><br><span class="line">                    childLabelsName.put(childrenLabel.getPkId(), childrenLabel.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            labelsName.put(parentLabel.getName(), childLabelsName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将存储标签信息的Map对象添加进model对象</span><br><span class="line">        model.addAttribute(&quot;labelsName&quot;, labelsName);</span><br><span class="line"></span><br><span class="line">        return &quot;alltags&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块三：上传书籍模块"><a href="#模块三：上传书籍模块" class="headerlink" title="模块三：上传书籍模块"></a><strong>模块三：上传书籍模块</strong></h3><h4 id="腾讯云存储服务—图片存储"><a href="#腾讯云存储服务—图片存储" class="headerlink" title="腾讯云存储服务—图片存储"></a><strong>腾讯云存储服务—图片存储</strong></h4><p>由于有些书籍会上传封面照片，而腾讯云又提供了对象存储服务，因此我并没有选择将图片存储至本地或云服务器上，而是使用了腾讯云所提供的云对象存储。</p>
<p>使用云对象存储，腾讯所提供的开发者文档：<strong><a href="https://cloud.tencent.com/document/product/436/10199" target="_blank" rel="noopener">对象存储 — SDK 文档</a></strong></p>
<h4 id="手动获取bean"><a href="#手动获取bean" class="headerlink" title="手动获取bean"></a><strong>手动获取bean</strong></h4><p>Spring MVC给我们提供了文件上传功能（两种使用形式）：</p>
<blockquote>
<ol>
<li>给控制器方法参数上添加@RequestPart注解，参数类型为字节数组</li>
<li>给控制器方法参数上添加@RequestPart注解，参数类型为Part</li>
</ol>
</blockquote>
<p>但是我在使用Spring MVC所提供的文件上传功能时，始终无法获取到对应的字节流对象。我查阅了大量的相关文档，并仔细的检查了所写的代码，最终也没有找到问题的根源。因此在项目中，对于书籍图片的处理，我使用了Servlet所提供的原生API：<code>request.getPart()</code>。</p>
<p>既然使用了Servlet所提供的原生API，因此图书上传模块所对应的控制器便继承于HttpServlet。在继承了HttpServlet之后，还是出现了很多问题—怎么使原生Servlet与Spring MVC的bean之间进行协作？</p>
<p>在使用了HttpServlet之后，便无法给此Servlet添加@controller注解，也就无法使用依赖注入。大概的原因是Servlet由Web容器管理，而bean由Spring容器管理。在这种情况下，我对bean进行了手动获取。</p>
<p>手动获取bean的代码我写到了Servlet的init方法中，对于此方法我不在这里进行描述。</p>
<p>博主之所以将这一技术细节提取出来，也是想给那些遇到同样问题的朋友们提供一些思路。</p>
<p>代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 下午8:14 17-12-3.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/auth/upload.do"</span>)</span><br><span class="line"><span class="meta">@MultipartConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewBookController</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NewBookController.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BookInfoService bookInfoService;</span><br><span class="line">    <span class="keyword">private</span> BookLabelService bookLabelService;</span><br><span class="line">    <span class="keyword">private</span> BookRelationLabelService bookRelationLabelService;</span><br><span class="line">    <span class="keyword">private</span> COSStorage cosStorage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动获取bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">// 得到Servlet应用上下文</span></span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">// 得到Web应用上下文</span></span><br><span class="line">        WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">        <span class="comment">// 根据beanId获取相应bean</span></span><br><span class="line">        bookInfoService = (BookInfoService) ctx.getBean(<span class="string">"bookInfoServiceImpl"</span>);</span><br><span class="line">        bookLabelService = (BookLabelService) ctx.getBean(<span class="string">"bookLabelServiceImpl"</span>);</span><br><span class="line">        bookRelationLabelService = (BookRelationLabelService) ctx.getBean(<span class="string">"bookRelationLabelServiceImpl"</span>);</span><br><span class="line">        cosStorage = (COSStorage) ctx.getBean(<span class="string">"cosStorage"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块四：对Jdbc-RowMapper的简易封装"><a href="#模块四：对Jdbc-RowMapper的简易封装" class="headerlink" title="模块四：对Jdbc RowMapper的简易封装"></a><strong>模块四：对Jdbc RowMapper的简易封装</strong></h3><p>本项目的架构采用<code>Spring + Spring MVC + JdbcTemplate</code>，其中Spring + Spring MVC对应ssm框架中的ss，我们并没有使用Mybatis框架。Spring提供了相应的JDBC框架—JdbcTemplate。</p>
<p>对于JdbcTemplate的使用如下（在使用之前需要进行相关的Spring配置）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-11-7.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcSpitterRepository</span> <span class="keyword">implements</span> <span class="title">SpitterRepository</span> </span>&#123;</span><br><span class="line">    JdbcOperations jdbcOperations;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String INSERT_SPITTER = <span class="string">"INSERT INTO spitter (username, password, "</span> +</span><br><span class="line">            <span class="string">"firstname, lastname) VALUES (?, ?, ?, ?)"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUERY_SPITTER_BY_USERNAME = <span class="string">"SELECT * FROM spitter "</span> +</span><br><span class="line">            <span class="string">"WHERE username = ?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcSpitterRepository</span><span class="params">(JdbcOperations jdbcOperations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcOperations = jdbcOperations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库插入操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spitter <span class="title">save</span><span class="params">(Spitter spitter)</span> </span>&#123;</span><br><span class="line">        jdbcOperations.update(INSERT_SPITTER, spitter.getUsername(), spitter.getPassword(),</span><br><span class="line">                spitter.getFirstName(), spitter.getLastName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> spitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库查询操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Spitter&gt; <span class="title">findByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jdbcOperations.query(QUERY_SPITTER_BY_USERNAME,</span><br><span class="line">                <span class="keyword">new</span> SpitterRowMapper(), username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SpitterRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Spitter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Spitter <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Spitter(</span><br><span class="line">                    resultSet.getInt(<span class="string">"id"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"username"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"password"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"firstname"</span>),</span><br><span class="line">                    resultSet.getString(<span class="string">"lastname"</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上述代码有几点说明：</p>
<blockquote>
<ol>
<li>JdbcOperations是一个接口，定义了JdbcTemplate所实现的操作。通过注入JdbcOperations从而使JdbcSpitterRepository与JdbcTemplate保持了松耦合</li>
<li>使用RowMapper对Spitter对象进行填充，最后得到从数据库中查询到的结果集合</li>
<li>使用JdbcTemplate极大的方便了对JDBC的操作，没有了创建JDBC连接和语句的代码，也没有了异常处理的代码，只剩下单纯的数据插入与查询代码</li>
</ol>
</blockquote>
<ul>
<li><strong>那么我们为何还要对RowMapper进行封装？</strong></li>
</ul>
<p>由上面的代码可知，每当我们从相同（不同）的数据库表中得到不同的数据时，就有可能创建不同的RowMapper。那么问题就凸显出来了，我们的系统中必定有多张数据库表，也必定要从各个表中查询不同的数据，那么就会创建大量不同的RowMapper类，这些RowMapper散落于项目中的各个角落。这样的设计，显然很失败。</p>
<ul>
<li><strong>我们自己封装的JdbcRowMapper（与Spring所提供的RowMapper所区分）有什么功能呢？</strong></li>
</ul>
<p>我们尝试对RowMapper进行封装，以提供这样的功能：对于不同的对象，RowMapper在从数据库中查询到相应的数据之后，都可对其相应的字段进行自动填充。</p>
<p><strong>我们先来看一下它的使用效果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbcOperations.query(GET_BOOK_BY_LABEL_AND_PAGE_TYPESCONTROLLER,</span><br><span class="line">                        JdbcRowMapper.newInstance(BookInfoPO.class), labelId,pagePO.getBeginIndex(), pagePO.getEveryPage());</span><br><span class="line">                        </span><br><span class="line">jdbcOperations.query(QUERY_CHILDREN_LABELS_BY_PARENT_ID, JdbcRowMapper.newInstance(BookLabelPO.class), parentId);</span><br></pre></td></tr></table></figure>
<p>可以看到，我们不必再为不同的PO对象编写不同的RowMapper。</p>
<p>现在开始分析它的具体实现：</p>
<p>根据上述代码，我们先来分析它的<code>newInstance</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">JdbcRowMapper&lt;T&gt; <span class="title">newInstance</span> <span class="params">(Class&lt;T&gt; mappedClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JdbcRowMapper&lt;T&gt;(mappedClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个泛型方法，返回值是泛型类：<code>JdbcRowMapper&lt;T&gt;</code>，方法参数是泛型Class对象。这个方法调用了JdbcRowMapper如下的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcRowMapper</span><span class="params">(Class&lt;T&gt; mappedClass)</span> </span>&#123;</span><br><span class="line">    initialize(mappedClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟踪，initialize方法：（核心方法之一）</p>
<ul>
<li><strong>initialize方法的作用：</strong></li>
</ul>
<blockquote>
<ul>
<li>在说initialize方法的作用之前，我们先要知道什么是PO。之前我所使用的Java Bean为什么都以PO为后缀？简单来说，这是Java Bean与持久化层之间的一层规约。这层规约可以简单的概述为：数据库中表字段的命名方式都以下划线分割单词，而Java Bean中则是以驼峰式命名，并且，每个PO对象基本对应一张数据库表。就拿BookInfoPO中的<code>private int pkId</code>属性来说，它对应的就是数据库表<code>book_info</code>中的<code>pk_id</code>字段。这里涉及到了数据库建表时的规范，我们之后再说。目前你就先这样记住。</li>
<li>有了这层规约，我们在封装RowMapper的时候，就可以通过一些逻辑代码，将Java Bean中的实例字段名转换为数据库表中相应的字段名，也就为我们的下一个方法：把从数据库表中读取到的数据填充到Java Bean中的相应字段做了铺垫。</li>
</ul>
</blockquote>
<ul>
<li><strong>initialize方法的实现思路：</strong></li>
</ul>
<blockquote>
<ol>
<li>通过<code>BeanUtils.getPropertyDescriptor()</code>得到当前JavaBean(mappedClass对应的PO)的PropertyDescriptor数组</li>
<li>对PropertyDescriptor数组进行遍历，拿到每一个实例变量的变量名</li>
<li>对变量名做相应转换，转为对应的数据库表字段名</li>
<li>将这些名字保存在合适的数据结构中，供接下来的mapRow方法使用（JdbcRowMapper中真正从数据库中读取所需数据的方法）</li>
</ol>
</blockquote>
<p>有了实现思路，那么接下来看代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Class&lt;T&gt; mappedClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以下三个变量都是实例变量，在这里进行初始化</span></span><br><span class="line">    <span class="keyword">this</span>.mappedClass = mappedClass;</span><br><span class="line">    <span class="keyword">this</span>.mappedFileds = <span class="keyword">new</span> HashMap&lt;String, PropertyDescriptor&gt;();</span><br><span class="line">    <span class="keyword">this</span>.mappedProperties = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 通过BeanUtils.getPropertyDescriptor()得到当前JavaBean(mappedClass对应的PO)的PropertyDescriptor数组，PropertyDescriptors类是Java内省类库的一个类。</span></span><br><span class="line"><span class="comment">     * Java JDK中提供了一套API用来访问某个对象属性的getter/setter方法，这就是内省。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取bean的所有属性（也就是实例变量）列表   </span></span><br><span class="line">    PropertyDescriptor[] propertyDescriptors = BeanUtils.getPropertyDescriptors(mappedClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历属性列表</span></span><br><span class="line">    <span class="keyword">for</span> (PropertyDescriptor propertyDescriptor : propertyDescriptors) &#123;</span><br><span class="line">        <span class="comment">// propertyDescriptor.getWriteMethod()获得用于写入属性值的方法</span></span><br><span class="line">        <span class="keyword">if</span> (propertyDescriptor.getWriteMethod() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 得到此属性名（变量名）</span></span><br><span class="line">            String name = propertyDescriptor.getName();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过反射取得Class里名为name的字段信息</span></span><br><span class="line">                Field field = mappedClass.getDeclaredField(name);</span><br><span class="line">                <span class="keyword">if</span> (field != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 得到该属性(field)上存在的注解值（下一个代码给出示例）</span></span><br><span class="line">                    Column column = field.getAnnotation(Column.class);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果取得的column值不为null, 那就给name赋值column.name</span></span><br><span class="line">                    <span class="keyword">if</span> (column != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        name = column.name();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将&lt;属性名字, 属性&gt;加入mappedFileds中</span></span><br><span class="line">            <span class="keyword">this</span>.mappedFileds.put(lowerCaseName(name), propertyDescriptor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不使用自定义注解，使用代码将所得name转换为对应数据库表字段</span></span><br><span class="line">            String underscoredName = underscoreName(name);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果两个不等，则将nderscoredName也添加进mappedFileds，相当于一种容错机制</span></span><br><span class="line">            <span class="keyword">if</span> (!lowerCaseName(name).equals(underscoredName)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mappedFileds.put(underscoredName, propertyDescriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将属性名添加至mappedProperties</span></span><br><span class="line">            <span class="keyword">this</span>.mappedProperties.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是initialize方法。接下来看一下其中所用到的自定义注解，也就是对这一行代码的解释：<code>Column column = field.getAnnotation(Column.class)</code></p>
<ul>
<li><strong>定义自定义注解：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dela</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: <span class="doctag">@Retention</span>是JDK的元注解, 当RetentionPolicy取值为RUNTIME的时候,</span></span><br><span class="line"><span class="comment"> * 意味着编译器将Annotation记录在class文件中, 当Java文件运行的时候,</span></span><br><span class="line"><span class="comment"> * JVM也可以获取Annotation的信息, 程序可以通过反射获取该Annotation的信息.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="comment">// @Target也是JDK的一个元注解, 当ElementType取不同值的时候, 意味着这个注解的作用域也不同,</span></span><br><span class="line"><span class="comment">// 比如, 当ElementType取TYPE的时候, 说明这个注解用于类/接口/枚举定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    <span class="comment">// 数据库中表的名字</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 12/20/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="comment">// 数据库中的表上的字段的名字</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>自定义注解在BookInfoPO中的应用：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by dela on 11/22/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 书籍信息表</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"book_info"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookInfoPO</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BookInfoPO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"pk_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pkId;                   <span class="comment">// 无意义主键</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"ugk_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String ugkName;             <span class="comment">// 书名(组合索引)</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"author"</span>)</span><br><span class="line">    <span class="keyword">private</span> String author;              <span class="comment">// 作者</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"ugk_uid"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ugkUid;                 <span class="comment">// 所有者(即用户表里的id)(组合索引)</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"amount"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amount;                 <span class="comment">// 数量</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"upload_date"</span>)</span><br><span class="line">    <span class="keyword">private</span> String uploadDate;          <span class="comment">// 上传时间</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"book_picture"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bookPicture;         <span class="comment">// 书籍照片</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"describ"</span>)</span><br><span class="line">    <span class="keyword">private</span> String describ;             <span class="comment">// 书籍描述</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookInfoPO</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在initialize方法中还有一个<code>underscoreName()</code>：（此方法就不打注解了）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">underscoreName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    result.append(lowerCaseName(name.substring(<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; name.length(); i++) &#123;</span><br><span class="line">        String s = name.substring(i, i + <span class="number">1</span>);</span><br><span class="line">        String slc = lowerCaseName(s);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!s.equals(slc)) &#123;</span><br><span class="line">            result.append(<span class="string">"_"</span>).append(slc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ok，接下来我们继续探究核心方法二：<code>mapRow()</code></p>
<p>刚说过initialize方法是为了使mapRow方法可以把从数据库表中读取到的结果填充到Java Bean相应的字段上而做的一个铺垫。那么mapRow必定实现了如下功能：</p>
<blockquote>
<ol>
<li>从数据库表中读取结果集</li>
<li>将结果集中的元素填充到相应的Java Bean中（别忘了initialize方法已经帮我们将Java Bean中的实例变量名转换为了数据库表中相应的字段名）</li>
</ol>
</blockquote>
<p>明白了mapRow中实现的大致功能，那么我们直接来看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> rowNumber)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// Spring的断言表达式, 传入的Java Bean的Class对象不能为空</span></span><br><span class="line">    Assert.state(<span class="keyword">this</span>.mappedClass != <span class="keyword">null</span>, <span class="string">"Mapped class was not specified"</span>);</span><br><span class="line">        <span class="comment">// 实例化一个Java Bean</span></span><br><span class="line">        T mappedObject = BeanUtils.instantiate(<span class="keyword">this</span>.mappedClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BeanWrapper可以设置及访问被包装对象的属性值</span></span><br><span class="line">        BeanWrapper beanWrapper = PropertyAccessorFactory.forBeanPropertyAccess(mappedObject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从resultSet中拿到有关此数据库表的元数据（字段名称、类型以及数目等）</span></span><br><span class="line">        ResultSetMetaData resultSetMetaData = resultSet.getMetaData();</span><br><span class="line">        <span class="comment">// 得到此数据库表的字段数目</span></span><br><span class="line">        <span class="keyword">int</span> columnCount = resultSetMetaData.getColumnCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt;= columnCount; index++) &#123;</span><br><span class="line">            <span class="comment">// 得到数据库表中当前字段名</span></span><br><span class="line">            String column = JdbcUtils.lookupColumnName(resultSetMetaData, index);</span><br><span class="line">            String field = lowerCaseName(column.replaceAll(<span class="string">" "</span>, <span class="string">""</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据数据库表中的字段名拿到Java Bean中对应实例字段属性的描述</span></span><br><span class="line">            PropertyDescriptor propertyDescriptor = <span class="keyword">this</span>.mappedFileds.get(field);</span><br><span class="line">            <span class="keyword">if</span> (propertyDescriptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 得到该field所对应的数据库表中字段所对应的值（下一个代码给出示例）</span></span><br><span class="line">                    Object value = getColumnValue(resultSet, index, propertyDescriptor);</span><br><span class="line"></span><br><span class="line">                    ... ...</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 将得到值填充到Java Bean中相应的实例变量上</span></span><br><span class="line">                        beanWrapper.setPropertyValue(propertyDescriptor.getName(), value);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">                        ... ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NotWritablePropertyException ex) &#123;</span><br><span class="line">                    ... ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有发现相应实例字段的属性描述</span></span><br><span class="line">                ... ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mappedObject;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>getColumnValue()的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到数据库表中字段(column)对应的值(value)</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getColumnValue</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> index, PropertyDescriptor propertyDescriptor)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JdbcUtils.getResultSetValue(resultSet, index, propertyDescriptor.getPropertyType());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a><strong>设计数据库</strong></h2><p>由于博主负责了本项目的数据库设计，因此在这里有一点心得想分享给大家。</p>
<p>首先是MySQL的建表规范（当然并不绝对）：</p>
<blockquote>
<ul>
<li>主键一律无意义，就算有意义，也必须是以后不会被更新，修改并且是自增的字段。命名规范一律是pk_id,数据类型为int unsigned,字段not null。</li>
<li>唯一索引命名一律以uk_为前缀，唯一索引并不以提高查询速率为主要目的，主要是进行唯一性约束。</li>
<li>唯一组合索引命名一律以ugk_为前缀，目的同上，注意最左前缀的问题。<br>由于主键一律设置的是无意义的自增字段，所以对于有外键约束的字段，只设置了级联删除（只更新父表的主键会存在外键约束）。</li>
<li>日期字段的数据类型一律为datetime。</li>
<li>所有表的字段设置为not null，数字默认值为0,字符串默认值为’’，datetime没有设置默认值，因此在后台必须处理时间问题。</li>
</ul>
</blockquote>
<p>当初在设计本项目的数据库时分别使用了主键与外键约束、唯一索引与组合索引、级联更新与级联删除等技术。对于这些技术的讲解在博主所置顶的几篇博客中就可以看到，因此不再讲解。</p>
<p>至于数据库结构与数据的SQL文件，在本人GitHub的README中有提供，感兴趣的可以去下载，源码地址在本篇博客开始已经给出～</p>
<p>Ok，XiyouLinux Group图书借阅平台的实现分析至此结束！</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/03/05/计算机网络-详解DNS域名系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/05/计算机网络-详解DNS域名系统/" itemprop="url">
                  计算机网络--详解DNS域名系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-05 18:01:22" itemprop="dateCreated datePublished" datetime="2018-03-05T18:01:22+08:00">2018-03-05</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/计算机网络/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">6.7k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">6 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>注：本篇博客大部分内容截选自阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">DNS 原理入门</a>一文。</strong>其中少部分内容是博主自己的理解。</p>
<h2 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a><strong>什么是DNS</strong></h2><p>我们知道，网络本身只能理解数字形式的地址，也就是IP地址。但是直观的IP地址毫无规律，很难让人记住，并且如果使用IP地址浏览一个公司的主页，意味着这家公司一旦将主页移动到了另一台机器上，且该机器具有不同的IP地址，那么必须将该机器的IP地址通知给每一个人。因此人们引入了类似于<code>www.baidu.com</code>这样的域名。而要将域名转换为对应的IP地址，就需要<strong>DNS服务器（Domain Name System）</strong>。</p>
<p>在早期的ARPANET时代，只有一个简单的hosts.txt文件，它列出了所有的计算机名字和其对应的IP地址。每天晚上，所有的主机都从一个维护此文件的站点将该文件取回，然后在本地进行更新。对于一个拥有几百台大型分时机器的网络而言，这种方法工作的相当好。</p>
<p>然而当几百万台PC连接到互联网以后，问题就出现了。首先这个文件会变的非常大，并且主机名冲突的现象将会频繁发生。为了解决这些问题，DNS服务器应运而生。</p>
<p><strong>注：DNS服务器和域名服务器同义。</strong></p>
<hr>
<h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a><strong>查询过程</strong></h2><p>虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。</p>
<p>工具软件dig可以显示整个查询过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig math.stackexchange.com</span><br></pre></td></tr></table></figure>
<p>上面的命令会输出六段信息：</p>
<p><img src="DNS查询过程.png" alt="这里写图片描述"></p>
<p><code>;;</code>开头的表示这一行是注释。</p>
<p><strong>1. 第一段是查询参数和统计。可以看到dig命令的一些基本信息，如版本和参数说明。还有一些对查询结果的简单统计：</strong></p>
<p><img src="DNS查询过程1.png" alt="这里写图片描述"></p>
<p><strong>2. 第二段是查询内容：</strong></p>
<p><img src="DNS查询过程2.png" alt="这里写图片描述"></p>
<p>上面结果表示，查询域名math.stackexchange.com的A记录，A是address的缩写，也就是查询域名的IP地址。</p>
<p><strong>3. 第三段是DNS服务器的答复：</strong></p>
<p><img src="DNS查询过程3.png" alt="这里写图片描述"></p>
<p>我们将上述图片中的每一行记录称为<strong>域名资源记录</strong>，DNS数据库就是由这些记录所构成。最常见的资源记录就是它的IP地址，但除此之外还有许多其他种类的资源记录。当解析器把一个域名传给DNS时，它能获得的DNS返回结果就是与该域名相关联的资源记录。</p>
<p>因此，<strong>DNS的基本功能是将域名映射至资源记录</strong>。</p>
<p>我们来看一下资源记录的格式：<strong>五元组</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Domain_name    Time_to_live    Class    Type    Value</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Domain_name（域名）：这条资源记录属于哪一个域</li>
<li>Time_to_live（生存期）：TTL值，表示缓存时间，在上图中就是600秒之内不用重新查询</li>
<li>Class（类别）：对于Internet信息，它总是IN。对于非Internet信息，则可以使用其他的代码，但实际很少见</li>
<li>Type（类型）：指出了本条资源记录是什么样的类型。DNS有许多类型，我们在<a href="#DNS的记录类型">DNS的记录类型</a>进行详细讨论</li>
<li>Value：可以是数字、域名、ASCII字符串，其取决于资源记录的类型</li>
</ul>
</blockquote>
<p>那么上面结果就显示，math.stackexchange.com有四个A记录，即四个IP地址。600是TTL值，表示缓存时间，即600秒之内不用重新查询。</p>
<p><strong>4. 第四段显示stackexchange.com的NS记录（Name Server的缩写），即哪些服务器负责管理stackexchange.com的DNS记录：</strong></p>
<p><img src="DNS查询过程4.png" alt="这里写图片描述"></p>
<p>上面结果显示stackexchange.com共有四条NS记录，即四个域名服务器，向其中任一台查询就能知道math.stackexchange.com的IP地址是什么。</p>
<p>这里有一些分级查询的内容，我们稍后在讲。我们此时应该注意为什么<code>stackexchange.com</code>有四台域名服务器？</p>
<p>在理论上，一台域名服务器就足以。但实际上，这台服务器有可能会因负载过重而变得毫无用处。而且，一旦它停机，则域名必然会解析失败。这就是单个信息源所带来的问题。</p>
<p><strong>5. 第五段是上面四个域名服务器的IP地址，这是随着前一段一起返回的：</strong></p>
<p><img src="DNS查询过程5.png" alt="这里写图片描述"></p>
<p><strong>6. 第六段是DNS服务器的一些传输信息：</strong></p>
<p><img src="DNS查询过程6.png" alt="这里写图片描述"></p>
<p>上面结果显示，本机的DNS服务器是192.168.1.253，查询端口是53（DNS服务器的默认端口），以及回应长度是305字节。</p>
<p>如果不想看到这么多内容，可以使用+short参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dig +short math.stackexchange.com</span><br><span class="line"></span><br><span class="line">151.101.129.69</span><br><span class="line">151.101.65.69</span><br><span class="line">151.101.193.69</span><br><span class="line">151.101.1.69</span><br></pre></td></tr></table></figure>
<p>上面命令只返回<code>math.stackexchange.com</code>对应的4个IP地址（即A记录）。</p>
<hr>
<h2 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a><strong>DNS服务器</strong></h2><p>下面我们根据前面这个例子，一步步还原，本机到底怎么得到域名math.stackexchange.com的IP地址。</p>
<p>首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。</p>
<p>除了本地DNS服务器。有一些公网的DNS服务器，也可以使用，其中最有名的就是Google的<code>8.8.8.8</code>和Level 3的<code>4.2.2.2</code>。</p>
<p>本机只向自己的DNS服务器查询，dig命令有一个@参数，显示向其他DNS服务器查询的结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig @4.2.2.2 math.stackexchange.com</span><br></pre></td></tr></table></figure>
<p>上面命令指定向DNS服务器4.2.2.2查询。</p>
<hr>
<h2 id="域名层级"><a href="#域名层级" class="headerlink" title="域名层级"></a><strong>域名层级</strong></h2><p>DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。</p>
<p>请仔细看前面的例子，每个域名的尾部都多了一个点。</p>
<p><img src="DNS查询过程2.png" alt="这里写图片描述"></p>
<p>比如，域名<code>math.stackexchange.com</code>显示为<code>math.stackexchange.com.</code>。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。</p>
<p>举例来说，<code>www.example.com</code>真正的域名是<code>www.example.com.root</code>，简写为<code>www.example.com.</code>。因为，根域名<code>.root</code>对于所有域名都是一样的，所以平时是省略的。</p>
<p>根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如.com、.net；再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如<a href="http://www.example.com里面的.example，这一级域名是用户可以注册的（可以了解一下域名抢注问题）；再下一级是主机名（host），比如www.example.com里面的www，又称为&quot;三级域名&quot;，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。" target="_blank" rel="noopener">www.example.com里面的.example，这一级域名是用户可以注册的（可以了解一下域名抢注问题）；再下一级是主机名（host），比如www.example.com里面的www，又称为&quot;三级域名&quot;，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。</a></p>
<p>总结一下，域名的层级结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br><span class="line"></span><br><span class="line">host.sld.tld.root</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a><strong>根域名服务器</strong></h2><p>DNS服务器<strong>根据域名的层级，进行分级查询</strong>。</p>
<p>需要明确的是，<strong>每一级域名都有自己的NS记录</strong>，NS记录指向<strong>该级域名</strong>的域名服务器。<strong>这些服务器知道下一级域名的各种记录。</strong></p>
<p>所谓<strong>“分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址</strong>，过程大致如下：</p>
<blockquote>
<ol>
<li>从根域名服务器查到顶级域名服务器的NS记录和A记录（IP地址）</li>
<li>从顶级域名服务器查到次级域名服务器的NS记录和A记录（IP地址）</li>
<li>从次级域名服务器查出主机名的IP地址</li>
</ol>
</blockquote>
<p>仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道根域名服务器的IP地址。回答是<strong>根域名服务器的NS记录和IP地址一般是不会变化的，所以内置在本地DNS服务器里面</strong>。</p>
<p>下面是内置的根域名服务器IP地址的一个例子：</p>
<p><img src="根域名服务器IP地址.png" alt="这里写图片描述"></p>
<p>上面列表中，列出了根域名（.root）的三条NS记录<code>A.ROOT-SERVERS.NET</code>、<code>B.ROOT-SERVERS.NET</code>和<code>C.ROOT-SERVERS.NET</code>，以及它们的IP地址（即A记录）<code>198.41.0.4</code>、<code>192.228.79.201</code>、<code>192.33.4.12</code>。</p>
<p>另外，可以看到所有记录的TTL值是3600000秒，相当于1000小时。也就是说，每1000小时才查询一次根域名服务器的列表。</p>
<p>目前，世界上一共有十三组根域名服务器，从<code>A.ROOT-SERVERS.NET</code>一直到<code>M.ROOT-SERVERS.NET</code>。</p>
<hr>
<h2 id="分级查询实例"><a href="#分级查询实例" class="headerlink" title="分级查询实例"></a><strong>分级查询实例</strong></h2><p>dig命令的+trace参数可以显示DNS的整个分级查询过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +trace math.stackexchange.com</span><br></pre></td></tr></table></figure>
<p>上面命令的第一段列出根域名.的所有NS记录，即所有根域名服务器：</p>
<p><img src="根域名服务器.png" alt="这里写图片描述"></p>
<p>根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问<code>math.stackexchange.com</code>的顶级域名服务器com.的NS记录。最先回复的根域名服务器将被缓存（缓存到本地DNS服务器上），以后只向这台服务器发请求。</p>
<p>接着是第二段：</p>
<p><img src="一级域名服务器.png" alt="这里写图片描述"></p>
<p>上面结果显示.com域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。</p>
<p>然后，DNS服务器向这些顶级域名服务器发出查询请求，询问<code>math.stackexchange.com</code>的次级域名<code>stackexchange.com</code>的NS记录：</p>
<p><img src="二级域名服务器.png" alt="这里写图片描述"></p>
<p>上面结果显示<code>stackexchange.com</code>有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。</p>
<p>然后，DNS服务器向上面这四台NS服务器查询<code>math.stackexchange.com</code>的主机名：</p>
<p><img src="主机名所在服务器.png" alt="这里写图片描述"></p>
<p>上面结果显示，<code>math.stackexchange.com</code>有4条A记录，即这四个IP地址都可以访问到网站。并且还显示，最先返回结果的NS服务器是<code>ns-463.awsdns-57.com</code>，IP地址为<code>205.251.193.207</code>。</p>
<p>在分级查询的过程中，还有2个技术要点值得讨论。</p>
<h3 id="递归查询与迭代查询"><a href="#递归查询与迭代查询" class="headerlink" title="递归查询与迭代查询"></a><strong>递归查询与迭代查询</strong></h3><p>我们再来补充一些概念：</p>
<blockquote>
<ul>
<li>域名解析：查询一个域名和找出其对应地址的过程</li>
<li>本地DNS服务器：参考知乎—<a href="https://www.jianshu.com/p/e84ccddd45b5" target="_blank" rel="noopener">本地DNS服务器的作用</a></li>
</ul>
</blockquote>
<p>先抛开分级查询不说，DNS的使用方法大致如下：为了将一个域名映射成IP地址，应用程序调用一个名为解析器的库程序，并将域名作为参数传递给此程序。然后解析器向本地DNS服务器发送一个包含该名字的请求报文；本地DNS服务器查询该名字，并且返回一个包含该名字对应IP地址的响应报文给解析器，然后解析器再将IP地址返回给调用方。</p>
<p>但是如果我们要查询的域名在远端，即本地DNS服务器没有相关域名的缓存信息，那么域名服务器就会进行一次远程查询，而远程查询的过程，则对应我们上面所说的分级查询。图表形式如下：</p>
<p><img src="分级查询.jpg" alt="这里写图片描述"></p>
<ul>
<li><strong>递归查询</strong></li>
</ul>
<blockquote>
<ul>
<li>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。</li>
<li>所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</li>
</ul>
</blockquote>
<ul>
<li><strong>迭代查询</strong></li>
</ul>
<blockquote>
<ul>
<li>当根域名服务器收到本地域名服务器发出的<strong>迭代查询</strong>请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个次级域名服务器进行查询… …最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</li>
</ul>
</blockquote>
<p>由上图可知，DNS域名系统同时涉及了两种机制。如果采用单一的迭代查询方式，则查询过程如下：</p>
<p><img src="迭代查询.jpg" alt="此处输入图片的描述"></p>
<p>可以看到，如果使用单一的迭代查询，DNS客户端将变的异常繁忙，CPU资源被抢占，用户体验将会下降。</p>
<p>通过结合使用递归查询与迭代查询，将DNS查询的重担交给本地DNS服务器，客户端就可以在DNS查询的过程中干自己想干的事情。</p>
<p><strong>总结：</strong></p>
<blockquote>
<ul>
<li>递归：客户端只发一次请求，要求对方给出最终结果。</li>
<li>迭代：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。</li>
</ul>
</blockquote>
<p><strong>从递归和迭代查询可以看出：</strong></p>
<blockquote>
<ul>
<li>客户端—本地DNS服务端：这部分属于递归查询。</li>
<li>本地dns服务端—外网：这部分属于迭代查询。</li>
</ul>
</blockquote>
<hr>
<h2 id="DNS的记录类型"><a href="#DNS的记录类型" class="headerlink" title="DNS的记录类型"></a><strong>DNS的记录类型</strong></h2><p>域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，“记录”可以分成不同的类型（type），前面已经看到了有A记录和NS记录。</p>
<p>常见的DNS记录类型如下：</p>
<blockquote>
<ol>
<li>A：地址记录（Address），返回域名指向的IPv4地址。</li>
<li>AAAA：地址记录（Address），返回域名指向的IPv6地址。</li>
<li>NS：域名服务器记录（Name Server），<strong>返回保存下一级域名信息的服务器地址</strong>。该记录只能设置为域名，不能设置为IP地址。</li>
<li>MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。</li>
<li>CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。</li>
<li>PTR：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。</li>
</ol>
</blockquote>
<p>一般来说，为了服务的安全可靠，至少应该有两条NS记录，而A记录和MX记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。</p>
<p>CNAME记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，<code>facebook.github.io</code>这个域名就是一个CNAME记录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dig facebook.github.io</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">facebook.github.io. 3370    IN  CNAME   github.map.fastly.net.</span><br><span class="line">github.map.fastly.net.  600 IN  A   103.245.222.133</span><br></pre></td></tr></table></figure>
<p>上面结果显示，<code>facebook.github.io</code>的CNAME记录指向<code>github.map.fastly.net</code>。也就是说，用户查询<code>facebook.github.io</code>的时候，实际上返回的是<code>github.map.fastly.net</code>的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改<code>github.map.fastly.net</code>这个域名就可以了，用户的<code>facebook.github.io</code>域名不用修改。</p>
<p>由于CNAME记录就是一个替换，所以域名一旦设置CNAME记录以后，就不能再设置其他记录了（比如A记录和MX记录），这是为了防止产生冲突。举例来说，<code>foo.com</code>指向<code>bar.com</code>，而两个域名各有自己的MX记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置MX记录，所以一般不允许用户对顶级域名设置CNAME记录。</p>
<p>PTR记录用于从IP地址反查域名。dig命令的-x参数用于查询PTR记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dig -x 192.30.252.153</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">153.252.30.192.in-addr.arpa. 3600 IN    PTR pages.github.com.</span><br></pre></td></tr></table></figure>
<p>逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有它所声称的域名。</p>
<p>dig命令可以查看指定的记录类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dig a github.com</span><br><span class="line">dig ns github.com</span><br><span class="line">dig mx github.com</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol>
<li>熟悉DNS的查询过程：<strong>分级查询</strong>；</li>
<li>熟悉分级查询中，递归查询与迭代查询的概念及使用场景；</li>
<li>熟悉本地DNS服务器的作用，了解DNS缓存机制；</li>
<li>掌握资源记录的格式：<strong>五元组</strong>；</li>
<li>掌握域名层级的概念：根域名、顶级域名、次级域名、主机名；</li>
<li>了解DNS的记录类型。</li>
</ol>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>计算机网络（第五版）— Andrew S.Tanenbaum、David J.Wetherall</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">DNS原理入门 — 阮一峰</a></p>
<p><a href="https://www.cnblogs.com/qingdaofu/p/7399670.html" target="_blank" rel="noopener">DNS递归查询与迭代查询 — 皈依之路</a></p>
<p><a href="https://www.jianshu.com/p/e84ccddd45b5" target="_blank" rel="noopener">本地DNS服务器的作用 — ALEXIRC</a></p>
<p><a href="http://blog.51cto.com/longlei/2058298" target="_blank" rel="noopener">DNS缓存服务器配置详解 — long9617</a></p>
<p><a href="https://blog.csdn.net/lycb_gz/article/details/11720247" target="_blank" rel="noopener">例解DNS递归/迭代名称解析原理 — 茶乡浪子</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/03/02/Java网络爬虫-多线程爬虫（抓取淘宝商品详情页URL）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/Java网络爬虫-多线程爬虫（抓取淘宝商品详情页URL）/" itemprop="url">
                  Java网络爬虫--多线程爬虫（抓取淘宝商品详情页URL）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-02 22:35:30" itemprop="dateCreated datePublished" datetime="2018-03-02T22:35:30+08:00">2018-03-02</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java网络爬虫/" itemprop="url" rel="index"><span itemprop="name">Java网络爬虫</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">14k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">13 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>源码地址：<a href="h   ttps://github.com/championheng/multithreading-crawlers">多线程爬虫–抓取淘宝商品详情页URL</a></strong></p>
<p>项目地址中包含了一份README，因此对于项目的介绍省去部分内容。这篇博客，主要讲述项目的构建思路以及实现细节。</p>
<hr>
<h2 id="项目概述及成果"><a href="#项目概述及成果" class="headerlink" title="项目概述及成果"></a><strong>项目概述及成果</strong></h2><p>首先将本项目使用到技术罗列出来：</p>
<blockquote>
<ol>
<li>MySQL数据库进行数据持久化及对宕机情况的发生做简单的处理</li>
<li>Redis数据库做IP代理池及部分已抓取任务的缓存</li>
<li>自制IP代理池</li>
<li>使用多线程执行任务（同步块，读写锁，等待与通知机制，线程优先级）</li>
<li>HttpClient与Jsoup的使用</li>
<li>序列化与反序列化</li>
<li>布隆过滤器</li>
</ol>
</blockquote>
<p>之后会对其中使用到的技术进行详细的解释。</p>
<p>本项目如README中所述，还有许多不完善的地方，但IP代理池与任务抓取线程之间的调度与协作基本已无问题。也就是说，在此项目的框架上，如果你想修改其中代码用作其他抓取任务，也是完全可以的。我抓取到的数据所保存的源文件也放在GitHub的README上供大家免费浏览与下载（近90000的商品ID）。</p>
<hr>
<h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a><strong>整体思路</strong></h2><blockquote>
<ol>
<li>首先你需要一个IP代理池</li>
<li>使用本机IP将淘宝中基本的商品分类抓取下来</li>
</ol>
<ul>
<li>页面源链接：<code>https://www.taobao.com/tbhome/page/market-list</code></li>
<li>从页面源链接中解析到的URL形如下：<code>https://s.taobao.com/search?q=羽绒服&amp;style=grid</code></li>
</ul>
<ol start="3">
<li>将诸如此类的URL<code>https://s.taobao.com/search?q=羽绒服&amp;style=grid</code>作为任务队列，使用多线程对其进行抓取与解析（使用代理IP）,解析的内容为第4点</li>
<li>我们需要分析每一种类的商品在淘宝中大概具有多少数量，为此我解析出带有页面参数的URL，在第3点中URL的基础上：<code>https://s.taobao.com/search?q=羽绒服&amp;style=grid&amp;s=44</code>，在浏览器中打开URL可发现此页面为此种类衣服的第二页</li>
<li>我们得到了每一种商品带有页面参数的URL，意味着我们可以得到此类商品中全部或部分的商品ID，有了商品ID，我们就可以进入商品详情页抓取我们想要的数据了</li>
<li>为了实现第5点，我们先将第4点中抓取到的URL全部存储进MySQL中</li>
<li>从MySQL中将待抓取URL全部取出，存储到一个队列中，使用多线程对此共享队列进行操作，使用代理IP从待解析URL中解析出本页面中包含的商品ID，并构建商品详情页URL</li>
<li>在第7点中解析商品ID的时候，同时使用布隆过滤器，对重复ID进行过滤，并将已经抓取过的URL任务放入Redis缓存中，等达到合适的阈值时，将存储在MySQL中对应的URL行记录中的flag置为true，表示此URL已经被抓取过，等到下一次重启系统，可以不用对此URL进行抓取</li>
</ol>
</blockquote>
<hr>
<h2 id="实现细节（省略大量实现代码，如有需要请阅读源码）"><a href="#实现细节（省略大量实现代码，如有需要请阅读源码）" class="headerlink" title="实现细节（省略大量实现代码，如有需要请阅读源码）"></a><strong>实现细节（省略大量实现代码，如有需要请阅读源码）</strong></h2><h3 id="IP代理池"><a href="#IP代理池" class="headerlink" title="IP代理池"></a><strong>IP代理池</strong></h3><p>我们先从IP代理池说起，在这个项目中所运用到的IP代理池与我在<a href="http://blog.csdn.net/championhengyi/article/details/77053448" target="_blank" rel="noopener">Java网络爬虫（十一）–重构定时爬取以及IP代理池（多线程+Redis+代码优化）</a>这一篇博客中所讲述的IP代理池的实现思想有一些细小的差别。</p>
<ul>
<li><strong>差别1：不再使用定时更新IP代理池的方法</strong></li>
</ul>
<blockquote>
<p>由于是将IP代理池真正的运用到一个工程中，因此定时更新IP代理池的方法已经不可取。我们的IP代理池作为一个生产者，众多线程都要使用其中的代理IP，我们就可以认为这些线程都为消费者，根据多线程中经典的<strong>生产者与消费者模型</strong>，在没有足够的产品供消费者使用的时候，生产者就应该开始进行生产。也就是说，IP代理池的更新变为，当池中已经没有足够的代理IP供众多线程使用的时候，IP代理池就应该开始进行更新。而在IP代理池进行更新的时候，众多线程作为消费者，也只能等待。</p>
</blockquote>
<p>具体的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建生产者（ip-proxy-pool）与消费者（thread-tagBasicPageURL-i）等待/通知机制所需的对象锁</span></span><br><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p><strong>生产者—IP代理池</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-8-11.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: IP代理池的整体构建逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimeJob</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="comment">// IP代理池线程是生产者，此锁用来实现等待/通知机制，实现生产者与消费者模型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line"></span><br><span class="line">    MyTimeJob(Object lock) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果IP代理池中没有IP信息，则IP代理池进行工作</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (myRedis.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">	                ... ...</span><br><span class="line"></span><br><span class="line">                    lock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>消费者—thread-tagBasicPageURL-i</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 下午1:01 18-2-1.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 得到带有分页参数的主分类搜索页面的URL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TagBasicPageCrawlerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;              <span class="comment">// 有关生产者、消费者的锁</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TagBasicPageCrawlerThread</span><span class="params">(Queue&lt;String&gt; tagBasicUrls, Object lock, Queue&lt;String&gt; tagBasicPageUrls,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Object taskLock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tagBasicUrls = tagBasicUrls;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        <span class="keyword">this</span>.tagBasicPageUrls = tagBasicPageUrls;</span><br><span class="line">        <span class="keyword">this</span>.taskLock = taskLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    ... ...</span><br><span class="line">	    </span><br><span class="line">        <span class="comment">// 此flag用于---&gt;如果IP可以进行抓取，则一直使用此IP，不在IP代理池中重新拿取新IP的逻辑判断</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个URL用单独的代理IP进行分析</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (myRedis.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", "</span> +</span><br><span class="line">                                    <span class="string">"发现ip-proxy-pool已空, 开始进行等待... ..."</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ipMessage = myRedis.getIPByList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ... ...    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中，我们可以清楚的看到等待/通知机制的经典范式：</p>
<p><strong>等待方（伪代码）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">	<span class="keyword">while</span>(条件不满足) &#123;</span><br><span class="line">	    对象.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	对应的逻辑处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通知方（伪代码）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">     改变条件</span><br><span class="line">     对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于等待/通知机制更详细的使用，参考这篇博客：<a href="http://blog.csdn.net/canot/article/details/50879963" target="_blank" rel="noopener">Java线程之间的通信(等待/通知机制)</a></p>
<ul>
<li><strong>差别2：不再给每个线程分配固定数目的任务。将任务放在共享队列中，供线程使用</strong></li>
</ul>
<blockquote>
<p>在重构IP代理池的那一版本中，我将待抓取任务平分给了多个线程，每个线程将自己拿到的那些任务执行完毕即可。在将IP代理池运用到工程中的时候，我并没有那样做，而是维护了一个任务队列，每个线程都可以在这个任务队列中取任务，直到队列为空为止。这就改善了在多个线程平分任务的这种情况下，由于一个线程需要完成多个任务，而这多个任务间不是并发执行的缺点。</p>
</blockquote>
<p>具体的代码实现如下（我们只需要注意其中的saveIP方法，方法参数urls就是共享任务队列）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-8-11.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抓取xici代理网的分配线程</span></span><br><span class="line"><span class="comment"> * 抓取不同页面的xici代理网的html源码，就使用不同的代理IP，在对IP进行过滤之后进行合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateIPProxyPool</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveIP</span><span class="params">(Queue&lt;String&gt; urls, Object taskLock)</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 随机挑选代理IP(本步骤由于其他线程有可能在位置确定之后对ipMessages数量进行</span></span><br><span class="line"><span class="comment">             * 增加，虽说不会改变已经选择的ip代理的位置，但合情合理还是在对共享变量进行读写的时候要保证</span></span><br><span class="line"><span class="comment">             * 其原子性，否则极易发生脏读)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ... ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务队列是共享变量，对其的读写必须进行正确的同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (taskLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", 发现任务队列已空"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                url = urls.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IP代理池在项目中是如何对抗反爬虫的"><a href="#IP代理池在项目中是如何对抗反爬虫的" class="headerlink" title="IP代理池在项目中是如何对抗反爬虫的"></a>IP代理池在项目中是如何对抗反爬虫的</h3><p>我在使用IP代理池对抗反爬虫的时候，对IP代理池还做了些许改变：修改了IPMessage类结构。看过我关于IP代理池项目博客的同学应该清楚IPMessage这个类是做什么的，就是用来存储有关代理IP信息的。类结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-8-11.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: IPMessage JavaBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String IPAddress;</span><br><span class="line">    <span class="keyword">private</span> String IPPort;</span><br><span class="line">    <span class="keyword">private</span> String IPType;</span><br><span class="line">    <span class="keyword">private</span> String IPSpeed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> useCount;            <span class="comment">// 使用计数器，连续三十次这个IP不能使用，就将其从IP代理池中进行清除</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPMessage</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.useCount = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPMessage</span><span class="params">(String IPAddress, String IPPort, String IPType, String IPSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.IPAddress = IPAddress;</span><br><span class="line">        <span class="keyword">this</span>.IPPort = IPPort;</span><br><span class="line">        <span class="keyword">this</span>.IPType = IPType;</span><br><span class="line">        <span class="keyword">this</span>.IPSpeed = IPSpeed;</span><br><span class="line">        <span class="keyword">this</span>.useCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUseCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> useCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUseCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.useCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.useCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我给其中添加了<code>useCount</code>这一成员变量。我在使用xici代理网上的IP时发现，大部分的代理IP一次不能使用并不代表每次都不可使用，因此我在用代理IP进行网页抓取时的策略作出了如下的改变：</p>
<blockquote>
<ol>
<li>当前代理IP如果解析当前任务失败，则将此代理IP中的useCount变量进行加1，并将此代理IP进行序列化之后，重新丢进IP代理池，切换至其他代理IP</li>
<li>如果当前代理IP解析当前任务成功，则将此代理IP中的useCount变量置0，并且继续使用此代理对其它任务进行抓取，直到任务解析失败，然后重复第1点</li>
<li>如果发现从IP代理池中取出的代理IP的useCount变量数值已为30，则对此代理IP进行舍弃，并切换至其他代理IP</li>
</ol>
</blockquote>
<p>具体的代码实现如下：</p>
<ul>
<li><strong>舍弃代理IP，flag用于判断是否需要从IP代理池中拿取新的IP</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 下午4:25 18-2-6.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 负责解析带有页面参数的商品搜索页url，得到本页面中的商品id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsDetailsUrlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;                      <span class="comment">// 用于与 ip-proxy-pool 进行协作的锁</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (myRedis.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", "</span> +</span><br><span class="line">                                    <span class="string">"发现ip-proxy-pool已空, 开始进行等待... ..."</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ipMessage = myRedis.getIPByList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ipMessage.getUseCount() &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", 发现此ip："</span> +</span><br><span class="line">                        ipMessage.getIPAddress() + <span class="string">":"</span> + ipMessage.getIPPort() + <span class="string">", 已经连续30次不能使用, 进行舍弃"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>当前代理IP解析任务成功（失败），useCount置0（++），并持续使用此代理IP抓取新任务（将代理IP丢进IP代理池并拿取新IP）</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: spider_hgyi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 下午4:25 18-2-6.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 负责解析带有页面参数的商品搜索页url，得到本页面中的商品id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodsDetailsUrlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (myRedis.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">", "</span> +</span><br><span class="line">                                    <span class="string">"发现ip-proxy-pool已空, 开始进行等待... ..."</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ipMessage = myRedis.getIPByList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">			... ...</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (html != <span class="keyword">null</span>) &#123;</span><br><span class="line">				... ...</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	            <span class="comment">// 当前任务解析失败，将当前任务重新放入任务队列中，并将flag置为true</span></span><br><span class="line">                <span class="keyword">synchronized</span> (tagBasicPageUrls) &#123;</span><br><span class="line">                    tagBasicPageUrls.offer(tagBasicPageUrl);</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hg_yi on 17-5-23.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 对淘宝页面的请求，得到页面的源码</span></span><br><span class="line"><span class="comment"> * setConnectTimeout：设置连接超时时间，单位毫秒.</span></span><br><span class="line"><span class="comment"> * setSocketTimeout：请求获取数据的超时时间，单位毫秒.如果访问一个接口，</span></span><br><span class="line"><span class="comment"> * 多少时间内无法返回数据，就直接放弃此次调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成功抓取淘宝页面计数器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> pageCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用代理IP进行网页的获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHtmlByProxy</span><span class="params">(String requestUrl, IPMessage ipMessage, Object lock)</span> </span>&#123;</span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ... ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 得到服务响应状态码</span></span><br><span class="line">            <span class="keyword">if</span> (statusCode == <span class="number">200</span>) &#123;</span><br><span class="line">                ... ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ... ...</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 只要能返回状态码，没有出现异常，则此代理IP就可使用</span></span><br><span class="line">            ipMessage.initCount();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            ... ...</span><br><span class="line">            ipMessage.setUseCount();</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                myRedis.setIPToList(ipMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ... ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a><strong>布隆过滤器</strong></h3><p>在这篇博客中，详细的介绍了布隆过滤器的实现原理：<a href="http://blog.csdn.net/championhengyi/article/details/72885500" target="_blank" rel="noopener">海量URL去重之布隆过滤器</a>，我在将布隆过滤器应用到项目中的时候，有些方法发生了改变。</p>
<p>之所以将布隆过滤器在这里单独提出来，是因为想给大家提供自己之前写的有关布隆过滤器的实现原理。搞清楚原理之后，大家再看项目中布隆过滤器的相关实现，也就会轻松许多。</p>
<h3 id="监控线程—tagBasicPageURLs-cache"><a href="#监控线程—tagBasicPageURLs-cache" class="headerlink" title="监控线程—tagBasicPageURLs-cache"></a><strong>监控线程—tagBasicPageURLs-cache</strong></h3><p>这个线程的主要作用是将Redis数据库中缓存的，已经成功解析过的任务，将其对应MySQL中所在的行记录中的flag位设置为true。在前面也说了，我将任务队列保存在了MySQL数据库中，其中对应的每一条记录，都有一个额外的标志位，flag。设置这一标志位的主要目的是，对爬虫系统做了一个简单的宕机恢复。我们应当对已经抓取过的任务做一定的标记手段，以防止在系统突然死机或其他突发状况下，需要重启项目的情况。这个时候，我们当然不可能对所有的任务重新进行抓取。</p>
<p>对于这个问题的处理，我在项目中的实现思路如下：</p>
<blockquote>
<ol>
<li>在任务抓取线程：<code>thread-GoodsDetailsUrl-i</code>，主要用来解析商品ID的线程中，如果抓取完一个任务，就将这个任务先缓存到Redis数据库中，毕竟如果直接将这个任务在MySQL中所在的行记录中的flag置为true的话，效率就有点低下了</li>
<li>设置监控线程：<code>tagBasicPageURLs-cache</code>，监控缓存在Redis数据库中已抓取过任务的数量，我设置的阈值是大于等于100，当然这个数字不绝对，因为线程调度是不可控的。但为了接近我所设置的这个阈值，我将此线程的优先级设置为最高</li>
<li>监控线程开始工作，期间使用同步块保证任务抓取线程不得给Redis数据库中添加新的已经抓取成功的任务，以达到监控线程与任务抓取线程对Redis数据库操作之间的互斥性</li>
</ol>
</blockquote>
<p>具体的代码实现如下：</p>
<p><strong>监控线程—tagBasicPageURLs-cache</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author: spider_hgyi</span><br><span class="line"> * @Date: Created in 上午11:51 18-2-6.</span><br><span class="line"> * @Modified By:</span><br><span class="line"> * @Description: 处理缓存的线程，将 tag-basic-page-urls 中存在的url标记进MySQL数据库中</span><br><span class="line"> */</span><br><span class="line">public class TagBasicPageURLsCacheThread implements Runnable &#123;</span><br><span class="line">    private final Object tagBasicPageURLsCacheLock;</span><br><span class="line"></span><br><span class="line">    public TagBasicPageURLsCacheThread(Object tagBasicPageURLsCacheLock) &#123;</span><br><span class="line">        this.tagBasicPageURLsCacheLock = tagBasicPageURLsCacheLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void start(Object tagBasicPageURLsCacheLock) &#123;</span><br><span class="line">        Thread thread = new Thread(new TagBasicPageURLsCacheThread(tagBasicPageURLsCacheLock));</span><br><span class="line">        thread.setName(&quot;tagBasicPageURLs-cache&quot;);</span><br><span class="line">        thread.setPriority(MAX_PRIORITY);           // 将这个线程的优先级设置最大，允许出现误差</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        MyRedis myRedis = new MyRedis();</span><br><span class="line">        MySQL mySQL = new MySQL();</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            synchronized (tagBasicPageURLsCacheLock) &#123;</span><br><span class="line">                while (myRedis.tagBasicPageURLsCacheIsOk()) &#123;</span><br><span class="line">                    System.out.println(&quot;当前线程：&quot; + Thread.currentThread().getName() + &quot;, &quot; +</span><br><span class="line">                            &quot;准备开始将 tag-basic-page-urls-cache 中的url在MySQL中进行标记&quot;);</span><br><span class="line"></span><br><span class="line">                    List&lt;String&gt; tagBasicPageURLs = myRedis.getTagBasicPageURLsFromCache();</span><br><span class="line">                    System.out.println(&quot;tagBasicPageURLs-size: &quot; + tagBasicPageURLs.size());</span><br><span class="line"></span><br><span class="line">                    // 将MySQL数据库中对应的url标志位置为true</span><br><span class="line">                    mySQL.setFlagFromTagsSearchUrl(tagBasicPageURLs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>任务抓取线程—thread-GoodsDetailsUrl-i</strong>：（截取了部分代码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line"><span class="comment">// 将tagBasicPageUrl写进Redis数据库</span></span><br><span class="line"><span class="keyword">synchronized</span> (tagBasicPageURLsCacheLock) &#123;</span><br><span class="line">	System.out.println(<span class="string">"当前线程："</span> + Thread.currentThread().getName() + <span class="string">"，准备将tagBasicPageUrl写进Redis数据库，tagBasicPageUrl："</span> + tagBasicPageUrl);</span><br><span class="line">	myRedis.setTagBasicPageURLToCache(tagBasicPageUrl);</span><br><span class="line">&#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p><strong>MyRedis中的tagBasicPageURLsCacheIsOk()方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 tagBasicPageURLs-cache 中的url数量是否达到100条</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tagBasicPageURLsCacheIsOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	tagBasicPageURLsCacheReadWriteLock.readLock().lock();</span><br><span class="line">	Long flag = jedis.llen(<span class="string">"tag-basic-page-urls-cache"</span>);</span><br><span class="line">	tagBasicPageURLsCacheReadWriteLock.readLock().unlock();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> flag &gt;= <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，我为什么会称自己对宕机情况的发生做了简单的处理：这个解决方案并不完美，可以说存在很大的瑕疵。</p>
<p>我在将已经缓存至Redis数据库中，并解析完成的任务URL通过监控线程—tagBasicPageURLs-cache进行MySQL中相关标志位置true的时候，设置的是当Redis数据库中缓存的任务数量达到100及以上的时候，这个监控线程才会启动。</p>
<p>那么就会出现一种情况：Redis数据库中的URL数量没有达到100及以上，这个时候系统发生宕机，那么这些已经抓取过的URL在MySQL中所对应的flag标志位就不会被置为true。也就是说，在我们下次重新启动该系统的时候，这些已经抓取过的URL还会被重新抓取，并且每次存在的误差并无法严格判定，有可能没有误差，有可能误差达到了百条左右。</p>
<p>针对这个bug，目前博主还没有想到比较好的解决办法，相信日后会攻破它。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/01/12/JVM-深入剖析继承与多态实现原理（合集篇）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/12/JVM-深入剖析继承与多态实现原理（合集篇）/" itemprop="url">
                  JVM--深入剖析继承与多态实现原理（合集篇）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-01-12 14:53:43" itemprop="dateCreated datePublished" datetime="2018-01-12T14:53:43+08:00">2018-01-12</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">193</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">1 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于我将继承与多态的讲解分成了三篇博客，所以在这篇博客给出三篇博客总的链接，阅读顺序由第一篇至第三篇就可以。</p>
<p>第一篇：主要讲解分派：<a href="https://blog.dhengyi.name/2017/12/09/JVM-%E8%AF%A6%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E4%B9%8B%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%88%86%E6%B4%BE/">JVM–详解虚拟机字节码执行引擎之静态链接、动态链接与分派</a></p>
<p>第二篇：主要讲解invokevirtual指令：<a href="https://blog.dhengyi.name/2018/01/08/JVM-%E4%BB%8EJVM%E5%B1%82%E9%9D%A2%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/">JVM–从JVM层面深入解析对象实例化、多态性实现机制</a></p>
<p>第三篇：主要讲解继承与方法表：<a href="https://blog.dhengyi.name/2018/01/10/JVM-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/">JVM–再谈继承与多态</a></p>
<p>相信这三篇博客会给你带来惊喜~~~</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/01/10/JVM-再谈继承与多态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/10/JVM-再谈继承与多态/" itemprop="url">
                  JVM--再谈继承与多态
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-01-10 16:14:59" itemprop="dateCreated datePublished" datetime="2018-01-10T16:14:59+08:00">2018-01-10</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">6.6k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">6 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>此文试图从JVM层面深刻剖析Java中的继承与多态，知识面覆盖class字节码文件，对象的内存布局，JVM的内存区域、分派，方法表等相关知识，内容整合于大量博客，知乎，书籍，并加上博主自己的理解，相信看完会对你大有裨益！</p>
<p>即使博主在JVM专栏已经有两篇博客对多态的实现机制进行了分析，但是今天在分析了一波继承的原理之后，发觉之前对于多态的讲述还不完整，在查阅的相关资料之后，决定在这一篇博客真正的将继承与多态讲透彻！</p>
<p><strong>注：本篇博客有部分内容摘抄自：<a href="https://www.cnblogs.com/qingergege/p/6853547.html" target="_blank" rel="noopener">从JVM角度看Java多态</a>。表示感谢~</strong></p>
<hr>
<p>先来看一份代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		age = <span class="number">40</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父亲在吃饭"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		age = <span class="number">18</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"孩子在吃饭"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"孩子在打CS"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPolymorphic</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Parent c = <span class="keyword">new</span> Child();</span><br><span class="line">		</span><br><span class="line">		c.eat();</span><br><span class="line"><span class="comment">//		c.play();</span></span><br><span class="line">		System.out.println(<span class="string">"年龄："</span> + c.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">孩子在吃饭</span><br><span class="line">年龄：40</span><br></pre></td></tr></table></figure>
<p>并且如果我在代码中没有将<code>c.play()</code>进行注释的话，将会编译错误。</p>
<p>对于这些结果，我会在随后给大家进行说明。我将以问答的形式来组成这篇博客的架构。随着问题的深入这些疑惑都会被解决。</p>
<hr>
<h2 id="类之间的继承，都继承了哪些东西？"><a href="#类之间的继承，都继承了哪些东西？" class="headerlink" title="类之间的继承，都继承了哪些东西？"></a><strong>类之间的继承，都继承了哪些东西？</strong></h2><p>既然要谈多态，就不能绕开继承。那就从继承开始讲起。很经典也很值得思考的问题，子类从父类上都继承了哪些东西？在类的字节码文件中是怎么体现的呢？实例化后在内存中又是怎么体现的呢？</p>
<h3 id="从语言层面上分析"><a href="#从语言层面上分析" class="headerlink" title="从语言层面上分析"></a><strong>从语言层面上分析</strong></h3><p>我们先来说清楚子类到底都继承了父类的哪些东西，当然这都是语言层面上的继承，不涉及它的具体实现：</p>
<blockquote>
<p>所有的东西，所有的父类的成员，包括变量（静态变量）、常量和方法（存储在方法表中），都成为了子类的成员，除了构造方法。构造方法是父类所独有的，因为它的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。</p>
</blockquote>
<p>网上有些博客给出，子类没有继承父类的private成员，这种说法是错误的。我们只能说子类不能覆盖且访问父类的private变量，所以当我们试图在子类中覆盖或访问父类的private变量的时候，编译器会给我们报错，但这并不意味着子类并没有继承父类的private变量与常量（隐藏了而已）。</p>
<h3 id="从字节码文件上分析"><a href="#从字节码文件上分析" class="headerlink" title="从字节码文件上分析"></a><strong>从字节码文件上分析</strong></h3><p>也许你会凭借上面所述的<strong>子类会继承父类的一切东西（除了构造器）</strong>而感觉在子类的字节码文件中也会包含父类的所有属性和方法。很遗憾，这种想法并不正确。先不说上面的例子，我们知道在Java中所有的类都默认继承自Object，你可以尝试使用javap命令编译一个普通类的class文件，看看其产生的字节码文件中是否含有Object中默认定义的方法信息，好比toString，equals方法等，如果你并没有重写这些方法的话。</p>
<p>那么在字节码文件中是如何表示两个类之间的继承关系呢？如果你对class文件熟悉的话，应该知道字节码中含有字段表集合，方法表集合与父类索引和接口索引集合。</p>
<p>字段表集合用于描述接口或类中声明的变量。方法表用于描述接口或类中所定义的方法。而<strong>父类索引与接口索引（implement也是一种继承）则是用来确定这个类的继承关系</strong>。父类索引用两个u2类型（表示两个字节）的索引值表示，它指向一个类型为CONSTANT_Class_info的类描述符常量，这个类型常量存储于字节码的常量池中，通过CONSTANT_Class_info类型常量中的索引值可以找到定义在CONSTANT_Utf8_info类型常量中的全限定名字符串。CONSTANT_Utf8_info在常量池中表示的就是UTF-8编码的字符串，也就是父类的名称。而接口索引的索引表之前还有一个接口计数器，也是u2类型的，之所以有计数器，我们也知道，在Java中，类都是单根继承，但是可以同时操作多个接口。索引表的内容则和父类索引相似，就不再赘述了。</p>
<p>因此在子类的字节码文件中，它的字段表集合中不会列出从基类或父接口中继承而来的字段。与字段表相对应，如果父类方法在子类中没有被重写，方法表集合中也不会出现来自父类的方法信息。我们在语言层面上所使用的继承，对应到字节码文件中，只不过是子类的字节码文件中含有父类的索引罢了，父类中的属性，方法都是通过这个索引找到指定的父类从而解析出来的。至于怎么找，怎么解析，则是类加载器与类加载机制部分的知识了，我在JVM专栏的相关博客中也有说明。</p>
<h3 id="实例化后从内存上分析"><a href="#实例化后从内存上分析" class="headerlink" title="实例化后从内存上分析"></a><strong>实例化后从内存上分析</strong></h3><p>首先问大家一个问题：创建子类对象的时候，会一同创建父类的对象吗？</p>
<p>我没有查阅过官方文档，但是我在网络上搜索了大量的相关资料，并且与学长也进行了讨论，我目前偏向于，我觉得的确也是这样设计的：<strong>创建子类对象的时候不会一同创建父类的对象</strong>。</p>
<p>在知乎上，对这个问题进行了激烈的探讨：<a href="https://www.zhihu.com/question/51920553" target="_blank" rel="noopener">java中，创建子类对象时，父类对象会也被一起创建么？</a></p>
<p>首先我先说支撑自己观点的原因：</p>
<p>引用一下知乎网友的回答：</p>
<blockquote>
<p>new指令开辟空间，用于存放对象的各个属性，方法等，反编译字节码你会发现只有一个new指令，所以开辟的是一块空间，一块空间就放一个对象。然后，子类调用父类的属性，方法啥的，那并不是一个实例化的对象。并且如果一个子类继承自抽象类或着接口，那么实例化这个子类的时候还能实例化抽象类与接口不成？</p>
</blockquote>
<p>而像一些博客与书籍所说的“子类对象的一部分空间存放的是父类对象”，我觉得这涉及到对象的内存布局，等下在说这个问题。</p>
<p>现在解答一下上面代码中的部分运行结果吧：<code>c.eat()</code>。我之前已经写了两篇关于多态的文章，具体的链接我不再贴出，直接在我的JVM专栏中寻找就可以。看过我前两篇博客的读者对这个代码的运行结果应该不会有太大的疑惑，也就是我们前面讲述的那些<strong>动态分派</strong>与<strong>invokevirtual指令</strong>，但是在这篇博客中，对于多态的实现性机制，我还要再阐述一个关于<strong>虚方法表</strong>的概念。</p>
<p>在《深入理解Java虚拟机》这本书中，关于多态的实现机制也是讲述了这三方面的内容，我之所以将三个东西分开讲，是觉得没有前面两篇博客的沉淀，这三个东西还真的是不好串起来。当初博主看这部分内容的时候是一种似懂非懂的状态，完全对这个三个东西没有明确的认识，我昨天对这三个东西做了如下总结，觉得大概可以将多态的实现机制概括清楚：</p>
<ol>
<li><p>动态分派能够让我们从语言层面正确辨析重写（多态），我觉得它是Java语义上多态的实现；</p>
</li>
<li><p>invokevirtual指令则是对动态分派这个概念在JVM层面上功能的具体实现，即在JVM中是用怎样一种逻辑实现了动态分派。明白了这个指令，感觉也就体现了多态实现代码中的实现逻辑；</p>
</li>
<li><p>虚方法表则是支撑着invokevirtual指令的实现，我们知道invokevirtual指令代表了递归查找当前栈帧操作数栈顶上引用所代表的实际类型的过程，而虚方法表的实现就是让invokevirtual指令有地方可查。</p>
</li>
</ol>
<p>而且《深入理解Java虚拟机》一书中，也称虚方法表是“虚拟机动态分派”的实现。由此可见虚方法表对于多态的重要意义。</p>
<p>说了这么多，到底什么是虚方法表呢？</p>
<p>虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值之后，虚拟机会把该类的虚方法表也初始化完毕。虚方法表存储在方法区，虚方法表中存放的都是类中的实例方法，不会存储静态方法，因为静态方法属于非虚方法，会在类加载的解析阶段就将符号引用解析为直接引用，因此不需要虚方法表。关于非虚方法的描述请参考这篇博客：<a href="http://blog.csdn.net/championhengyi/article/details/78760590" target="_blank" rel="noopener">JVM–详解虚拟机字节码执行引擎之静态链接、动态链接与分派</a>。</p>
<p>虚方法表中的这些直接引用会指向JVM中相关类Class对象相应的方法信息上，当然这只是本类的方法，表中还有父类的方法，相应地指向父类类型Class对象的具体位置。</p>
<p>如果与上述代码对应的话，应该是这样：</p>
<p><img src="JVM方法区中的方法表.png" alt="这里写图片描述"></p>
<p>如上图所示，Parent，Child都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。然后再各自指向本类中方法所存在的数据类型。但是这里有两点需要注意：</p>
<ol>
<li><p>如果子类重写了父类的方法，如上面中的eat方法，则子类方法表中的地址将会替换为指向子类实现版本的入口地址，对应至上图就是父类中有属于自己的eat方法入口地址，子类也有属于自己的eat方法入口地址。因此invokevirtual指令才能正确的找到重写方法后的地址入口。</p>
</li>
<li><p>我们从上图中可以看出，相同的方法，在子类和父类的虚方法表中都具有一样的索引序号，这主要是为了程序实现上的方便，因为当实际类型发生变化时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。</p>
</li>
</ol>
<p>好了，如果将此篇博客中的虚方法表和前两篇博客中的动态分派与invokevirtual指令的查找过程完全弄明白的话，我觉的在理论方面你的多态已经算是完全没有问题了，如果你还想更加深入，我觉得无非就是看JVM中多态的实现源码了。</p>
<p>谈到这，我觉得<code>c.eat()</code>方法的运行结果不用我说你们也完全明白了吧。</p>
<p>那么接着上面所遗留的一个问题，<strong>对象的内存布局</strong>，解决掉这个东西，<code>c.play()</code>为什么会编译错误以及<code>System.out.println(&quot;年龄：&quot; + c.age)</code>等于40的真相也将慢慢浮上水面。</p>
<p><strong>以下内容引入自知乎用户</strong>：<a href="https://www.zhihu.com/people/zu-chun-lei/activities" target="_blank" rel="noopener">祖春雷</a></p>
<p> Java对象的内存布局是由对象所属的类确定。也可以这么说，当一个类被加载到虚拟机中时，由这个类创建的对象的布局就已经确定下来了。</p>
<p>Hotspot中Java对象的内存布局：</p>
<p>每个Java对象在内存中都由对象头和对象体组成。</p>
<p>对象头是存放对象的元信息，包括该对象所属类对象Class的引用以及hashcode和monitor的一些信息。关于对象头的介绍，这篇博客有些许说明<a href="http://blog.csdn.net/championhengyi/article/details/78778575" target="_blank" rel="noopener">JVM–详解创建对象与类加载的区别与联系</a>。</p>
<p>对象体主要存放的是<strong>Java对象自身的实例域以及从父类继承过来的实例域</strong>，并且内部布局满足以下规则（从我所标出的重点来看，创建子对象的时候，确实不是真正意义上的同时创建一个基类对象）：</p>
<blockquote>
<p>规则1：任何对象都是8个字节为粒度进行对齐的。<br>规则2：实例域按照如下优先级进行排列：长整型和双精度类型；整型和浮点型；字符和短整型；字节类型和布尔类型，最后是引用类型。这些实例域都按照各自的单位对齐。<br>规则3：不同类继承关系中的实例域不能混合排列。首先按照规则2处理父类中的实例域，接着才是子类的实例域。<br>规则4：当父类中最后一个成员和子类第一个成员的间隔如果不够4个字节的话，就必须扩展到4个字节的基本单位。<br>规则5：如果子类第一个实例域是一个双精度或者长整型，并且父类并没有用完8个字节，JVM会破坏规则2，按照整形（int），短整型（short），字节型（byte），引用类型（reference）的顺序，向未填满的空间填充。</p>
</blockquote>
<p>还是以一个例子说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span> six;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="title">extend</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前Sub对象的内存布局由下：</p>
<p><img src="实例对象的内存布局.jpg" alt="这里写图片描述"></p>
<p>但是这些东西还不足以解释为什么上述代码中<code>c.play()</code>会报错以及为什么<code>System.out.println(&quot;年龄：&quot; + c.age)</code>的答案是40。继续往下看。</p>
<p>我们需要注意这一句代码：<code>Parent c = new Child()</code>，可以发现，c的实际类型虽然是Child，但它的静态类型却是Parent，问题就出在了静态类型上！</p>
<p>学了这么长时间的Java，博主一直没有搞懂静态类型存在的真实意义，在网上查到的都是以面向对象的思想给你解释为什么Java中存在实际类型的同时还要存在静态类型，而没有从根本上说明静态类型到底会对变量产生什么样的影响。</p>
<p>博主目前查阅到的设计静态类型的真正作用有如下两点（也许还有更多）：</p>
<blockquote>
<ol>
<li>Java的类型检查机制是静态类型检查</li>
<li>规定了引用能够访问内存空间的大小</li>
</ol>
</blockquote>
<p>对于第一点，不是本文的重点，直接给大家贴一篇相关博客<a href="http://www.tiantianbianma.com/java-static-type-check.html/" target="_blank" rel="noopener">深入分析Java的静态类型检查</a>。</p>
<p>我们直接来讨论第二点。</p>
<p>我们都知道在C中有void类型的指针，而给指针前面限定一个类型就限制了指针访问内存的方式，比如<code>char *p</code>就表示p只能一个字节一个字节地访问内存，但是<code>int *p</code>中p就必须四个字节四个字节地访问内存。但是我们都知道指针是不安全的，其中一个不安全因素就是指针可能访问到没有分配的内存空间，也就是说<code>char *p</code>虽然限制了p指针访问内存的方式，但是没有限制能访问内存的大小，这一点要完全靠程序员自己掌握。</p>
<p>但是在Java中的静态类型不但指定了以何种方式访问内存，也规定了能够访问内存空间的大小。</p>
<p>对应于刚开始贴出得代码：</p>
<p>我们看Parent实例对象的大小是占两行，但Child实例对象占三行（这里就是简单量化一下）。</p>
<p>如下图：</p>
<p><img src="JVM堆区实例对象包含的内容.png" alt="这里写图片描述"></p>
<p>所以虽然引用c指向的是Child实例对象，但是前面有Parent修饰它，它也只能访问两行的数据，也就是说c根本访问不到Child类中的age！！！只能访问到Parent类的age，<strong>所以输出40</strong>。你也可以对照着我上面贴出的“Sub对象的内存布局”那张图来对刚开始贴出的代码进行分析。</p>
<p>而且我们注意两个类的方法表：</p>
<p><img src="两个类的方法表.png" alt="这里写图片描述"></p>
<p>我们看到Parent的方法表占三行，Child的方法表占4行，c虽然指向了Child类的实例对象，而对象中也有指针指向Child类的方法表，但是由于c受到了Parent的修饰，通过c也只能访问到Child方法表中前3行的内容！！！！<strong>因此<code>c.play()</code>编译会出错</strong>。就是这个原因，它在方法表中根本找不到play方法。</p>
<p>前面说过，在方法表的形成过程中，子类重写的方法会覆盖掉表中原来的数据，也就是Child类的方法表的第三行是指向Child.eat的引用，而不是指向Parent.eat（因为方法表产生了覆盖），所以c访问到的是Child.eat。也就是子类的方法（这也是作为多态的一种解释，比invokevirtual指令更加深入）！！！这种情况下，c是没有办法直接访问到父类的eat方法的。</p>
<p>好了，本篇博客的内容已结束，对开头的代码也做出了完整的解释。但是我们还是有一些地方没有涵盖，比如super关键字。对于super关键字的使用，我觉得如果你已经将我写的三篇有关于多态的博客吸收与消化，那么，对于super关键字的使用与基本理解，应该是没有问题的，至于对它的深入研究，我们以后再说~~~</p>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>《深入理解Java虚拟机》—周志明</p>
<p><a href="https://www.jianshu.com/p/da9876272ad7" target="_blank" rel="noopener">JAVA基础探究：子类与父类</a></p>
<p><a href="https://www.cnblogs.com/qingergege/p/6853547.html" target="_blank" rel="noopener">从JVM角度看Java多态</a></p>
<p><a href="https://www.zhihu.com/question/51920553" target="_blank" rel="noopener">java中，创建子类对象时，父类对象会也被一起创建么？</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2018/01/08/JVM-从JVM层面深入解析对象实例化、多态性实现机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/08/JVM-从JVM层面深入解析对象实例化、多态性实现机制/" itemprop="url">
                  JVM--从JVM层面深入解析对象实例化、多态性实现机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-01-08 18:24:57" itemprop="dateCreated datePublished" datetime="2018-01-08T18:24:57+08:00">2018-01-08</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">9.3k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">8 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前一直觉得对于字节码的执行过程，对象的实例化过程，多态的实现机制没有进行深刻的探讨，只是进行了简单的总结，一直也苦于没有找到恰当的例子，所幸今天看到一前辈的博客，对其进行钻研之后，终于解决了这个历史遗留问题。</p>
<p><strong>首先贴出前辈的原文链接，并且这篇博客会引用其中的一些内容：<a href="https://www.jianshu.com/p/cdc5adb40bb7" target="_blank" rel="noopener">Java重写方法与初始化的隐患</a></strong></p>
<hr>
<h2 id="问题的还原"><a href="#问题的还原" class="headerlink" title="问题的还原"></a><strong>问题的还原</strong></h2><p>先来看一份代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSuperX;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setX(<span class="number">99</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        mSuperX = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSubX = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setX(x);</span><br><span class="line">        mSubX = x;</span><br><span class="line">        System.out.println(<span class="string">"mSubX is assigned "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"mSubX = "</span> + mSubX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在main里调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubClass sc = <span class="keyword">new</span> SubClass();</span><br><span class="line">        sc.printX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你认为答案是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mSubX is assigned 99</span><br><span class="line">mSubX = 99</span><br></pre></td></tr></table></figure>
<p>那么请继续往下看，因为真实的答案是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SubX is assigned 99</span><br><span class="line">SubX = 1</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="实际分析"><a href="#实际分析" class="headerlink" title="实际分析"></a><strong>实际分析</strong></h2><h3 id="方法重写所产生的影响及其JVM层面的原因"><a href="#方法重写所产生的影响及其JVM层面的原因" class="headerlink" title="方法重写所产生的影响及其JVM层面的原因"></a><strong>方法重写所产生的影响及其JVM层面的原因</strong></h3><p>我觉得首先要给大家说一件非常重要的事情：</p>
<p>SuperClass构造器中的这个方法调用，事实会调用重写后的方法，也就是SubClass中的setX方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       setX(<span class="number">99</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事实调用的是 SubClass 中的setX方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.setX(x);</span><br><span class="line">       mSubX = x;</span><br><span class="line">       System.out.println(<span class="string">"SubX is assigned "</span> + x);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>要想知道发生了什么，最简单的方法就是看看到底程序到底是怎么执行的，比如单步调试，或者直接一点，看看Java字节码。</p>
<p>下面是Main的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"Main.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">Main</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class bugme/SubClass</span><br><span class="line">       <span class="number">3</span>: dup           </span><br><span class="line">       4: invokespecial #3                  // Method bugme/SubClass."&lt;init&gt;":()V</span><br><span class="line">       ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码首先new一个SubClass实例, 把引用入栈, dup是把栈顶复制一份再入栈, invokespecial # 3将栈顶元素出栈并调用它的某个方法, 这个方法具体是什么要看常量池里第3个条目是什么, 但是javap生成的字节码直接给我们写在旁边了, 即SubClass.&lt;init&gt;。</p>
<p>接下来看SubClass.&lt;init&gt;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> bugme.SubClass();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method bugme/SuperClass."&lt;init&gt;":()V</span><br><span class="line">       ......</span><br></pre></td></tr></table></figure>
<p>好了，先看到这，我们来解决几个问题：</p>
<blockquote>
<ol>
<li>new指令之后为什么需要dup指令（操作数栈中为什么会有两个指向SubClass的引用）</li>
<li>&lt;init&gt;方法是什么</li>
</ol>
</blockquote>
<p><strong>首先来解决第一个问题</strong>：</p>
<p>分析一下mian方法的执行顺序吧：</p>
<p>1) 其中new指令在java堆上为SubClass对象分配内存空间，并将指向其地址的引用压入操作数栈顶；<br>2) 然后dup指令为复制操作数栈顶值，并将其压入栈顶，也就是说此时操作数栈上有连续相同的两个引用；<br>3) invokespecial指令调用实例初始化方法&lt;init&gt;:()V，所以需要从操作数栈顶弹出一个this引用，也就是说这一步会弹出一个之前入栈的引用；<br>4) <code>sc.printX()</code>也需要从操作数栈顶取出一个引用类型的值，进行使用；<br>5) 最后由return指令结束方法。</p>
<p>main方法后面的字节码没有贴出，大家可以使用javap命令进行查看。</p>
<p>从上面的五个步骤中可以看出，需要从栈顶弹出两个实例对象的引用，这就是为什么会在new指令下面有一个dup指令，其实对于每一个new指令来说一般编译器都会在其下面生成一个dup指令，这是因为实例的初始化方法肯定需要用到一次，然后第二个留给程序员使用，例如给变量赋值，调用方法，抛出异常等，如果我们不用，那编译器也会生成dup指令，在初始化方法调用完成后再从栈顶pop出来。</p>
<p><strong>再来解决第二个问题</strong>：</p>
<p>我曾经在JVM的其他篇章讲述过&lt;clinit&gt;，如果你对类构造器还不是很清楚，可以翻翻我以前的JVM相关博客或Baidu一下相关资料。</p>
<p>如果你清楚&lt;clinit&gt;，那么&lt;init&gt;与其是相类似的，其名为实例构造器，其实对于实例构造器，我们在之前也做过相关的介绍，但我还是要再次总结。</p>
<p>首先要清楚，我们平常所说的对象的构造方法实际上只是&lt;init&gt;的一个真子集。这是Java帮我们合成的一个方法, <strong>里面的指令会帮我们按顺序进行普通成员变量初始化, 也包括初始化块里的代码, 注意是按顺序执行, 这些都执行完了之后才轮到构造方法里代码生成的指令执行。</strong></p>
<p>但是一般来说，我们都是将成员变量的初始化放在构造方法中，所以<strong>&lt;init&gt;事实上就是将实例代码块中的代码放在对超类构造方法的调用语句之后（super方法），对象自身的构造方法之前合并所产生的一块代码。</strong></p>
<p><strong>对&lt;init&gt;方法的介绍在这篇博客中也有：<a href="http://blog.csdn.net/championhengyi/article/details/78778575" target="_blank" rel="noopener">JVM–详解创建对象与类加载的区别与联系</a></strong></p>
<p>因此我们平常所记忆的关于对象实例化的顺序是这样：父类&lt;clinit&gt; —&gt; 子类&lt;clinit&gt; —&gt; 父类实例块代码 —&gt; 父类构造方法 —&gt; 子类实例块代码 —&gt; 子类构造方法</p>
<p>现在我们可以对其实例化的顺序进行简化：父类&lt;clinit&gt; —&gt; 子类&lt;clinit&gt; —&gt; 父类&lt;init&gt;  —&gt; 子类&lt;init&gt;</p>
<p>刚才说到JVM在处理了new指令、dup指令之后首先调用了SubClass.&lt;init&gt;，我们也解释了&lt;init&gt;构造器。从前面说的我们知道了在&lt;init&gt;构造器中的一个指令就是对父类&lt;init&gt;构造器的调用，结合上面所贴的<code>SubClass.&lt;init&gt;</code>字节码，aload_0就将局部变量表中下标为0的元素入栈, 其实就是Java中的this, 结合<code>invokespecial #1</code>, 是在调用父类的&lt;init&gt;构造器。（<strong>注意这里调用父类构造器的this代表是SubClass</strong>）</p>
<p>解释了所有的问题之后，让我们再继续看SuperClass.&lt;init&gt;：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> bugme.SuperClass();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0       </span><br><span class="line">       <span class="number">5</span>: bipush        <span class="number">99</span></span><br><span class="line">       7: invokevirtual #2                  // Method setX:(I)V</span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span>  </span><br><span class="line">      </span><br><span class="line">  ......     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样是先调了父类Object的&lt;init&gt;构造器, 然后再将this, 99入栈, invokevirtual #2旁边注释了是调用setX, 参数分别是this和99也就是this.setX(99)，最后是return指令，方法结束。</p>
<p>博主当初看到这里的时候，又产生了一个疑惑，为什么JVM会调用重写后的方法，在父类中使用的是<code>this.setX(99)</code>进行调用，JVM是怎么找到重写后方法的入口的？</p>
<p>事实上博主之前认为this代表的是当前对象，方法在哪个对象中，this就代表哪个对象。</p>
<p>如果你和博主有一样的疑惑，那么你也应该好好了解一下this这个关键字了。问题就出在对this的理解上。博主目前并没有找到官方的说法，但是经过代码验证之后，SuperClass中的this表示的还是SubClass。并且在JavaScript中对于this调用是这样描述的：<strong>一个方法由哪个对象调用，这个方法所属的对象就是this。</strong></p>
<p><strong>这个方法被谁调用，这个this就是谁</strong>。可以好好体会这句话。</p>
<p><strong>博主一直以为，this仅代表着当前对象。但是事实看来好像并不如此</strong>。由于是在子类构造器中调用的父类构造器，因此父类中的this代表的也是SubClass。甚至，我现在基本可以肯定，在SuperClass中对Object类的调用，也是SubClass。</p>
<p>那么事情已经变得简单了。既然已经确定了this，那么运用我们之前所说的动态分派知识，也可以明白为什么调用父类构造器中的setX方法会对应至子类的setX方法。</p>
<p>但是内容还不止于此… …</p>
<p>在和学长讨论之后，并且重新翻阅了分派那一节的内容之后，我觉得多态从本质上来说是根据当前栈帧上操作数栈顶引用所代表的实际类型来进行方法的查找，而不能简单的理解为根据方法接受者的实际类型来进行判断（那只是从我们程序员的角度来说）。正如我们上面分析的那样。</p>
<p>怎么理解“<strong>当前栈帧上操作数栈顶引用所代表的实际类型</strong>”呢？等下再说明这个问题。</p>
<p>昨天跟学长的讨论中觉得对多态的浅显认识可以这样理解：</p>
<blockquote>
<p>当初始化子类的时候，所有子类继承的父类，父类的父类的方法都被子类所拥有，而因为子类可以重写父类的方法，所以被重写的方法就不会有体现。</p>
</blockquote>
<p>我对其进行了一点补充：“相当于JVM把父类方法隐藏了，只有通过super.xxx()显式调用才能调用父类方法”。</p>
<p>如果你不想刨根问底，对于多态这样理解的话，我觉得也无可厚非。但是我们需要从JVM层面来考虑一下JVM到底是怎么找到重写后方法的地址入口而将父类方法的地址入口给隐藏了。</p>
<p>在之前我讲多态性实现机制的时候，我遗漏了一个非常重要的东西<strong>invokevirtual指令</strong>，因为当初没有学习JVM指令集，所以直接将这一部分知识略过了，这也导致了我当初对于多态的实现机制一知半解，就直接带大家上车了。</p>
<p>现在我来详细说一下invokevirtual指令的多态查找过程：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做C；</li>
<li>如果在C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用；不通过则抛出IllegalAccessError异常；</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程；</li>
<li>如果始终没有找到合适的方法，就抛出AbstractMethodError异常。</li>
</ol>
<p>而上述步骤就是Java语言中方法重写的本质，而这种在运行期根据实际类型（对应步骤一）确定方法执行版本的分派过程就是<strong>动态分派</strong>！！！</p>
<p>那么我们回到刚才所讨论的代码上，要找到当前栈帧上操作数栈顶引用所代表的实际类型，看一下上面贴出的SuperClass.&lt;init&gt;的字节码。我们发现在调用setX方法之前，对操作数栈压入了this，又弹出this调用了Object的&lt;init&gt;构造器，之后又压入了99和this，此时操作数栈顶引用this所代表的实际类型就是subClass（上面已经进行了验证）。根据动态分派的原理，最后会调用SubClass中的setX方法，也就是重写后的方法。</p>
<h3 id="对象实例化的顺序对运行结果所产生的影响"><a href="#对象实例化的顺序对运行结果所产生的影响" class="headerlink" title="对象实例化的顺序对运行结果所产生的影响"></a><strong>对象实例化的顺序对运行结果所产生的影响</strong></h3><p>上面所述将这篇博客的主要内容已经阐述清楚，但是还有一个问题，我们明白了在子类重写父类方法之后JVM为什么会调用重写后的方法，但是还没有说明程序运行结果的原因。</p>
<p>让我们继续来看Java字节码，调用重写setX方法中的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: iload_1       </span><br><span class="line">       2: invokespecial #3                  // Method bugme/SuperClass.setX:(I)V</span><br><span class="line">       ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里将局部变量表前两个元素都入栈, 第一个是this, 第二个是括号里的参数, 也就是99, invokespecial #3调用的是父类的setX, 也就是我们代码中写的super.setX(int)。</p>
<p>SuperClass.setX就很简单了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  ......     </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: iload_1       </span><br><span class="line">       2: putfield      #3                  // Field mSuperX:I</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先把this入栈, 再把参数入栈, putfield #3使得前两个入栈的元素全部出栈, 而成员mSuperX被赋值, 这四条指令只对应代码里的一句this.mSuperX = x。</p>
<p>接下来控制流回到子类的setX：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">       <span class="number">1</span>: iload_1       </span><br><span class="line">       2: invokespecial #3                  // Method bugme/SuperClass.setX:(I)V</span><br><span class="line">    --&gt;<span class="number">5</span>: aload_0                           <span class="comment">// 即将执行这句</span></span><br><span class="line">       <span class="number">6</span>: iload_1       </span><br><span class="line">       7: putfield      #2                  // Field mSubX:I</span><br><span class="line">      10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      13: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">16</span>: dup           </span><br><span class="line">      17: invokespecial #6                  // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      20: ldc           #7                  // String SubX is assigned </span><br><span class="line">      22: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      <span class="number">25</span>: iload_1       </span><br><span class="line">      26: invokevirtual #9                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">      29: invokevirtual #10                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      32: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">35</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在应该从上面所指向的5处开始执行了，5,6,7将参数的值赋给mSubX, 此时mSubX是99了, 下面那一堆则是在执行System.out.println(“mSubX is assigned “ + x);并返回, 还可以看到Java自动帮我们使用StringBuilder优化字符串拼接, 就不分析了。</p>
<p>都分析到这里了，你也许都会说，子类中的mSubX就是99啊，没毛病。为什么最后答案是1呢？</p>
<p>你也许忘了，好好想一想刚才程序所走的流程—是不是才将父类中&lt;init&gt;构造器流程走完啊。子类初始化，调用父类的&lt;init&gt;，父类的&lt;init&gt;中调用了子类的setX方法，此时mSubX等于99，剩下的子类&lt;init&gt;还没有执行呢！而我们刚才也说了，&lt;init&gt;中包括了实例变量的初始化，因此在执行子类的&lt;init&gt;过程中把1赋给mSubX, 99被1覆盖了。这就是产生最后运行结果的真相！</p>
<p>我们还可以再对照SubClass的字节码进行查看，刚才并没有将SubClass的字节码分析完毕：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">bugme</span>.<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">bugme</span>.<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> bugme.SubClass();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0       </span><br><span class="line">    --&gt;1: invokespecial #1                  // Method bugme/SuperClass."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: aload_0       </span><br><span class="line">       <span class="number">5</span>: iconst_1      </span><br><span class="line">       6: putfield      #2                  // Field mSubX:I</span><br><span class="line">       <span class="number">9</span>: <span class="keyword">return</span>        </span><br><span class="line"></span><br><span class="line">  ......      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们刚才分析到1处就去分析SuperClass中的&lt;init&gt;构造器了，此时mSubX已经是99了, 再执行下面的4,5,6, 将this入栈，将变量1入栈，将1赋值给this.mSubX，这一部分才是SubClass的初始化, 代码将1赋给mSubX, 99被1覆盖了。</p>
<p>最后return指令将方法返回，才相当于我们执行完了箭头指的这一句代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     --&gt;SubClass sc = <span class="keyword">new</span> SubClass();</span><br><span class="line">        sc.printX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来执行的代码将打印mSubX的值, 自然就是1了。</p>
<p>我们基本上将这份代码所产生的字节码文件分析了一遍，相信大家应该有一份额外的感受—JVM真的是基于栈执行的啊！原来这就是基于栈的指令集。</p>
<p>好了，这篇博客到此结束，自认为干货满满，非常有成就感，如果大家在阅读的过程有什么疑惑，欢迎大家留言讨论交流~~</p>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>《深入理解Java虚拟机》– 周志明</p>
<p><a href="http://www.apkbj.com/language/show-21398.html" target="_blank" rel="noopener">java虚拟机指令dup的理解</a></p>
<p><a href="https://www.jianshu.com/p/cdc5adb40bb7" target="_blank" rel="noopener">Java重写方法与初始化的隐患</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/12/20/JVM-浅谈垃圾收集机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/JVM-浅谈垃圾收集机制/" itemprop="url">
                  JVM--浅谈垃圾收集机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-20 20:26:28" itemprop="dateCreated datePublished" datetime="2017-12-20T20:26:28+08:00">2017-12-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">5.7k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">5 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>谈起GC，应该是让Java程序员最激动的一项技术，我相信每个Java程序员都有探究GC本质的冲动！</p>
<p>本篇博客围绕三个问题展开：</p>
<blockquote>
<ol>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ol>
</blockquote>
<hr>
<h2 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a><strong>哪些内存需要回收</strong></h2><p>首先回答第一个问题：不再使用的对象需要进行回收，<strong>不使用的类也有可能回收</strong>。</p>
<p>那么我们如何判断一个对象不再使用呢？主要有以下两种方法。</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a><strong>引用计数算法</strong></h3><p>定义：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减一；任何时刻计数器为0的对象就是不会被使用的对象。</p>
<p>我们可以看出，引用技术方法实现简单。并且有一些GC中确实使用的是引用计数算法，但是在Java虚拟机中并没有使用这个方法进行内存管理，原因就是一个问题很难被解决—<strong>对象之间循环引用</strong>。</p>
<p>来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123; </span><br><span class="line">    Node next ;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Node a = <span class="keyword">new</span> Node (); </span><br><span class="line">Node b = <span class="keyword">new</span> Node (); </span><br><span class="line"></span><br><span class="line">a.next = b ; </span><br><span class="line">b.next = a ; </span><br><span class="line"></span><br><span class="line">a = <span class="keyword">null</span>;</span><br><span class="line">b = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>如上述代码，当我们执行最后两行代码的时候，堆中的对象因为还存在着循环引用，因此引用计数并不是0，导致GC并不会回收这两个对象的内存。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h3><p>Java、C#等语言都是使用这种算法来判定对象是否存活。</p>
<p>基本思想：</p>
<blockquote>
<p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为<strong>引用链</strong>，当一个对象到“GC Roots”没有任何引用链相连的时候，就证明此对象是不可用的。</p>
</blockquote>
<p>如图：</p>
<p><img src="可达性分析算法.png" alt="这里写图片描述"></p>
<p>在Java语言中，可作为GC Root对象包括以下几种：</p>
<blockquote>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中的引用对象。</li>
<li>方法区中的静态属性或常量（final）引用的对象。</li>
<li>本地方法栈中JNI(即一般说的Native方法)引用的对象。 </li>
</ul>
</blockquote>
<h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a><strong>方法区的回收</strong></h3><p>Java虚拟机规范中描述可以不要求虚拟机在方法区实现垃圾收集，因此很多人认为方法区中是没有垃圾收集的。</p>
<p>不要求虚拟机对方法区进行垃圾收集的原因主要是性价比比较低，在堆中，尤其是新生代中，进行一次垃圾收集一般会回收70%～95%的空间，但方法区的垃圾收集率远低于此。</p>
<p>即使这样，对方法区进行垃圾收集也并非没有必要，在大量使用反射、动态代理等这类频繁定义ClassLoader的场景都需要虚拟机卸载类的功能，以保证方法区不会溢出。</p>
<p>方法区的垃圾收集主要回收<strong>废弃常量与无用的类</strong>。</p>
<p>废弃常量的判定与回收比较简单：以“abc”这个常量为例，如果当前系统中没有任何对象引用这个常量，也没有任何其他地方（博主猜测是.class文件中有些地方对此常量的引用）引用这个字面量。此时如果发生内存回收，这个常量就会被清理出常量池。（<strong>常量池中其他类、接口、方法、字段的符号引用与此类似</strong>）</p>
<p>一个无用的类则需要满足以下三个条件：</p>
<blockquote>
<ol>
<li>该类不存在任何实例。</li>
<li>加载该类的ClassLoader已经被回收（条件比较苛刻）。</li>
<li>该类对应的Class对象没有在任何地方被引用，也就是无法使用反射机制。</li>
</ol>
</blockquote>
<p>虚拟机<strong>可以</strong>对满足上述三个条件的无用类进行回收。</p>
<h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a><strong>枚举根节点</strong></h3><p>我们在这个部分应该思考一个关于可达性分析算法的问题，我们应该如何找出那些GC Roots。</p>
<p>目前很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，必然会消耗很多时间。</p>
<p>要解决这个问题，我们首先明确准确式内存管理的概念：虚拟机可以知道内存中某个位置的数据具体是什么类型。基于这点实现，在HotSpot中，使用一组称为OopMap的数据结构来保存内存中对象引用所存储的位置。</p>
<p>一般是在类加载完成的时候，HotSpot就将对象内什么偏移量上是什么类型的数据计算出来，在<strong>JIT编译</strong>（运行期优化）过程中，也会在<strong>特定的位置</strong>记录下栈和寄存器中哪些位置是引用。</p>
<p>这样GC在扫描的时候就可以直接得到这些信息。</p>
<hr>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a><strong>再谈引用</strong></h2><p>引用分为<strong>强引用</strong>（Strong Reference）、<strong>软引用</strong>（Soft Reference）、<strong>弱引用</strong>（Weak Reference）、<strong>虚引用</strong>（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<ol>
<li><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</li>
<li><strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</li>
<li><strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</li>
</ol>
<hr>
<h2 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a><strong>什么时候回收</strong></h2><h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a><strong>finalize方法</strong></h3><p>通过上面几种算法，虚拟机可以知道此时内存中有哪些需要被回收的对象，但是虚拟机什么时候会对这些对象进行回收呢？我们需要来谈一谈finalize方法。</p>
<p>在JVM中，当一个对象通过可达性分析算法被判定为垃圾的时候，JVM并不能直接对其进行回收，一是垃圾回收机制并不是实时进行，二是真正的回收一个对象之前还会判断是否要运行它的finalize方法。</p>
<p>当一个对象被判定为是垃圾之后，它将会被第一次标记并进行一次筛选，筛选的条件就是此对象是否有必要执行finalize方法。</p>
<p>如何判断一个对象是否有必要执行finalize方法呢？</p>
<p>两种情况下虚拟机会视为“没有必要执行”：</p>
<blockquote>
<ul>
<li>对象没有覆盖finalize方法；</li>
<li>finalize方法已经被虚拟机调用过（finalize方法只会被调用一次）。</li>
</ul>
</blockquote>
<p>如果这个对象被判定为有必要执行finalize方法，那么这个对象会被放置在一个叫做F-Queue的队列之中，并在稍后由一个被虚拟机创建的，低优先级的Finalizer线程去执行该对象的finalize()方法，并且对象在finalize()方法执行中如果出现执行缓慢或者发生死循环，将会导致F-Queue队列中其他对象永久处于等待。甚至导致整个内存回收系统崩溃。之后GC将会对F-Queue之中的对象进行第二次标记。如果<strong>在第二次标记前这些对象在自己的finalize()方法中可以拯救自己(重新与引用链上的任何一个对象建立关联即可)</strong>也是可以成功存活下来并被移除“即将回收”的集合的。 如果此时还没有逃脱，那就真的要被回收了。</p>
<p>注意：finalize()方法的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。博主建议大家完全可以忘掉Java语言中有这个方法的存在。</p>
<hr>
<h2 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a><strong>如何回收</strong></h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a><strong>标记清除算法</strong></h3><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是使用可达性算法进行标记的。</p>
<p>不足：</p>
<p>效率问题，标记和清除两个过程的效率都不高。<br>空间问题，标记清除之后会产生大量不连续的内存碎片，导致以后分配较大对象时内存不足以至于不得不提前触发另一次垃圾收集动作。</p>
<p>标记，清除过程图解：</p>
<p><img src="标记清除算法.jpg" alt="这里写图片描述"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制算法</strong></h3><p>将现有的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
<p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大。因此在真正需要垃圾回收的时刻，复制算法的效率是很高的。又由于对象在垃圾回收过程中统一被复制到新的内存空间中，因此，可确保回收后的内存空间是没有碎片的。该算法的缺点是将系统内存折半。</p>
<p>现在的商业虚拟机都采用这种收集算法回收<strong>新生代</strong>，同时我们显然不能忍受内存折半的损耗，好在IBM公司研究表明，新生代中98%的对象都是“朝生夕死”，所以并不需要按照1:1的比例来划分内存空间。</p>
<p>通常是将内存分为一块较大的Eden空间两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机默认Eden和Survivor的比例为8:1。</p>
<p>当每次进行回收时，将Eden和Survivor中还存活的对象一次性的复制到另一块Survivor空间上，然后清理掉Eden和刚才使用的Survivor空间。</p>
<p>当然会存在另一块Survivor空间不够用的情况，这时需要其他内存进行<strong>分配担保</strong>。关于分配担保的内容，我们稍后再说。</p>
<h3 id="内存分配策略与分代收集算法"><a href="#内存分配策略与分代收集算法" class="headerlink" title="内存分配策略与分代收集算法"></a><strong>内存分配策略与分代收集算法</strong></h3><p>也许你会疑惑什么是新生代以及什么是分配担保。</p>
<p>Java堆根据对象存活周期的不同将内存划分为新生代与老年代。新生代又被划分为三个区域：Eden、From Survivor、To Survivor。 </p>
<p>堆的内存模型大致为： </p>
<p><img src="堆的内存模型.jpg" alt="这里写图片描述"></p>
<p>当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代（长期存活的对象进入老年代）。但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代（PretenureSizeThreshold参数的设定）。</p>
<p><strong>Minor GC（新生代GC）</strong>：在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需付出少量存活对象的复制成本就可以完成收集。Minor GC非常频繁，并且回收速度也很快。</p>
<p><strong>Full GC/Major GC（老年代GC）</strong>：老年代中对象存活率高、<strong>没有额外空间对它进行分配担保</strong>，就要使用“标记-清理”或“标记-整理”算法进行回收。回收速度比Minor GC慢上很多，发生也不频繁。</p>
<p><strong>额外说一点：（动态对象年龄判定）</strong></p>
<blockquote>
<p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果新生代中的Eden与from Survivor空间相同年龄对象的大小之和大于to Survivor空间中的一半，则大于或等于这个年龄的对象则无须等到MaxTenuringThreshold中要求的年龄，即可晋升老年代。</p>
<p>（JDK1.6环境下正常运行）。</p>
</blockquote>
<h3 id="分配担保机制"><a href="#分配担保机制" class="headerlink" title="分配担保机制"></a><strong>分配担保机制</strong></h3><p>我们之前说过在新生代GC的时候，会将Eden和Survivor中还存活的对象一次性的复制到另一块Survivor空间上，然后清理掉Eden和刚才使用的Survivor空间。</p>
<p>但是会存在另一块Survivor空间不够用的情况，这时就需要分配担保了。</p>
<p>其实在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否<strong>大于新生代所有对象的总大小</strong>，如果大于，则此次Minor GC是安全的。如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许开启分配担保机制。如果HandlePromotionFailure=true，说明开启了分配担保机制，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</p>
<p>上面提到了Minor GC依然会有风险，是因为<strong>新生代采用复制收集算法</strong>，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</p>
<p>但取平均值仍然是一种概率性的事件，如果某次Minor GC后存活对象陡增，远高于平均值的话，必然导致担保失败。如果出现了分配担保失败，就只能在失败后重新发起一次Full GC。虽然存在发生这种情况的概率，但大部分时候都是能够成功分配担保的，这样就避免了过于频繁执行Full GC。</p>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p>《深入理解Java虚拟机》—周志明</p>
<p><a href="http://www.bijishequ.com/detail/543280?p=58" target="_blank" rel="noopener">深入理解Java虚拟机读书笔记 - 垃圾收集算法</a></p>
<p><a href="http://blog.csdn.net/gyqjn/article/details/49848473" target="_blank" rel="noopener">Java GC、新生代、老年代</a></p>
<p><a href="http://www.jianshu.com/p/62c37dc7d638" target="_blank" rel="noopener">空间分配担保</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/12/17/JVM-剖析类与对象在JVM中从生存至死亡/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/17/JVM-剖析类与对象在JVM中从生存至死亡/" itemprop="url">
                  JVM--剖析类与对象在JVM中从生存至死亡
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-17 12:52:20" itemprop="dateCreated datePublished" datetime="2017-12-17T12:52:20+08:00">2017-12-17</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">10k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">10 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面学习了Class文件结构、类的加载机制、字节码执行引擎、对象的创建与销毁，所以我准备从一个Java代码进行切入，详细剖析它的生命历程，将所学的知识真正的用起来，也算是对前面所学的知识进行一个系统的总结。</p>
<hr>
<p>我们以这份Java代码为例，来剖析一个Java程序的生命历程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getClassName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span> <span class="keyword">implements</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    String className;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String className;</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            className = scanner.next();</span><br><span class="line">            Company company = <span class="keyword">new</span> Company(className);</span><br><span class="line">            System.out.println(<span class="string">"name="</span> + company.getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这份代码涉及到了接口，继承，对象的实例化，main方法，值得我们花费一些功夫去从JVM层面上了解这个程序从编译、运行到结束都发生了哪些事情。</p>
<p>所以，别急，让我们按顺序慢慢来分析。</p>
<hr>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a><strong>编译阶段</strong></h2><p>首先你要运行一个java程序，肯定要对其进行编译，生成我们前面说的Class文件，这段代码会生成3个Class文件。</p>
<p>Class文件中保存了<strong>魔数、版本符号、常量池、方法标志、类索引、父类索引、接口索引、字段表（有可能含有属性表）、方法表（有可能含有属性表）</strong>等信息。这些信息具体的组成结构，我在这里不再赘述。</p>
<p>我们可以通过字节码文件，清晰的描述出Java源码中有关类的所有信息。</p>
<p>在这里只以Main类为例，使用javap命令看一下生成的Class文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose Main;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">  Last modified <span class="number">2017</span>-<span class="number">12</span>-<span class="number">13</span>; size <span class="number">852</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">0336f</span>a14cc04a9c858c34cc016880c19</span><br><span class="line">  Compiled from <span class="string">"Main.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #18.#29        // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Class              #30            // java/util/Scanner</span><br><span class="line">   #3 = Fieldref           #31.#32        // java/lang/System.in:Ljava/io/InputStream;</span><br><span class="line">   #4 = Methodref          #2.#33         // java/util/Scanner."&lt;init&gt;":(Ljava/io/InputStream;)V</span><br><span class="line">   #5 = Methodref          #2.#34         // java/util/Scanner.hasNext:()Z</span><br><span class="line">   #6 = Methodref          #2.#35         // java/util/Scanner.next:()Ljava/lang/String;</span><br><span class="line">   #7 = Class              #36            // Company</span><br><span class="line">   #8 = Methodref          #7.#37         // Company."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">   #9 = Fieldref           #31.#38        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">  #10 = Class              #39            // java/lang/StringBuilder</span><br><span class="line">  #11 = Methodref          #10.#29        // java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">  #12 = String             #40            // name=</span><br><span class="line">  #13 = Methodref          #10.#41        // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #14 = Methodref          #7.#42         // Company.getClassName:()Ljava/lang/String;</span><br><span class="line">  #15 = Methodref          #10.#43        // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">  #16 = Methodref          #44.#45        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #17 = Class              #46            // Main</span><br><span class="line">  #18 = Class              #47            // java/lang/Object</span><br><span class="line">  #19 = Utf8               &lt;init&gt;</span><br><span class="line">  #20 = Utf8               ()V</span><br><span class="line">  #21 = Utf8               Code</span><br><span class="line">  #22 = Utf8               LineNumberTable</span><br><span class="line">  #23 = Utf8               main</span><br><span class="line">  #24 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #25 = Utf8               StackMapTable</span><br><span class="line">  #26 = Class              #30            // java/util/Scanner</span><br><span class="line">  #27 = Utf8               SourceFile</span><br><span class="line">  #28 = Utf8               Main.java</span><br><span class="line">  #29 = NameAndType        #19:#20        // "&lt;init&gt;":()V</span><br><span class="line">  #30 = Utf8               java/util/Scanner</span><br><span class="line">  #31 = Class              #48            // java/lang/System</span><br><span class="line">  #32 = NameAndType        #49:#50        // in:Ljava/io/InputStream;</span><br><span class="line">  #33 = NameAndType        #19:#51        // "&lt;init&gt;":(Ljava/io/InputStream;)V</span><br><span class="line">  #34 = NameAndType        #52:#53        // hasNext:()Z</span><br><span class="line">  #35 = NameAndType        #54:#55        // next:()Ljava/lang/String;</span><br><span class="line">  #36 = Utf8               Company</span><br><span class="line">  #37 = NameAndType        #19:#56        // "&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">  #38 = NameAndType        #57:#58        // out:Ljava/io/PrintStream;</span><br><span class="line">  #39 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #40 = Utf8               name=</span><br><span class="line">  #41 = NameAndType        #59:#60        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #42 = NameAndType        #61:#55        // getClassName:()Ljava/lang/String;</span><br><span class="line">  #43 = NameAndType        #62:#55        // toString:()Ljava/lang/String;</span><br><span class="line">  #44 = Class              #63            // java/io/PrintStream</span><br><span class="line">  #45 = NameAndType        #64:#56        // println:(Ljava/lang/String;)V</span><br><span class="line">  #46 = Utf8               Main</span><br><span class="line">  #47 = Utf8               java/lang/Object</span><br><span class="line">  #48 = Utf8               java/lang/System</span><br><span class="line">  #49 = Utf8               in</span><br><span class="line">  #50 = Utf8               Ljava/io/InputStream;</span><br><span class="line">  #51 = Utf8               (Ljava/io/InputStream;)V</span><br><span class="line">  #52 = Utf8               hasNext</span><br><span class="line">  #53 = Utf8               ()Z</span><br><span class="line">  #54 = Utf8               next</span><br><span class="line">  #55 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #56 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #57 = Utf8               out</span><br><span class="line">  #58 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #59 = Utf8               append</span><br><span class="line">  #60 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #61 = Utf8               getClassName</span><br><span class="line">  #62 = Utf8               toString</span><br><span class="line">  #63 = Utf8               java/io/PrintStream</span><br><span class="line">  #64 = Utf8               println</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">27</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class java/util/Scanner</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: getstatic     #3                  // Field java/lang/System.in:Ljava/io/InputStream;</span><br><span class="line">         7: invokespecial #4                  // Method java/util/Scanner."&lt;init&gt;":(Ljava/io/InputStream;)V</span><br><span class="line">        <span class="number">10</span>: astore_2</span><br><span class="line">        <span class="number">11</span>: aload_2</span><br><span class="line">        12: invokevirtual #5                  // Method java/util/Scanner.hasNext:()Z</span><br><span class="line">        <span class="number">15</span>: ifeq          <span class="number">63</span></span><br><span class="line">        <span class="number">18</span>: aload_2</span><br><span class="line">        19: invokevirtual #6                  // Method java/util/Scanner.next:()Ljava/lang/String;</span><br><span class="line">        <span class="number">22</span>: astore_1</span><br><span class="line">        23: new           #7                  // class Company</span><br><span class="line">        <span class="number">26</span>: dup</span><br><span class="line">        <span class="number">27</span>: aload_1</span><br><span class="line">        28: invokespecial #8                  // Method Company."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">31</span>: astore_3</span><br><span class="line">        32: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        35: new           #10                 // class java/lang/StringBuilder</span><br><span class="line">        <span class="number">38</span>: dup</span><br><span class="line">        39: invokespecial #11                 // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">        42: ldc           #12                 // String name=</span><br><span class="line">        44: invokevirtual #13                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        <span class="number">47</span>: aload_3</span><br><span class="line">        48: invokevirtual #14                 // Method Company.getClassName:()Ljava/lang/String;</span><br><span class="line">        51: invokevirtual #13                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        54: invokevirtual #15                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        57: invokevirtual #16                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">60</span>: goto          <span class="number">11</span></span><br><span class="line">        <span class="number">63</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">31</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">32</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">33</span>: <span class="number">18</span></span><br><span class="line">        line <span class="number">34</span>: <span class="number">23</span></span><br><span class="line">        line <span class="number">35</span>: <span class="number">32</span></span><br><span class="line">        line <span class="number">36</span>: <span class="number">60</span></span><br><span class="line">        line <span class="number">37</span>: <span class="number">63</span></span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">253</span> <span class="comment">/* append */</span></span><br><span class="line">          offset_delta = <span class="number">11</span></span><br><span class="line">          locals = [ top, class java/util/Scanner ]</span><br><span class="line">        frame_type = <span class="number">51</span> <span class="comment">/* same */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SourceFile: <span class="string">"Main.java"</span></span><br></pre></td></tr></table></figure>
<p>我们大概分析一下上面的输出结果吧：</p>
<p>直接从常量池开始分析，前面的几行信息我认为没有分析的必要。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 = Methodref          #18.#29        // java/lang/Object."&lt;init&gt;":()V</span><br></pre></td></tr></table></figure>
<p>这是常量池里面的第一项数据，#1代表索引，Methodref告诉我们常量池中第一个索引表示的是一个方法引用，对这个方法引用的描述用常量池中第18项和第29项的内容可以进行描述，你们可以查一下常量池中第18项和第29项的内容，其实对应的就是后面注释的内容。它告诉了你这个方法所属的类是Object，方法的<strong>简单名称</strong>是&lt;init&gt;，方法的<strong>描述符</strong>是()V，也就是Object中的实例构造函数（对简单名称和描述符我在前面的博客中已经进行了说明）。</p>
<p>你也许想问，为什么Main类常量池中的第一项数据描述的是Object类中的无参构造函数？你可能忘了，所有类都应如此，Java中所有的类都继承自Object，常量池中也会保存他们父类的索引，因为在Java中，对象的初始化与实例化不是还有一条规则嘛—先初始化与实例化父类，然后才是子类（说的并不精确，明白我的意思就行）。</p>
<p>剩余的常量池分析与上面类似。</p>
<p>常量池下面的代码块，可以看到，一个Main类的默认构造函数，一个就是main方法了。关于这两个东西，我们等一下在字节码的执行阶段再说。</p>
<p>可以看到，Class文件中，包含着详细的信息，有大量的信息都是你无法从源码中直接得到的。</p>
<hr>
<h2 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a><strong>类加载阶段</strong></h2><p>javac对源文件编译完成，我们使用java命令开始运行这个Main类。<strong>java命令只能运行包含main方法的类</strong>。</p>
<p>java命令一开始运行，JVM开始对Main类进行<strong>加载</strong>。</p>
<p>这时候就对应了我们学习类加载机制的每个阶段：加载（从.class文件中读取字节码）、验证（对字节码文件进行一系列的验证保证格式无误并且对JVM不会产生危害）、准备（为类变量分配内存并进行系统初始化）、解析（分为静态链接与动态链接，非虚方法的符号引用会在这一阶段被解析为直接引用）、初始化（执行类构造器）。</p>
<p>我再对其过程进行一点点补充，如果想要更加详细的说明，请移步至我的博客专栏。</p>
<p>JVM在加载这个Main类的时候，使用<strong>类加载器（双亲委派模型）</strong>对其进行加载，经历了加载、验证（在这个时候又会<strong>触发Object类的加载</strong>）阶段，由于在Main类中并没有类变量，也就相当于跳过了准备这一阶段，然后对字节码进行解析，由于main方法是静态方法，也就是非虚方法，开始<strong>静态链接</strong>，在字节码中直接将main方法的符号引用解析为直接引用（别忘了Main类反编译之后的默认构造器～），由于没有静态变量与静态语句块，所以初始化这一阶段也相当于是直接跳过，最后整个加载过程完毕，并在方法区中生成Main类所对应的<strong>Class对象</strong>。</p>
<p>由于我这个例子中不涉及多态，也就不涉及<strong>分派</strong>，但这部分知识请务必掌握。</p>
<hr>
<h2 id="方法执行阶段"><a href="#方法执行阶段" class="headerlink" title="方法执行阶段"></a><strong>方法执行阶段</strong></h2><p>类中所有的信息已经在内存中加载完毕，JVM开始进行<strong>方法调用</strong>… …</p>
<p><strong>方法调用</strong>：JVM开始执行main方法，这部分工作是由虚拟机中字节码执行引擎完成的。main方法会由一个线程进行调用。此线程会在虚拟机栈上为自己开辟一部分的栈空间，此后只要这个线程调用新的方法，这个方法便会被当作<strong>栈帧</strong>压入虚拟机栈的栈顶（<strong>作为当前栈帧</strong>）。这个方法中定义的局部变量会被存储进局部变量表，在JVM中，并不存储局部变量的名称，他们都是以局部变量表的<strong>相对偏移量</strong>来标识每个不同的局部变量。</p>
<p>我以main方法的Code属性再说明一下栈帧中的局部变量表以及操作数栈。（Class文件中方法表的Code属性保存的是Java方法体中的字节码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，main方法在调用之前（实际上在编译阶段，它的局部变量表，操作数栈的大小都已确定），locals为4，也就是局部变量表的大小为4：this，className，scanner，company；stack为3，也就是操作数栈的大小3：className，scanner，company。</p>
<p>我们还可以在上面方法体的字节码当中看到许多指令，而这些指令就是方法在执行的过程中，JVM需要解释运行的，如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0: new           #2                  // class java/util/Scanner</span><br></pre></td></tr></table></figure>
<p>前面的0表示的也是相对偏移量，而new指令就是新建一个对象，对应Java源码中的new，后面的#2代表的是new指令的参数，表达的意思是常量池中索引为2的数据项，也就是上述代码后面注释中的Scanner类。</p>
<p>值得一说的是，这里的Scanner由于是对类的实例化，因此JVM会首先判断Scanner这个类是否会被加载进内存，如果没有被加载进内存，JVM开始对这个类进行类加载，过程如上述步骤，然后进行对象的初始化。</p>
<p>指令一条条的向下面执行（<strong>程序计数器</strong>），进入循环体，最终执行到这一步：<code>Company company = new Company(className);</code>，也是一个对类的实例化，但它和上面的Scanner又有点不同，这个类不仅实现了ClassName接口，而且实例化的时候还进行了传参。那么何时会加载ClassName接口呢，博主根据查阅的资料，<strong>猜测</strong>是在Company类加载中的验证阶段会触发其接口的加载，具体大家可以Google、baidu。</p>
<p>那么如何实现参数的传递呢，相信大家应该是有印象的，它是在实例化Company类的过程中，执行了Company的构造方法，而构造方法本身又是一个方法，因此可以理解为实参先进入被调用方法的操作数栈中，然后将操作数栈中的引用出栈赋值给被调用方法的局部变量表。</p>
<p>最后，代码执行完毕，程序退出。</p>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="http://www.cnblogs.com/richaaaard/p/6214929.html" target="_blank" rel="noopener">JVM 内部原理（六）— Java 字节码基础之一</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.dhengyi.name/2017/12/12/JVM-详解创建对象与类加载的区别与联系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dhengyi">
      <meta itemprop="description" content="忍耐力较诸脑力，尤胜一筹。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="H.Y's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/12/JVM-详解创建对象与类加载的区别与联系/" itemprop="url">
                  JVM--详解创建对象与类加载的区别与联系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-12 11:40:51" itemprop="dateCreated datePublished" datetime="2017-12-12T11:40:51+08:00">2017-12-12</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">4.7k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">4 分钟</span>
              
            </div>
          

          
          
        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在前几篇博客中，我们探究了.class文件的本质，类的加载机制，JVM运行时的栈帧结构以及字节码执行时对应操作数栈以及局部变量表的变化。</p>
<p>如果你已经掌握了这些东西，你现在应该会有一种感觉，给你一个Java代码，你可以从JVM的层面上将这个类从javac编译成.class文件开始，到使用java命令运行这个Class文件，然后这个类的运行过程是怎么样的，你可以解释清楚。</p>
<p>但是等等，好像少了点什么？我们好像没有谈及<strong>JVM中对象的创建</strong>？也就是说，在Java代码中，你new一个对象，这时候都发生哪些事情，这就是今天我所要说的。</p>
<hr>
<h2 id="对象创建的时机"><a href="#对象创建的时机" class="headerlink" title="对象创建的时机"></a><strong>对象创建的时机</strong></h2><p>我们先不说对象创建的具体过程是啥，我们先来谈一谈什么时候JVM会创建对象。</p>
<p>以下5种方式，会使JVM帮助你创建一个对象：</p>
<h3 id="使用new关键字创建对象"><a href="#使用new关键字创建对象" class="headerlink" title="使用new关键字创建对象"></a><strong>使用new关键字创建对象</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<h3 id="使用Class类的newInstance方法-反射机制"><a href="#使用Class类的newInstance方法-反射机制" class="headerlink" title="使用Class类的newInstance方法(反射机制)"></a><strong>使用Class类的newInstance方法(反射机制)</strong></h3><p>newInstance方法只能调用无参的构造器创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student student2 = (Student)Class.forName(<span class="string">"Student类全限定名"</span>).newInstance();　</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Student stu = Student.class.newInstance();</span><br></pre></td></tr></table></figure>
<h3 id="使用Constructor类的newInstance方法-反射机制"><a href="#使用Constructor类的newInstance方法-反射机制" class="headerlink" title="使用Constructor类的newInstance方法(反射机制)"></a><strong>使用Constructor类的newInstance方法(反射机制)</strong></h3><p>java.lang.relect.Constructor类里也有一个newInstance方法可以创建对象，该方法和Class类中的newInstance方法很像，但是相比之下，Constructor类的newInstance方法更加强大些，我们可以通过这个newInstance方法调用有参数的和私有的构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 首先得到要实例化类的构造器（有参）</span></span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class</span><br><span class="line">                .getConstructor(Integer.class);</span><br><span class="line">        Student stu3 = constructor.newInstance(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上Class的newInstance方法内部调用的也是Constructor的newInstance方法。</p>
<h3 id="使用Clone方法创建对象"><a href="#使用Clone方法创建对象" class="headerlink" title="使用Clone方法创建对象"></a><strong>使用Clone方法创建对象</strong></h3><p>无论何时我们调用一个对象的clone方法，JVM都会帮我们创建一个新的、一样的对象，特别需要说明的是，用clone方法创建对象的过程中并不会调用任何构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class</span><br><span class="line">                .getConstructor(Integer.class);</span><br><span class="line">        Student stu3 = constructor.newInstance(<span class="number">123</span>);</span><br><span class="line">        Student stu4 = (Student) stu3.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-反-序列化机制创建对象"><a href="#使用-反-序列化机制创建对象" class="headerlink" title="使用(反)序列化机制创建对象"></a><strong>使用(反)序列化机制创建对象</strong></h3><p>当我们反序列化一个对象时，JVM会给我们创建一个单独的对象，在此过程中，JVM并不会调用任何构造函数。为了反序列化一个对象，我们需要让我们的类实现Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student [id="</span> + id + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class</span><br><span class="line">                .getConstructor(Integer.class);</span><br><span class="line">        Student stu3 = constructor.newInstance(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写对象</span></span><br><span class="line">        ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"student.bin"</span>));</span><br><span class="line">        output.writeObject(stu3);</span><br><span class="line">        output.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读对象</span></span><br><span class="line">        ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                <span class="string">"student.bin"</span>));</span><br><span class="line">        Student stu5 = (Student) input.readObject();</span><br><span class="line">        System.out.println(stu5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="创建对象与类加载的区别与联系"><a href="#创建对象与类加载的区别与联系" class="headerlink" title="创建对象与类加载的区别与联系"></a><strong>创建对象与类加载的区别与联系</strong></h2><p>在明白了对象何时会被创建之后，现在我们就说一说，对象的创建与类加载的区别与联系。</p>
<p>当碰到上面所述5种情况的任何一种，都会触发对象的创建。</p>
<h3 id="对象创建的过程"><a href="#对象创建的过程" class="headerlink" title="对象创建的过程"></a><strong>对象创建的过程</strong></h3><blockquote>
<ol>
<li>首先是对象创建的时机，在碰到new关键字，使用反射机制（class的new Instance、constructor的new Instance），使用clone等，会触发对象的创建。</li>
<li>在分配内存之前，JVM首先会解析是否能在运行时常量池中定位到这个类的符号引用，定位之后会判断这个类是否已经被加载、解析、初始化。如果没有，则先进行类的加载。</li>
<li>在确定对象需要创建之后，给对象开始分配内存，在分配内存的过程中，需要注意使用的是哪一种垃圾收集算法，因为垃圾收集算法的不同会导致内存块是否规整，也就影响到分配内存的方式是使用指针碰撞还是使用空闲列表。</li>
<li>在进行内存分配的时候，如果使用的是指针碰撞方法，还需要注意并发情况下，内存的分配是否是线程安全的。一般使用加同步块的方式和本地线程分配缓冲这两种方式解决线程安全的问题。</li>
<li>内存分配完毕之后就是JVM对其内存块进行默认初始化，这也是对象的实例变量不需要显示初始化就可以直接使用的原因。</li>
<li>从JVM的角度来看，一个对象就此创建完毕，但是从程序的角度来看，一个对象的创建才刚刚开始，它还没有运行&lt;init&gt;（实例初始化方法），所有的字段都还为默认值。只有运行了&lt;init&gt;之后，一个真正可用的对象才算产生出来。</li>
</ol>
</blockquote>
<p>具体过程如下图：</p>
<p><img src="对象创建的过程.png" alt="这里写图片描述"></p>
<h3 id="对象的组成"><a href="#对象的组成" class="headerlink" title="对象的组成"></a><strong>对象的组成</strong></h3><p>符号引用解析完毕之后，JVM会为对象在堆中分配内存，HotSpot虚拟机实现的Java对象包括三个部分：对象头、实例字段和对齐填充字段（非必须）。</p>
<p><strong>对象头主要包括两部分</strong>：</p>
<ol>
<li>用于存储对象自身的运行时数据（哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）</li>
<li>类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li>
</ol>
<p><img src="对象头.jpg" alt="这里写图片描述"></p>
<p><strong>实例字段包括</strong>自身定义的和从父类继承下来的（即使父类的实例字段被子类覆盖或者被private修饰，都照样为其分配内存）。相信很多人在刚接触面向对象语言时，总把继承看成简单的“复制”，这其实是完全错误的。JAVA中的继承仅仅是类之间的一种逻辑关系（具体如何保存记录这种逻辑关系，则设计到Class文件格式的知识，之前也有说过），唯有创建对象时的实例字段，可以简单的看成“复制”。</p>
<p>为对象分配完堆内存之后，JVM会将该内存（除了对象头区域）进行零值初始化，这也就解释了为什么Java的属性字段无需显示初始化就可以被使用，而方法的局部变量却必须要显示初始化后才可以访问。最后，JVM会调用对象的构造函数，当然，调用顺序会一直上溯到Object类。</p>
<p><img src="实例化类的递归过程.png" alt="这里写图片描述"></p>
<p>关于对象的实例化过程我下面详细说明，如图可得它是一个递归的过程。</p>
<h3 id="lt-init-gt-方法"><a href="#lt-init-gt-方法" class="headerlink" title="&lt;init&gt;方法"></a><strong>&lt;init&gt;方法</strong></h3><p>我们在类的加载机制一文中曾经说过&lt;clinit&gt;（类构造器），这个方法会在类的初始化阶段发挥作用，主要是收集类变量的赋值动作与静态语句块。</p>
<p>&lt;init&gt;有类似的作用。它也会将实例变量的赋值动作与实例代码块进行收集。说的详细点，如果我们对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将其中的代码放到类的构造函数中去，并且这些代码会被放在对超类构造函数的调用语句之后(Java要求构造函数的第一条语句必须是超类构造函数的调用语句)，构造函数本身的代码之前。</p>
<p><strong>&lt;init&gt;()就是指收集类中的所有实例变量的赋值动作、实例代码块和构造函数合并产生的。</strong></p>
<p>我们将类构造器和实例构造器的初始化过程做一个总结：<strong>父类的类构造器<clinit>() -&gt; 子类的类构造器<clinit>() -&gt; 父类成员变量的赋值和实例代码块 -&gt; 父类的构造函数 -&gt; 子类成员变量的赋值和实例代码块 -&gt; 子类的构造函数。</clinit></clinit></strong></p>
<h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a><strong>对象的引用</strong></h3><p>至此，一个对象就被创建完毕，此时，一般会有一个引用指向这个对象。在Java中，存在两种数据类型，一种就是诸如int、double等基本类型，另一种就是引用类型，比如类、接口、内部类、枚举类、数组类型的引用等。引用的实现方式一般有两种，如下图。</p>
<p><img src="对象的引用方式.jpg" alt="这里写图片描述"></p>
<hr>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a><strong>参考阅读</strong></h2><p><a href="http://www.cnblogs.com/chenyangyao/p/5296807.html" target="_blank" rel="noopener">图解JAVA对象的创建过程</a></p>
<p><a href="http://blog.csdn.net/justloveyou_/article/details/72466416" target="_blank" rel="noopener">深入理解Java对象的创建过程：类的初始化与实例化</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">dhengyi</p>
              <p class="site-description motion-element" itemprop="description">忍耐力较诸脑力，尤胜一筹。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">52</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dhengyi</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">273k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">4:08</span>
  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
